[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 6.2_Raft.mp4
Video File: 6.2_Raft.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 293
Active Line: 307
Video Position: 35487

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:00.92,0:00:05.76,Default,,0,0,0,,本节 我们将带大家浏览一遍\NNow, in this section, I'm going to walk you through the entire Raft consensus algorithm 
Dialogue: 0,0:00:05.76,0:00:08.16,Default,,0,0,0,,Raft共识算法实现全序关系广播的完整流程\Nfor performing total order broadcast.
Dialogue: 0,0:00:08.16,0:00:09.40,Default,,0,0,0,,我这里要给出一个警告\NNow, I'm going to warn you.
Dialogue: 0,0:00:09.40,0:00:11.06,Default,,0,0,0,,这是一个相对比较复杂的算法\NIt's a rather complex algorithm.
Dialogue: 0,0:00:11.06,0:00:14.16,Default,,0,0,0,,这是我们在本课程中学习的最复杂的算法\NIt's by far the most complex algorithm we will see in this course.
Dialogue: 0,0:00:14.56,0:00:18.42,Default,,0,0,0,,介绍整个算法的伪代码需要9页幻灯片\NIt takes 9 slides of pseudocode to explain the whole algorithm.
Dialogue: 0,0:00:18.42,0:00:20.68,Default,,0,0,0,,我不期待大家能完整记住这个算法\NAnd I'm not expecting you to memorize it all.
Dialogue: 0,0:00:20.68,0:00:24.82,Default,,0,0,0,,我希望大家可以认真理解\NWhat I would like you to do though is to carefully understand 
Dialogue: 0,0:00:24.82,0:00:27.96,Default,,0,0,0,,算法的工作原理及其背后的原因\Nexactly how and why the algorithm works,
Dialogue: 0,0:00:27.96,0:00:31.62,Default,,0,0,0,,因为我发现 理解Raft算法的工作原理\Nbecause I find that the principles of how the Raft algorithm works 
Dialogue: 0,0:00:31.62,0:00:37.12,Default,,0,0,0,,对于理解分布式系统中的状态具有很强的启发意义\Nare really instructive for thinking about state in a distributed system more generally.
Dialogue: 0,0:00:37.12,0:00:38.98,Default,,0,0,0,,我们开始吧\NOK, so, let's start.
Dialogue: 0,0:00:38.98,0:00:42.28,Default,,0,0,0,,Raft算法的核心是一个状态机\NThe core of the Raft algorithm is a state machine,
Dialogue: 0,0:00:42.28,0:00:47.56,Default,,0,0,0,,每个节点可以处于三种状态之一：从节点、候选节点、主节点\Nwhere every node can be in one of three states, either a follower, a candidate, or a leader.
Dialogue: 0,0:00:47.56,0:00:51.74,Default,,0,0,0,,每个任期只可能有一个状态\NAnd the state is always in a certain term.
Dialogue: 0,0:00:51.74,0:00:53.40,Default,,0,0,0,,系统包含一个特定的任期数\NSo, there's always a certain term number, 
Dialogue: 0,0:00:53.40,0:00:56.64,Default,,0,0,0,,一个节点可以在特定的任期内成为主节点\Nand a node can be the leader in a particular term.
Dialogue: 0,0:00:56.64,0:01:03.10,Default,,0,0,0,,当一个节点第一次启动时 它总会进入从节点状态\NWhen a node starts up for the first time, it always goes into the follower state.
Dialogue: 0,0:01:03.10,0:01:06.44,Default,,0,0,0,,如果一个节点崩溃并随后恢复\NAnd also, if a node crashes and recovers,
Dialogue: 0,0:01:06.44,0:01:09.54,Default,,0,0,0,,当此节点重启 并从崩溃状态恢复后\Nand then when the node restarts and recovers from the crash,
Dialogue: 0,0:01:09.54,0:01:11.72,Default,,0,0,0,,无论此节点在崩溃前处于什么状态\Nit always goes back into the follower state, 
Dialogue: 0,0:01:11.72,0:01:14.98,Default,,0,0,0,,它都会回到从节点状态\Nregardless of which state it was in before the crash.
Dialogue: 0,0:01:14.98,0:01:17.48,Default,,0,0,0,,然而 所有节点启动时都是从节点\NHowever, all of the nodes start as followers,
Dialogue: 0,0:01:17.48,0:01:19.62,Default,,0,0,0,,但我们最终总需要让一个节点成为主节点\Neventually, we need some node to become the leader.
Dialogue: 0,0:01:19.62,0:01:23.28,Default,,0,0,0,,节点想要成为主节点 首先要成为候选节点\NAnd the way how a node becomes the leader is by first becoming a candidate.
Dialogue: 0,0:01:23.28,0:01:26.72,Default,,0,0,0,,当一个节点检查到\NAnd so, when a node detects that 
Dialogue: 0,0:01:26.72,0:01:31.72,Default,,0,0,0,,已经有一段时间没有从主节点收到消息了 已经出现了超时情况\Nthere has been no message from a leader for some amount of time, a timeout elapses,
Dialogue: 0,0:01:31.72,0:01:33.86,Default,,0,0,0,,那么此节点将决定\Nand then a node will decide that, 
Dialogue: 0,0:01:33.86,0:01:37.72,Default,,0,0,0,,在这一特定任期内 我可以站出来 成为候选节点\NOK, it is going to stand as candidate in a particular term number.
Dialogue: 0,0:01:37.72,0:01:42.28,Default,,0,0,0,,在这一任期数内 它将尝试从其他节点处得到选票\NAnd within that term number, it's going to try to get votes from the other nodes.
Dialogue: 0,0:01:42.28,0:01:45.92,Default,,0,0,0,,如果它能得到系统中大多数节点的选票\NAnd if it manages to get positive votes 
Dialogue: 0,0:01:45.92,0:01:49.26,Default,,0,0,0,,即多半quorum节点为此节点投票\Nfrom a quorum of nodes in the system, from a majority,
Dialogue: 0,0:01:49.26,0:01:52.36,Default,,0,0,0,,则这个节点就能够转变为主节点状态\Nthen it is able to transition into the leader state.
Dialogue: 0,0:01:53.30,0:01:58.52,Default,,0,0,0,,然而 也可能出现的一种情况是 在此次选举过程中\NHowever, it could also happen that in the process of this election,
Dialogue: 0,0:01:58.52,0:02:02.30,Default,,0,0,0,,候选节点发现另一个节点有更高的任期数\Nthe candidate discovers that there's a different node with a higher term number.
Dialogue: 0,0:02:02.30,0:02:07.34,Default,,0,0,0,,如果发生了这种情况 则候选节点将立即退回为从节点\NAnd if it does, so, then the candidate immediately steps back becomes follower again,
Dialogue: 0,0:02:07.34,0:02:11.46,Default,,0,0,0,,并与拥有更高任期数的节点一同工作\Nand works with the node that has the higher term number.
Dialogue: 0,0:02:11.46,0:02:15.20,Default,,0,0,0,,也就是说 更高任期的优先级总是更高\NSo, a higher term number always takes precedence.
Dialogue: 0,0:02:15.20,0:02:18.42,Default,,0,0,0,,当节点处于候选节点状态时 还可能出现另一种情况\NIt could also happen while a node is in the candidate state.
Dialogue: 0,0:02:18.42,0:02:20.86,Default,,0,0,0,,节点参与了选举 但是节点当前\NIt's doing the election, but maybe it's not able to 
Dialogue: 0,0:02:20.86,0:02:24.34,Default,,0,0,0,,无法与足够多的quorum副本或quorum节点通信\Ncommunicate with a quorum of replicas right now, or quorum of nodes.
Dialogue: 0,0:02:24.34,0:02:26.18,Default,,0,0,0,,因此 选举超时了\NAnd so, it times out.
Dialogue: 0,0:02:26.62,0:02:32.98,Default,,0,0,0,,此节点在规定时间内无法收到quorum节点足够数量的选票\NSo, it simply doesn't receive a quorum of positive votes within the required time.
Dialogue: 0,0:02:32.98,0:02:38.54,Default,,0,0,0,,如果出现了这种情况 此节点将用更高的任期数重启选举\NAnd if, so it will restart its election again with a higher term number.
Dialogue: 0,0:02:38.54,0:02:43.04,Default,,0,0,0,,也就是说 此节点仍然为候选节点状态 用更高的任期数重启选举\NSo, it remains candidate and starts again with a higher term number.
Dialogue: 0,0:02:43.84,0:02:48.08,Default,,0,0,0,,同样地 主节点在执行主节点的工作时 还可能发生一种情况\NLikewise, it could happen if the leader is just doing its leadering job.
Dialogue: 0,0:02:48.50,0:02:51.98,Default,,0,0,0,,主节点发现系统中出现了一个持有更高任期数的节点\NIt might discover that there's a node with a higher term number.
Dialogue: 0,0:02:52.44,0:02:57.14,Default,,0,0,0,,可能系统出现了网络分区 一些子集节点\NPerhaps the system has been partitioned so that some subset of nodes 
Dialogue: 0,0:02:57.14,0:03:00.36,Default,,0,0,0,,在这一时期已在更高的任期数下选举出了新的主节点\Nhave elected a new leader with a higher term number in the meantime.
Dialogue: 0,0:03:00.36,0:03:04.82,Default,,0,0,0,,如果该主节点发现了某个持有更高任期数的其它节点\NAnd if so, the leader will always step back and become a follower again immediately 
Dialogue: 0,0:03:04.82,0:03:08.64,Default,,0,0,0,,则该主节点将立刻重新退回到从节点状态\Nupon discovering some other node with a higher term number.
Dialogue: 0,0:03:08.64,0:03:12.38,Default,,0,0,0,,Raft算法总存在一个非常和平的权力转换过程\NSo, we always have a very peaceful transition of power in the Raft algorithm 
Dialogue: 0,0:03:13.16,0:03:16.60,Default,,0,0,0,,让系统从低任期数转变到高任期数\Nfrom the lower term number to the higher term number.
Dialogue: 0,0:03:16.60,0:03:19.40,Default,,0,0,0,,让我们来看一下实际的代码\NSo, let's run through the actual code.
Dialogue: 0,0:03:19.40,0:03:24.70,Default,,0,0,0,,我们先从初始化变量开始\NAnd so, here we start off with the usual initialization of variables.
Dialogue: 0,0:03:24.70,0:03:27.30,Default,,0,0,0,,我不会现在就讲解每一个变量的作用\NI'm not going to explain every single variable right now,
Dialogue: 0,0:03:27.30,0:03:31.00,Default,,0,0,0,,当算法使用了某个变量时 我才会讲解此变量的作用\Nbut I will explain the variables as we use them as part of the algorithm.
Dialogue: 0,0:03:31.00,0:03:32.58,Default,,0,0,0,,我这里想指出的是\NBut I will just point out here, 
Dialogue: 0,0:03:32.58,0:03:35.70,Default,,0,0,0,,currentTerm（当前任期）、votedFor（投票给）\Nthe first four variables currentTerm, votedFor, 
Dialogue: 0,0:03:35.70,0:03:37.20,Default,,0,0,0,,log（日志）和commitLength（确认长度）\Nlog and commitLength,
Dialogue: 0,0:03:37.20,0:03:42.00,Default,,0,0,0,,这前四个变量必须存储在持久存储器中 即存储在硬盘中\Nthese four variables have to be stored in stable storage, that is, on disk,
Dialogue: 0,0:03:42.00,0:03:44.60,Default,,0,0,0,,而后面五个变量\Nwhereas the remaining five variables, 
Dialogue: 0,0:03:44.60,0:03:48.82,Default,,0,0,0,,可以存储在易失存储器中 即我们允许这些变量在节点崩溃时丢失\Nthey can be in transient storage, they can be lost in the case of a crash.
Dialogue: 0,0:03:48.82,0:03:53.76,Default,,0,0,0,,但前四个变量在节点崩溃时必须能保存下来\NBut the first four variables have to be preserved in the case of a crash.
Dialogue: 0,0:03:53.76,0:03:56.42,Default,,0,0,0,,你可以看到这里的崩溃恢复部分\NAnd you can see the crash recovery here.
Dialogue: 0,0:03:56.42,0:04:03.62,Default,,0,0,0,,在崩溃恢复时 后面的五个变量\NSo, those the five remaining variables simply get reset to new fresh states 
Dialogue: 0,0:04:03.62,0:04:06.92,Default,,0,0,0,,可以被简单重置为初始化状态\Nif we recover from a crash.
Dialogue: 0,0:04:06.92,0:04:12.66,Default,,0,0,0,,现在 我前面说过 当一个节点怀疑主节点已失效时\NNow, as I said, when a node suspects that the leader has failed,
Dialogue: 0,0:04:13.16,0:04:17.94,Default,,0,0,0,,它将成为候选节点 并启动选举 这就是下面这部分代码的工作\Nit will become a candidate, and it will start an election. That's what happens here.
Dialogue: 0,0:04:17.94,0:04:18.90,Default,,0,0,0,,顺带一提\NBy the way, typically, 
Dialogue: 0,0:04:18.90,0:04:25.52,Default,,0,0,0,,节点怀疑主节点已失效的超时时间是随机选取的\Nthis timeout that the node uses before it suspects a leader to have failed is randomized.
Dialogue: 0,0:04:25.52,0:04:29.22,Default,,0,0,0,,这么做的目的是避免大量的节点\NAnd the purpose for that is to avoid having lots of nodes 
Dialogue: 0,0:04:29.22,0:04:31.62,Default,,0,0,0,,在同一时刻尝试成为候选节点\Nall trying to become candidate at the same time,
Dialogue: 0,0:04:31.62,0:04:34.92,Default,,0,0,0,,如果所有节点设置了相同的超时时间 在相同的时间启动选举\Nwhich is what would happen if all the nodes start up at the same time,
Dialogue: 0,0:04:34.92,0:04:38.24,Default,,0,0,0,,就可能发生这种情况\Nand then have the same timeout before they start an election.
Dialogue: 0,0:04:38.24,0:04:39.46,Default,,0,0,0,,随机化超时时间\NSo, randomizing the timeout 
Dialogue: 0,0:04:39.46,0:04:43.68,Default,,0,0,0,,可以降低同一时刻启动多个选举的发生概率\Nreduces the probability of having several elections at the same time.
Dialogue: 0,0:04:44.28,0:04:48.54,Default,,0,0,0,,总之 如果节点怀疑主节点超时 此节点会决定启动选举\NSo, whenever that happens now, so, the node decides it's time to start an election.
Dialogue: 0,0:04:48.54,0:04:50.48,Default,,0,0,0,,它会递增currentTerm\NIt increments the currentTerm.
Dialogue: 0,0:04:50.48,0:04:54.14,Default,,0,0,0,,它将currentRole（当前角色）设置为候选节点状态\NIt sets its currentRole to be the candidate state.
Dialogue: 0,0:04:54.70,0:04:58.38,Default,,0,0,0,,就像正常的选举一样 每个人都会在选举中为自己投票\NAnd like in every good election, everyone votes for themselves in an election.
Dialogue: 0,0:04:58.38,0:04:59.58,Default,,0,0,0,,Raft也是如此\NSo, also in Raft.
Dialogue: 0,0:04:59.58,0:05:03.00,Default,,0,0,0,,刚刚成为候选节点的节点也会为自己投票\NSo, the node that has just become a candidate votes for itself 
Dialogue: 0,0:05:03.00,0:05:06.80,Default,,0,0,0,,投票方法是将votedFor（投票给）变量设置为自己的nodeId（节点id）\Nby setting this votedFor variable to its own nodeId. 
Dialogue: 0,0:05:06.80,0:05:10.76,Default,,0,0,0,,这里还有一个nodeId集合\NAnd it has this set of nodeId 
Dialogue: 0,0:05:10.76,0:05:16.52,Default,,0,0,0,,这个变量会记录此节点收到的、支持自己作为主节点的选票\Nin which it records the set of votes that it has received in favor of itself as a candidate.
Dialogue: 0,0:05:16.52,0:05:22.12,Default,,0,0,0,,它将自己的nodeId先添加到votesReceived（已收到选票）集合中\NAnd it puts its own nodeId as the first member of that set of votesReceived.
Dialogue: 0,0:05:22.12,0:05:24.64,Default,,0,0,0,,变量lastTerm（上一任期）被初始化为0\NThis variable, lastTerm, is initially 0,
Dialogue: 0,0:05:24.64,0:05:30.84,Default,,0,0,0,,但你可以看到 如果log.length>0 我们就要设置lastTerm变量\Nbut you can see if log.length>0, then we set this lastTerm variable.
Dialogue: 0,0:05:30.84,0:05:33.48,Default,,0,0,0,,让我先来解释一下什么是log（日志）\NSo, let me explain first what the log is.
Dialogue: 0,0:05:33.48,0:05:39.04,Default,,0,0,0,,右上角给出了示意图 log是一个数组或一个列表\NSo, the log, you can see illustrated up here, is an array or a list.
Dialogue: 0,0:05:39.04,0:05:42.16,Default,,0,0,0,,log按顺序存储了一系列log项\NIt's a sequence of log entries.
Dialogue: 0,0:05:42.16,0:05:44.44,Default,,0,0,0,,每个log项都包含两个部分\NEach log entry consists of two parts.
Dialogue: 0,0:05:44.44,0:05:45.62,Default,,0,0,0,,第一部分是消息（msg）\NFirstly, a message. 
Dialogue: 0,0:05:45.62,0:05:49.74,Default,,0,0,0,,这就是我们希望通过全序关系广播所传递的消息\NSo, this is the message that we want to deliver via total order broadcasts.
Dialogue: 0,0:05:50.22,0:05:53.38,Default,,0,0,0,,这也是此算法的最终目的\NThat's the whole thing that the purpose of the algorithm.
Dialogue: 0,0:05:53.38,0:05:56.90,Default,,0,0,0,,第二部分是每个log项的任期数（term）\NAnd secondly, a term number on every log entry.
Dialogue: 0,0:05:56.90,0:06:00.48,Default,,0,0,0,,这个任期数是当主节点将特定的log项添加到log中时\NSo, this term number is the term number of the leader 
Dialogue: 0,0:06:00.48,0:06:04.60,Default,,0,0,0,,此主节点所持有的任期数\Nat the time when that leader added that particular entry to the log.
Dialogue: 0,0:06:04.60,0:06:07.86,Default,,0,0,0,,我们稍后会看到 为什么任期数会如此重要\NAnd we'll see later why that term number is important.
Dialogue: 0,0:06:08.38,0:06:11.36,Default,,0,0,0,,但现在 只需要接受log是这样一个数据结构\NBut for now, just accept that log is this structure here.
Dialogue: 0,0:06:11.90,0:06:17.64,Default,,0,0,0,,这是一个0为起始索引值的数组 log[0]是第一个log项\NIt's an 0-indexed array, where log[0] is the first log entry.
Dialogue: 0,0:06:17.64,0:06:21.70,Default,,0,0,0,,log.length是log中包含的log项数量\NAnd log.length is the number of log entries in the log.
Dialogue: 0,0:06:21.70,0:06:25.64,Default,,0,0,0,,如果log非空 即如果log.length>0\NAnd if the log is non-empty here, if the log.length>0,
Dialogue: 0,0:06:25.64,0:06:31.24,Default,,0,0,0,,我们就让lastTerm等于最后一个log项中的任期字段\Nthen we're going to say that the lastTerm is the term field of the last log entry.
Dialogue: 0,0:06:31.24,0:06:35.68,Default,,0,0,0,,log.length-1就是log中最后一项的索引值\NSo, log.length-1 is the index of the last entry in the log.
Dialogue: 0,0:06:36.38,0:06:40.60,Default,,0,0,0,,因此 我们取出最后一个log项的任期字段\NAnd so, we take the term field of that last log entry,
Dialogue: 0,0:06:40.60,0:06:44.90,Default,,0,0,0,,将此字段的值赋给lastTerm\Nand set that to be the value of this variable lastTerm.
Dialogue: 0,0:06:44.90,0:06:48.98,Default,,0,0,0,,我们接下来要构造发送给所有节点的消息\NAnd we then construct a message that will be sent to all of the nodes.
Dialogue: 0,0:06:48.98,0:06:53.74,Default,,0,0,0,,候选节点要向所有节点发送相同的消息\NAnd so, the candidate sends the same message to all of the nodes.
Dialogue: 0,0:06:53.74,0:06:57.06,Default,,0,0,0,,此消息的消息类型被标记为VoteRequest（投票请求）\NIt's a message tagged with the message type VoteRequest,
Dialogue: 0,0:06:57.06,0:06:58.72,Default,,0,0,0,,意思是：“请给我投票”\Nsaying, “Please vote for me.”
Dialogue: 0,0:06:58.72,0:07:00.86,Default,,0,0,0,,此消息包含多个字段\NAnd the message contains the several fields.
Dialogue: 0,0:07:00.86,0:07:03.56,Default,,0,0,0,,包含候选节点的nodeId\NIt contains the nodeId of the candidate.
Dialogue: 0,0:07:03.56,0:07:07.30,Default,,0,0,0,,包含任期数递增后的currentTerm\NIt contains the currentTerm after that term number has been incremented.
Dialogue: 0,0:07:07.30,0:07:10.22,Default,,0,0,0,,包含候选节点的log.length\NIt contains the log.length on the candidate.
Dialogue: 0,0:07:10.22,0:07:12.58,Default,,0,0,0,,消息还包含lastTerm变量\NAnd it contains this lastTerm variable, 
Dialogue: 0,0:07:12.58,0:07:17.92,Default,,0,0,0,,我前面说过 此变量等于候选节点log中最后一个log项的任期字段\Nwhich as I just said, is the term field of the last log entry in the candidate’s log.
Dialogue: 0,0:07:17.92,0:07:20.50,Default,,0,0,0,,此节点向所有节点发送相同的这一消息\NIt sends this same message to all of the nodes.
Dialogue: 0,0:07:20.50,0:07:21.94,Default,,0,0,0,,此节点启动计时器\NAnd it starts the timer 
Dialogue: 0,0:07:21.94,0:07:28.18,Default,,0,0,0,,如果没有选举成功 则计时器会报告超时\Nthat might eventually time out if it doesn't manage to do the election successfully.
Dialogue: 0,0:07:28.18,0:07:29.48,Default,,0,0,0,,这就是候选节点的行动\NSo, that's the candidate.
Dialogue: 0,0:07:29.48,0:07:30.10,Default,,0,0,0,,我们来看看\NLet's see 
Dialogue: 0,0:07:30.10,0:07:34.44,Default,,0,0,0,,当其他节点收到这些VoteRequest消息时会发生什么\Nwhat happens on the other nodes that receive one of these VoteRequest messages.
Dialogue: 0,0:07:34.44,0:07:39.64,Default,,0,0,0,,现在 我们是收到候选节点消息的一个其它节点\NSo now, we're one of the other nodes that has received a message from the candidate.
Dialogue: 0,0:07:39.64,0:07:42.40,Default,,0,0,0,,我们得到了候选节点的id（cId）\NAnd we have the id of the candidate.
Dialogue: 0,0:07:42.40,0:07:44.64,Default,,0,0,0,,我们得到了候选节点的任期数（cTerm）\NWe have the term number of the candidate,
Dialogue: 0,0:07:45.06,0:07:46.64,Default,,0,0,0,,候选节点的log长度（cLogLength）\Nthe length of the candidate's log,
Dialogue: 0,0:07:46.64,0:07:50.34,Default,,0,0,0,,以及候选节点最后一个log项的任期数（cLogTerm）\Nand the term number in the candidates last log entry.
Dialogue: 0,0:07:51.54,0:07:55.58,Default,,0,0,0,,当收到VoteRequest消息后 我们要做的第一件事情是\NAnd the first thing we're going to do when receiving a VoteRequest message is 
Dialogue: 0,0:07:55.58,0:08:01.10,Default,,0,0,0,,比较cTerm和消息接收方的currentTerm\Nto compare the cTerm to the currentTerm on of the recipient of this message.
Dialogue: 0,0:08:01.10,0:08:05.28,Default,,0,0,0,,如果cTerm大于接收方的currentTerm\NAnd if the cTerm is greater than the currentTerm of the recipient,
Dialogue: 0,0:08:05.28,0:08:08.10,Default,,0,0,0,,则我们继续前进 加入候选节点的任期\Nthen we move forward and join the term of the candidate.
Dialogue: 0,0:08:08.10,0:08:13.08,Default,,0,0,0,,实现这一点的方法是 将接收方的currentTerm设置为cTerm\NSo, we do that by setting the recipient's currentTerm to be the cTerm,
Dialogue: 0,0:08:13.08,0:08:18.56,Default,,0,0,0,,无论接收方节点之前的状态是什么 都将节点状态设置为从节点\Nto transition into the follower state regardless of what the node's previous state was,
Dialogue: 0,0:08:18.56,0:08:21.32,Default,,0,0,0,,同时 把votedFor变量设置为null（空）\Nand this votedFor variable gets set to null,
Dialogue: 0,0:08:21.32,0:08:27.60,Default,,0,0,0,,意思是 我们还没有在当前任期内给任何候选节点投过票\Nwhich means that we have not yet voted for any candidate in the current term,
Dialogue: 0,0:08:27.60,0:08:29.98,Default,,0,0,0,,因为我们刚刚修改了当前任期\Nbecause we just changed the current term.
Dialogue: 0,0:08:30.66,0:08:33.36,Default,,0,0,0,,我们随后就会为此节点投票\NHowever, we might vote for that candidate in a minute.
Dialogue: 0,0:08:33.36,0:08:39.76,Default,,0,0,0,,接下来 我们按照和候选节点相似的方式设置变量lastTerm\NSo, next, we set up this variable lastTerm very similar to the way we did on the candidate.
Dialogue: 0,0:08:39.76,0:08:46.78,Default,,0,0,0,,也就是说 我们查看VoteRequest消息接收方的最后一个log项\NAnd that is, we look at the last log entry on the recipient of this VoteRequest message.
Dialogue: 0,0:08:46.78,0:08:52.90,Default,,0,0,0,,我们得到最后一个log项的任期数 并将其赋值给lastTerm变量\NWe get the term number in that last log entry, and we set that to be this lastTerm variable.
Dialogue: 0,0:08:52.90,0:08:54.36,Default,,0,0,0,,我们现在要做的是\NNow, what we need to do is 
Dialogue: 0,0:08:54.36,0:08:59.94,Default,,0,0,0,,检查候选节点的log与我们自己的log相比是不是最新的\Nto check if the candidate’s log is up-to-date with our own log.
Dialogue: 0,0:08:59.94,0:09:02.40,Default,,0,0,0,,这样做的原因是\NThe reason for that is that 
Dialogue: 0,0:09:02.40,0:09:06.94,Default,,0,0,0,,我们不希望一个持有过时log的候选节点成为主节点\Nwe don't want a candidate with an outdated log to become the leader.
Dialogue: 0,0:09:07.56,0:09:11.74,Default,,0,0,0,,后面大家就会理解什么叫做过时\NAnd exactly what outdated means will become apparent later.
Dialogue: 0,0:09:12.52,0:09:20.28,Default,,0,0,0,,但重要的一点是 我们希望候选节点的log\NBut it's crucial that we want the candidate’s log to reflect all the updates
Dialogue: 0,0:09:20.28,0:09:25.28,Default,,0,0,0,,至少包含了quorum节点已经持有的log\Nthat at least the quorum of other nodes has seen.
Dialogue: 0,0:09:25.28,0:09:30.10,Default,,0,0,0,,因此 你不能让一个持有过时log的节点成为主节点\NSo, you don't end up with a leader whose log is really outdated,
Dialogue: 0,0:09:30.54,0:09:33.08,Default,,0,0,0,,因为这意味着我们会丢失很多消息\Nbecause that might lead to the loss of some messages.
Dialogue: 0,0:09:33.98,0:09:39.52,Default,,0,0,0,,我们这里的logOk变量是一个布尔值 这个变量告诉我们\NSo, we have this logOk variable here, which will contain a Boolean, which tells us 
Dialogue: 0,0:09:39.52,0:09:46.02,Default,,0,0,0,,当前节点是否认为候选节点的log符合要求 可以给此候选节点投票\Nwhether the current node thinks the candidate's log is OK to vote in favor of.
Dialogue: 0,0:09:46.02,0:09:48.36,Default,,0,0,0,,有两个判断标准\NAnd so, there are two criteria here.
Dialogue: 0,0:09:48.36,0:09:52.12,Default,,0,0,0,,首先 如果候选节点的log任期\NFirst of all, if the log term of the candidate, 
Dialogue: 0,0:09:52.12,0:09:56.98,Default,,0,0,0,,即候选节点最后一个log项的任期数\Nso, the term number that appears in the last log entry of the candidate,
Dialogue: 0,0:09:56.98,0:09:59.96,Default,,0,0,0,,如果此任期数\Nif that term number is greater than 
Dialogue: 0,0:09:59.96,0:10:05.92,Default,,0,0,0,,大于收到VoteRequest消息接收方最后一个log项的任期数\Nthe term number of the log entry on the recipient of this VoteRequest message,
Dialogue: 0,0:10:05.92,0:10:09.66,Default,,0,0,0,,则我们认为候选节点的log符合要求\Nthen we consider the log to be OK.
Dialogue: 0,0:10:09.66,0:10:13.48,Default,,0,0,0,,候选节点的log符合要求的另一个判断标准是\NSecondly, another way for the log to be OK is 
Dialogue: 0,0:10:13.48,0:10:17.12,Default,,0,0,0,,两个节点最后一个log项的任期相同\Nfor the log term in the last log entry to be the same,
Dialogue: 0,0:10:17.12,0:10:19.26,Default,,0,0,0,,但候选节点持有的log数量\Nbut for the candidates to have a log 
Dialogue: 0,0:10:19.26,0:10:24.94,Default,,0,0,0,,至少等于收到VoteRequest消息接收方的log数量\Nthat is at least as long as the log of the recipient of this VoteRequest message.
Dialogue: 0,0:10:24.94,0:10:27.60,Default,,0,0,0,,两个条件满足其中一个就可以 两者选其一\NSo, one of those things needs to be true, either-or.
Dialogue: 0,0:10:27.60,0:10:31.96,Default,,0,0,0,,如果满足条件 则log符合要求\NAnd if so, then the log is OK.
Dialogue: 0,0:10:31.96,0:10:36.74,Default,,0,0,0,,如果下述三个判断标准成立 则我们要为此候选节点投票\NSo, we will now vote for this candidate if three criteria will hold.
Dialogue: 0,0:10:36.74,0:10:39.84,Default,,0,0,0,,第一 如果cTerm等于currentTerm\NFirstly, if the cTerm equals the currentTerm, 
Dialogue: 0,0:10:39.84,0:10:42.00,Default,,0,0,0,,也就是说 任期没有过时\Nthat is, it's not in some outdated term, 
Dialogue: 0,0:10:42.00,0:10:45.68,Default,,0,0,0,,我们还未看到任何持有更高任期数的节点\Nwe haven't seen any other node with a higher term number.
Dialogue: 0,0:10:45.68,0:10:47.80,Default,,0,0,0,,第二 如果候选节点的log符合要求\NSecondly, if the candidate's log is OK.
Dialogue: 0,0:10:47.80,0:10:55.34,Default,,0,0,0,,第三 如果我们在当前任期还没有给任何其他候选节点投过票\NAnd thirdly, if we have not yet voted for any other candidate in the current term.
Dialogue: 0,0:10:55.74,0:10:57.60,Default,,0,0,0,,如果我们在当前任期还没有给任何其他候选节点投票\NSo, this votedFor variable would be null 
Dialogue: 0,0:10:57.60,0:11:00.78,Default,,0,0,0,,则votedFor应该为null\Nif we have not yet voted at all for any candidate in the current term,
Dialogue: 0,0:11:00.78,0:11:04.86,Default,,0,0,0,,或者如果我们已经为相同的候选节点投过票 则votedFor为cId\Nor it could be cId if we've already voted for the same candidate.
Dialogue: 0,0:11:04.86,0:11:08.92,Default,,0,0,0,,在单一任期内 我们允许给相同的候选节点多次投票\NIt's OK to vote several times for the same candidate in a single term.
Dialogue: 0,0:11:08.92,0:11:12.94,Default,,0,0,0,,但我们在相同的任期内不能给两个不同的候选节点投票\NBut we must not vote for two different candidates within the same term.
Dialogue: 0,0:11:12.94,0:11:17.96,Default,,0,0,0,,如果这三个判断标准都成立 则我们就可以为此候选节点投票\NSo, if all those three criteria are true, then we can vote in favor of this candidate.
Dialogue: 0,0:11:17.96,0:11:21.46,Default,,0,0,0,,我们的投票方法是 首先把votedFor变量设置为cId\NWe will do that by first setting our votedFor variable to cId 
Dialogue: 0,0:11:21.46,0:11:24.54,Default,,0,0,0,,记录下我们已经给这个候选节点投过票了\Nto remember the fact that we have voted for the candidate.
Dialogue: 0,0:11:24.54,0:11:28.54,Default,,0,0,0,,随后 我们给候选节点返回VoteResponse（投票响应）消息\NAnd then, we send a VoteResponse message back to the candidate.
Dialogue: 0,0:11:28.54,0:11:33.12,Default,,0,0,0,,此消息将包含投票节点的nodeId\NAnd this is going to contain nodeId of the node doing the vote.
Dialogue: 0,0:11:33.70,0:11:35.80,Default,,0,0,0,,包含currentTerm的值\NIt's going to contain the currentTerm number,
Dialogue: 0,0:11:35.80,0:11:38.80,Default,,0,0,0,,这样我们就知道这张选票所处的任期\Nso, we know which term this election is for.
Dialogue: 0,0:11:38.80,0:11:45.06,Default,,0,0,0,,此消息还包含一个值true 表明这是一张投给此候选节点的投票\NAnd the value true to indicate that it's a vote approval in favor of this candidate.
Dialogue: 0,0:11:45.06,0:11:47.60,Default,,0,0,0,,另一方面 如果任意一个判断标准不成立\NOn the other hand, if any of those things are not true,
Dialogue: 0,0:11:47.60,0:11:52.66,Default,,0,0,0,,则发送给候选节点的VoteResponse消息会包含false\Nthen we send a VoteResponse with a false field back to the candidate,
Dialogue: 0,0:11:52.66,0:11:56.32,Default,,0,0,0,,告诉它我们没有为此候选节点投票\Ntelling it that we are not voting in favor of this candidate.
Dialogue: 0,0:11:57.64,0:11:59.28,Default,,0,0,0,,现在 我们回到候选节点\NNow, we move back to the candidates.
Dialogue: 0,0:11:59.28,0:12:02.30,Default,,0,0,0,,我们要聚合结果 我们要收集收到的选票\NAnd we aggregate. We collect the votes that we receive.
Dialogue: 0,0:12:02.30,0:12:08.30,Default,,0,0,0,,每当我们收到一个VoteResponse消息时 我们按照下述方式处理\NSo, any time we receive a VoteResponse message, this is what happens.
Dialogue: 0,0:12:08.86,0:12:13.12,Default,,0,0,0,,VoteResponse消息包含了投票方的id（voterId）\NSo, we have a VoteResponse with the id of the node that is voting,
Dialogue: 0,0:12:13.12,0:12:15.56,Default,,0,0,0,,包含了投票所属的任期（term）\Nwith the term number in which the vote is happening,
Dialogue: 0,0:12:15.56,0:12:18.92,Default,,0,0,0,,包含了一个布尔值（granted） 表示是否为此候选节点投票\Nand with the Boolean telling us whether that vote is granted or not.
Dialogue: 0,0:12:18.92,0:12:21.42,Default,,0,0,0,,我们要做的第一件事情是检查任期数\NAnd the first thing we do is to check the term number.
Dialogue: 0,0:12:21.42,0:12:28.48,Default,,0,0,0,,如果VoteResponse消息的term大于我们的currentTerm\NSo, if the term number in the VoteResponse message is greater than our currentTerm,
Dialogue: 0,0:12:28.48,0:12:29.82,Default,,0,0,0,,我们和之前一样处理此消息\Nwe do the usual thing, 
Dialogue: 0,0:12:29.82,0:12:34.02,Default,,0,0,0,,我们接受此任期数作为当前任期数\Nwe accept that term number as our own,
Dialogue: 0,0:12:34.02,0:12:35.90,Default,,0,0,0,,我们将自己转变为从节点状态\Nwe transition into follower state,
Dialogue: 0,0:12:35.90,0:12:40.08,Default,,0,0,0,,我们忘记上一个任期我们给谁投的票\Nwe forget which node we voted for in some previous term,
Dialogue: 0,0:12:40.08,0:12:42.08,Default,,0,0,0,,我们取消所有的选举计时器\Nand we cancel any election timer.
Dialogue: 0,0:12:42.08,0:12:46.22,Default,,0,0,0,,这一系列过程都是把我们的状态机转换为从节点状态\NSo, that just moves us back into the follow state in the state machine.
Dialogue: 0,0:12:46.22,0:12:49.82,Default,,0,0,0,,然而 如果我们仍然处于候选节点状态\NHowever, if we are still in the candidate state,
Dialogue: 0,0:12:49.82,0:12:54.42,Default,,0,0,0,,并且如果我们收到的消息所属的任期\Nand if the message that we just received is for the correct term 
Dialogue: 0,0:12:54.42,0:12:56.18,Default,,0,0,0,,就是我们在执行选举的正确任期\Nin which we're performing the election,
Dialogue: 0,0:12:56.18,0:12:58.48,Default,,0,0,0,,并且granted字段的值是true\Nand the granted field is true,
Dialogue: 0,0:12:58.48,0:13:02.66,Default,,0,0,0,,那我们就得到了一张给候选节点的选票\Nthen we have a vote in favor of us as the candidate.
Dialogue: 0,0:13:02.66,0:13:06.00,Default,,0,0,0,,我们将更新这里的votesReceived集合\NSo, we're going to maintain this set of votesReceived here.
Dialogue: 0,0:13:06.00,0:13:10.46,Default,,0,0,0,,我们将voterId添加至votesReceived集合中\NAnd we're going to add the id of the voter to the set of votesReceived.
Dialogue: 0,0:13:10.46,0:13:12.70,Default,,0,0,0,,注意 这里的更新操作是幂等的\NNotice that this update here is idempotent.
Dialogue: 0,0:13:12.70,0:13:17.18,Default,,0,0,0,,即使VoteResponse消息在网络中被重复传输\NSo, even if this VoteResponse message gets duplicated in the network somewhere,
Dialogue: 0,0:13:17.18,0:13:20.64,Default,,0,0,0,,这也不是问题 我们不会重复计算相同的选票\Nthat's not a problem, we're not going to count the same vote more than once.
Dialogue: 0,0:13:20.64,0:13:24.90,Default,,0,0,0,,我们仍然要求选票来自于不同的quorum节点\NWe still require votes from a quorum of different nodes.
Dialogue: 0,0:13:25.86,0:13:29.18,Default,,0,0,0,,接下来 为了判断quorum节点数量是否满足要求\NSo, then, to determine whether we have a quorum yet,
Dialogue: 0,0:13:29.18,0:13:33.40,Default,,0,0,0,,我们可以检查votesReceived集合的大小\Nwe can check the cardinality of this set votesReceived.
Dialogue: 0,0:13:33.40,0:13:37.28,Default,,0,0,0,,如果我们收到的选票数量大于或等于多半\NAnd if the number of votes we received is greater than or equal to a majority,
Dialogue: 0,0:13:37.28,0:13:41.66,Default,,0,0,0,,也就是说 大于或等于系统中的节点数量加1、除以2、向上取整\Nthat is, the number of nodes in the system plus 1 divided by 2 round upwards,
Dialogue: 0,0:13:41.66,0:13:45.24,Default,,0,0,0,,我们就得到了多半quorum节点的选票\Nthen we have a majority quorum of nodes.
Dialogue: 0,0:13:45.24,0:13:48.40,Default,,0,0,0,,此时 我们就可以成为主节点了 撒花庆祝！\NAnd at that point, we can become the leader, hurrah!
Dialogue: 0,0:13:48.40,0:13:53.52,Default,,0,0,0,,我们转变成主节点状态 currentLeader（当前主节点）就是我们自己\NSo, we transition to leader state. The currentLeader, well, that's ourselves now.
Dialogue: 0,0:13:53.52,0:13:55.54,Default,,0,0,0,,我们也取消所有的选举计时器\NWe can cancel the election timer as well.
Dialogue: 0,0:13:55.54,0:13:59.96,Default,,0,0,0,,现在 我们需要给其他所有节点 也就是现在的从节点 发送一条消息\NAnd now, we need to send a message to all of the nodes, which are now the followers,
Dialogue: 0,0:14:00.28,0:14:06.72,Default,,0,0,0,,告诉它们：“大家好 我是你们的新主节点了 给点信息吧”\Nto tell them, “Hey, I'm your new leader, and give it a bit of information.
Dialogue: 0,0:14:06.72,0:14:09.54,Default,,0,0,0,,这里的REPLICATELOG（复制日志）函数\NSo, this REPLICATELOG function here 
Dialogue: 0,0:14:09.54,0:14:11.42,Default,,0,0,0,,将会发送这条消息\Nis going to do the actual sending of that message,
Dialogue: 0,0:14:11.42,0:14:14.44,Default,,0,0,0,,我们稍后就会展开介绍此函数\Nand we will see that function in a minute.
Dialogue: 0,0:14:15.48,0:14:19.80,Default,,0,0,0,,我们还需要让主节点设置和从节点相关的一些变量\NWe also need to set up for all of the followers some variables.
Dialogue: 0,0:14:19.80,0:14:22.74,Default,,0,0,0,,这些变量是sentLength（发送长度）和actedLength（确认长度）\NThese variables here, sentLength and actedLength, 
Dialogue: 0,0:14:22.74,0:14:26.32,Default,,0,0,0,,它们都将nodeId映射成整数\Nare maps from nodeId to an integer.
Dialogue: 0,0:14:26.32,0:14:32.26,Default,,0,0,0,,主节点要为每一个从节点初始化这些变量\NAnd so, for each of the follower nodes, we're going to initialize these variables here.
Dialogue: 0,0:14:32.26,0:14:38.14,Default,,0,0,0,,sentLength要设置成主节点的log.length\NThe sentLength is going to be initialized with the log.length on the leader.
Dialogue: 0,0:14:40.10,0:14:42.18,Default,,0,0,0,,sentLength的意思是\NAnd the meaning of sentLength is 
Dialogue: 0,0:14:42.18,0:14:46.66,Default,,0,0,0,,主节点已经向特定从节点发送的log项数量\Nthe number of log records that we have already sent to a particular node.
Dialogue: 0,0:14:46.66,0:14:48.22,Default,,0,0,0,,这里我们假设\NSo, here we are assuming that 
Dialogue: 0,0:14:48.22,0:14:52.88,Default,,0,0,0,,从节点已经从主节点收到了sentLength之前的所有log项\Nthe follower has already received all of the log entries from us.
Dialogue: 0,0:14:52.88,0:14:57.06,Default,,0,0,0,,如果不满足这一假设情况 我们会用后面介绍的一个过程来纠正这一情况\NIf that is not the case, we will correct that later through a process that we will see later.
Dialogue: 0,0:14:57.44,0:15:03.38,Default,,0,0,0,,第二 actedLength从0开始计数\NSecondly, actedLength is the number of log entries, counted from the beginning,
Dialogue: 0,0:15:04.16,0:15:09.02,Default,,0,0,0,,表示此特定从节点已经确认的log项数量\Nthat this particular follower acknowledged as having received.
Dialogue: 0,0:15:09.02,0:15:10.72,Default,,0,0,0,,我们把这个变量初始化为0\NAnd we initialized that to be 0, 
Dialogue: 0,0:15:10.72,0:15:14.88,Default,,0,0,0,,随后 当我们收到确认后 我们将递增这个变量\Nand later, as we receive acknowledgements, we will increase that number.
Dialogue: 0,0:15:14.88,0:15:18.80,Default,,0,0,0,,这就是成为主节点时要做的事情\NOK, so that's all we have to do to become a leader.
Dialogue: 0,0:15:18.80,0:15:23.44,Default,,0,0,0,,现在我们有了一个主节点 我们将真正开始讨论全序关系广播了\NNow that we have a leader, we can actually start talking about the total order broadcast.
Dialogue: 0,0:15:23.44,0:15:30.32,Default,,0,0,0,,我们现在有一个可以被客户端调用的函数\NSo, what we have here is now a function that can be called by a client, for example,
Dialogue: 0,0:15:30.32,0:15:33.24,Default,,0,0,0,,这个函数告诉我们：“我们想广播一条消息”\Nto say, “OK, we want to broadcast a message.”
Dialogue: 0,0:15:34.10,0:15:37.60,Default,,0,0,0,,我们希望通过全序关系广播来广播这条消息\NAnd we want to do that via total order broadcast 
Dialogue: 0,0:15:37.60,0:15:41.88,Default,,0,0,0,,保证所有节点按照相同的顺序传递此消息\Nensuring that all nodes deliver that the messages in the same order.
Dialogue: 0,0:15:41.88,0:15:45.02,Default,,0,0,0,,消息和消息的传递顺序\NNow, the order in which those messages are going to be delivered 
Dialogue: 0,0:15:45.02,0:15:46.42,Default,,0,0,0,,就是由log来维护的\Nis in fact exactly the log.
Dialogue: 0,0:15:46.42,0:15:48.12,Default,,0,0,0,,这就是log的全部作用\NThat's the whole purpose of the log.
Dialogue: 0,0:15:49.50,0:15:53.70,Default,,0,0,0,,只有主节点能在log中增加log项\NAnd the only node that can add entries to the log is the leader.
Dialogue: 0,0:15:53.70,0:15:56.68,Default,,0,0,0,,我们首先要做的是\NAnd so, first of all, the first thing we have to do is 
Dialogue: 0,0:15:56.68,0:16:01.22,Default,,0,0,0,,如果广播一条消息的请求没有发生在主节点处\Nif the request to broadcast a message happens not on the leader,
Dialogue: 0,0:16:01.22,0:16:04.94,Default,,0,0,0,,则此节点要通过FIFO链路将广播请求转交给当前主节点\Nthen it has to be forwarded to the current leader via a FIFO link.
Dialogue: 0,0:16:05.48,0:16:07.64,Default,,0,0,0,,这里使用FIFO链路的原因是\NUsing a FIFO link here just ensures that
Dialogue: 0,0:16:07.64,0:16:12.28,Default,,0,0,0,,我们要保证最后实现的是FIFO全序关系广播 而不只是全序关系广播\Nin total, we actually get FIFO total order broadcast, not just total order broadcast.
Dialogue: 0,0:16:12.66,0:16:16.30,Default,,0,0,0,,实现FIFO全序广播唯一要做的就是通过FIFO链路转交广播请求\NAnd that's the only thing we need to do in order to ensure the FIFO aspect.
Dialogue: 0,0:16:17.82,0:16:20.10,Default,,0,0,0,,如果当前节点是主节点\NIf the current node is the leader, 
Dialogue: 0,0:16:20.10,0:16:24.92,Default,,0,0,0,,我们可能会收到转交过来的消息广播请求\Nand we may have just received one of those forwarded requests to broadcast a message,
Dialogue: 0,0:16:24.92,0:16:29.00,Default,,0,0,0,,我们首先要做的是 在log中追加一条记录\Nwell, the first thing we do is we append a record to the log 
Dialogue: 0,0:16:29.56,0:16:31.76,Default,,0,0,0,,记录中包括我们想要广播的消息（msg）\Ncontaining the message that we want to broadcast,
Dialogue: 0,0:16:31.76,0:16:34.80,Default,,0,0,0,,且包括主节点的当前任期数（currentTerm）\Nand containing the current term number of the leader.
Dialogue: 0,0:16:36.80,0:16:43.14,Default,,0,0,0,,我们也让主节点做个标记 确认自己已经传递了这条消息\NWe also note that the leader itself has acknowledged the delivery of this message.
Dialogue: 0,0:16:43.14,0:16:46.60,Default,,0,0,0,,这是另一种给自己投票的形式\NAnd that's just another instance of voting for ourselves.
Dialogue: 0,0:16:47.04,0:16:49.46,Default,,0,0,0,,这里的nodId是主节点的id\NSo, nodeId here is the id of the leader,
Dialogue: 0,0:16:49.46,0:16:52.20,Default,,0,0,0,,因此 我们只需要更新actedLength变量\Nand so, we're just updating this actedLength variable 
Dialogue: 0,0:16:52.20,0:16:56.28,Default,,0,0,0,,让其包含新追加的记录\Nto include the newly appended record.
Dialogue: 0,0:16:58.10,0:17:00.48,Default,,0,0,0,,现在 主节点向每个从节点再次调用REPLICATELOG函数\NAnd now, we call again this REPLICATELOG function 
Dialogue: 0,0:17:00.48,0:17:03.72,Default,,0,0,0,,我们在上一页幻灯片中已经见到过这个函数了\Nthat we already had on the last slide for each of the followers.
Dialogue: 0,0:17:03.72,0:17:07.38,Default,,0,0,0,,主节点要向除自己外的所有节点调用此函数\NSo, all of the nodes in the system apart from the leader.
Dialogue: 0,0:17:08.46,0:17:12.34,Default,,0,0,0,,此外 我们也要周期性地调用这个REPLICATELOG函数\NMoreover, we also call this REPLICATELOG function periodically.
Dialogue: 0,0:17:12.34,0:17:18.30,Default,,0,0,0,,即使主节点没有向log追加任何新的消息\NSo, the leader, even if it doesn't have any new messages appended to the log lately,
Dialogue: 0,0:17:18.30,0:17:23.22,Default,,0,0,0,,它仍然需要周期性地向每个从节点调用REPLICATELOG\Nit's still called REPLICATELOG for each of the followers periodically.
Dialogue: 0,0:17:23.22,0:17:25.08,Default,,0,0,0,,周期性调用有几个目的\NAnd that has several purposes.
Dialogue: 0,0:17:25.08,0:17:27.06,Default,,0,0,0,,第一是充当心跳包\NOne is to act as a kind of heartbeat.
Dialogue: 0,0:17:27.06,0:17:31.20,Default,,0,0,0,,调用REPLICATELOG会向从节点发送一条消息\NSo, calling REPLICATELOG sends a message to the followers,
Dialogue: 0,0:17:31.20,0:17:33.42,Default,,0,0,0,,告诉它们主节点还活着\Njust telling them that the leader is still alive.
Dialogue: 0,0:17:33.42,0:17:36.62,Default,,0,0,0,,它们不需要启动新的主节点选举 一切顺利\NSo, they don't need to start a new leader election. Everything is fine.
Dialogue: 0,0:17:38.82,0:17:41.72,Default,,0,0,0,,调用REPLICATELOG也可以保证 如果任意消息丢失\NCalling REPLICATELOG also ensures that 
Dialogue: 0,0:17:41.72,0:17:46.08,Default,,0,0,0,,消息还会被重新传递\Nif any messages got lost, for example, then they will get redelivered.
Dialogue: 0,0:17:46.66,0:17:52.40,Default,,0,0,0,,这也能保证如果主节点提交了任何log项\NAnd it ensures that if the leader has committed any log entries,
Dialogue: 0,0:17:52.40,0:17:56.16,Default,,0,0,0,,那么这些log项也会被从节点提交\Nthen they will also be committed on the followers.
Dialogue: 0,0:17:56.52,0:18:00.02,Default,,0,0,0,,我们稍后会讲解提交过程\NThe process for committing, we will see later.
Dialogue: 0,0:18:00.02,0:18:03.36,Default,,0,0,0,,我们来看看这个REPLICATELOG函数\NSo, let's have a look at this REPLICATELOG function 
Dialogue: 0,0:18:03.36,0:18:05.56,Default,,0,0,0,,我们已经提到过这个函数三次了\Nthat we've just seen called three times.
Dialogue: 0,0:18:06.34,0:18:08.10,Default,,0,0,0,,REPLICATELOG函数的输入参数是\NSo, this REPLICATELOG function gets called 
Dialogue: 0,0:18:08.10,0:18:12.60,Default,,0,0,0,,主节点的节点id（leaderId）和从节点的节点id（followerId）\Nfirst of all, with the node id of the leader, and the node id of the follower.
Dialogue: 0,0:18:12.60,0:18:15.68,Default,,0,0,0,,此函数也能访问之前创建的所有变量\NAnd we have access to all of the variables from before.
Dialogue: 0,0:18:15.68,0:18:22.20,Default,,0,0,0,,首先 我们要将主节点的log拆分为prefix部分和suffix部分\NSo, first of all, we are going to now split the log on the leader into a prefix and a suffix.
Dialogue: 0,0:18:22.20,0:18:24.24,Default,,0,0,0,,prefix部分将包括\NThe prefix will contain 
Dialogue: 0,0:18:24.24,0:18:29.12,Default,,0,0,0,,主节点认为已经发送给特定从节点的所有log项\Nall of the log entries that we think we have already sent to the follower.
Dialogue: 0,0:18:29.12,0:18:30.72,Default,,0,0,0,,suffix部分将包括\NAnd the suffix will contain 
Dialogue: 0,0:18:30.72,0:18:35.68,Default,,0,0,0,,主节点认为还没有发送给特定从节点的所有新log项\Nall of the new log entries that we think we have not yet sent to this particular follower.
Dialogue: 0,0:18:35.68,0:18:39.92,Default,,0,0,0,,我们这里设置的变量sentLength\NAnd so, we have this variable sentLength here, which records 
Dialogue: 0,0:18:39.92,0:18:45.58,Default,,0,0,0,,记录了我们已经为每个nodeId发送了的log项数量\Nfor every nodeId, the number of log entries that we think we have already sent there.
Dialogue: 0,0:18:45.58,0:18:48.80,Default,,0,0,0,,因此 这里的prefixLen也是一个整数\NAnd so, this prefixLen is just an integer now.
Dialogue: 0,0:18:48.80,0:18:51.74,Default,,0,0,0,,我们将suffix部分设置为\NAnd I'm going to take the suffix of the log 
Dialogue: 0,0:18:51.74,0:18:58.38,Default,,0,0,0,,从prefixLen索引值开始 一直到log中的最后一个log项\Nwhich is starting at the index prefixLen, and going all the way up to the end of the log,
Dialogue: 0,0:18:58.38,0:19:02.32,Default,,0,0,0,,即prefixLen之后所有剩余的log项\Nso, all of the remaining log entries after prefixLen.
Dialogue: 0,0:19:02.32,0:19:07.88,Default,,0,0,0,,有可能出现prefixLen就等于整个log的长度\NIt could happen that prefixLen is indeed the length of the entire log,
Dialogue: 0,0:19:07.88,0:19:10.40,Default,,0,0,0,,这种情况下 suffix部分就是一个空数组\Nin which case the suffix would just be an empty array.
Dialogue: 0,0:19:11.92,0:19:15.96,Default,,0,0,0,,接下来 我们要设置prefixTerm变量\NNext, we set up this variable, the prefixTerm.
Dialogue: 0,0:19:15.96,0:19:20.46,Default,,0,0,0,,我们要找到\NAnd that is now going to be looking at the log entries,
Dialogue: 0,0:19:20.46,0:19:24.36,Default,,0,0,0,,prefix部分中的最后一个log项\Nwe're going to look at the last log entry within the prefix,
Dialogue: 0,0:19:24.36,0:19:27.50,Default,,0,0,0,,查看此log项的任期数\Nand look at the term number of that log entry.
Dialogue: 0,0:19:28.00,0:19:32.80,Default,,0,0,0,,这与我们之前构造VoteRequest消息时所做的事情很相似\NSo, this is a bit similar to what we had previously in the VoteRequest message.
Dialogue: 0,0:19:33.66,0:19:38.10,Default,,0,0,0,,此时 我们要查看的不是所有log中的最后一个log项\NIn this case, what we're looking at is not the last log entry in the log all together,
Dialogue: 0,0:19:38.10,0:19:42.88,Default,,0,0,0,,而是prefix部分的最后一个log项 并得到此log项的任期数\Nbut the last log entry in the prefix, and getting the term number of that.
Dialogue: 0,0:19:42.88,0:19:45.20,Default,,0,0,0,,主节点现在将要向从节点发送一个LogRequest（日志请求）消息\NAnd we're now going to send a LogRequest 
Dialogue: 0,0:19:45.20,0:19:49.30,Default,,0,0,0,,消息中包含下述所有变量\Nwith all of these various variables to the follower.
Dialogue: 0,0:19:49.30,0:19:55.94,Default,,0,0,0,,我们要在这条消息中增加主节点的id（leaderId）\NSo, in this message, we're going to include the id of the leader,
Dialogue: 0,0:19:55.94,0:19:57.86,Default,,0,0,0,,主节点的任期数（currentTerm）\Nthe term number, in which it's the leader,
Dialogue: 0,0:19:57.86,0:20:00.52,Default,,0,0,0,,从节点尚未发送确认信息的prefix部分长度（prefixLen）\Nthe length of the prefix that we are not sending,
Dialogue: 0,0:20:00.52,0:20:04.56,Default,,0,0,0,,prefix部分最后一个log项的任期数（prefixTerm）\Nthe term number of the last log entry in the prefix,
Dialogue: 0,0:20:04.56,0:20:08.84,Default,,0,0,0,,commitLength 我们稍后会了解这个变量的含义 这也是一个整数\Nthe commitLength which is a variable that we will see later, that's just another integer,
Dialogue: 0,0:20:08.84,0:20:14.42,Default,,0,0,0,,以及suffix部分 这是主节点想要在log中增加的新log项数组\Nand then, suffix, which is this array of new log entries that we want to add to the log.
Dialogue: 0,0:20:16.58,0:20:19.76,Default,,0,0,0,,这就是主节点发送LogRequest消息的方法\NOK, so, that was how we send the LogRequest.
Dialogue: 0,0:20:19.76,0:20:21.64,Default,,0,0,0,,我们现在切换到从节点\NNow, we're on the followers.
Dialogue: 0,0:20:21.64,0:20:25.62,Default,,0,0,0,,我们来看看从节点如何处理收到的LogRequest消息\NAnd we will see how to receive one of these LogRequest messages.
Dialogue: 0,0:20:25.62,0:20:28.76,Default,,0,0,0,,上面是我们提到的所有变量\NSo, we've got all of the variables that I just mentioned.
Dialogue: 0,0:20:28.76,0:20:32.64,Default,,0,0,0,,和前面一样 从节点要做的第一件事是检查任期数\NAnd the first thing we need to do as always is to check the term number.
Dialogue: 0,0:20:32.64,0:20:34.92,Default,,0,0,0,,如果消息中的任期数\NAnd so, if the term number in the message 
Dialogue: 0,0:20:34.92,0:20:38.06,Default,,0,0,0,,大于从节点的任期数\Nis greater than the term number on the follower,
Dialogue: 0,0:20:38.06,0:20:40.40,Default,,0,0,0,,则我们和之前一样 更改状态机的状态\Nthen we're going to do the usual state machine thing.
Dialogue: 0,0:20:40.40,0:20:42.50,Default,,0,0,0,,我们将接受新的任期数\NWe're going to accept the current term.
Dialogue: 0,0:20:42.50,0:20:47.58,Default,,0,0,0,,我们将忘记上一个任期内我们给哪个候选节点投了票\NWe're going to forget what candidate we voted for in the previous term.
Dialogue: 0,0:20:47.58,0:20:49.20,Default,,0,0,0,,我们取消选取计时器\NWe’re going to cancel election timer.
Dialogue: 0,0:20:49.20,0:20:52.58,Default,,0,0,0,,我们也会落入第二个判断条件内\NAnd we will also fall through to this second if condition,
Dialogue: 0,0:20:52.58,0:20:55.16,Default,,0,0,0,,我们在这里将currentRole设置为从节点\Nwhere we set the currentRole to be follower.
Dialogue: 0,0:20:55.16,0:21:00.74,Default,,0,0,0,,我们接受当前主节点为LogRequest消息的发送方\NAnd we accept the current leader as being the sender of this LogRequest message.
Dialogue: 0,0:21:02.24,0:21:04.68,Default,,0,0,0,,之所以会落入第二个判断条件\NSo, we fall through to this second case,
Dialogue: 0,0:21:04.68,0:21:07.28,Default,,0,0,0,,是因为这里我们将currentTerm更新为收到的任期数\Nbecause here we update currentTerm to equals term.
Dialogue: 0,0:21:07.28,0:21:11.18,Default,,0,0,0,,因此 第二个判断条件中 任期数仍然等于currentTerm\NAnd so, it still equals currentTerm here in the second condition.
Dialogue: 0,0:21:11.18,0:21:14.96,Default,,0,0,0,,这里仍然会有第二个判断条件 因为还可能发生的是\NThe second condition is also here, because it could happen that 
Dialogue: 0,0:21:14.96,0:21:17.16,Default,,0,0,0,,收到LogRequest消息的节点\Nthe node receiving the LogRequest 
Dialogue: 0,0:21:17.16,0:21:21.90,Default,,0,0,0,,实际上是在当前任期数内竞争主节点的候选节点\Nis actually a candidate in the same term number as the leader.
Dialogue: 0,0:21:21.90,0:21:25.72,Default,,0,0,0,,在这种情况下 我们仍然转变成从节点状态\NAnd in that case, we also want to move into follower state.
Dialogue: 0,0:21:26.26,0:21:28.14,Default,,0,0,0,,即使我们没有改变任期数\NEven though we're not changing the term number,
Dialogue: 0,0:21:28.14,0:21:34.28,Default,,0,0,0,,我们仍然接受LogRequest消息的发送方为主节点\Nbut we still want to accept the sender of this LogRequest message as the leader.
Dialogue: 0,0:21:35.96,0:21:40.06,Default,,0,0,0,,我们下一件要做的是做另一个检查 验证log是否符合要求\NOK, next thing we need to do is do another check if the log is OK.
Dialogue: 0,0:21:40.06,0:21:43.94,Default,,0,0,0,,这有点类似于早些时候主节点选举期间的处理过程\NThis is a bit similar to what happened earlier during the leader election.
Dialogue: 0,0:21:44.42,0:21:46.34,Default,,0,0,0,,但这里的检查条件有些不一样\NBut the condition is a little different.
Dialogue: 0,0:21:46.34,0:21:49.74,Default,,0,0,0,,我们在这里首先想要保证的是\NSo, here, what we first of all want to ensure is 
Dialogue: 0,0:21:49.74,0:21:53.42,Default,,0,0,0,,还记得我在前一页幻灯片讲到的\Nremember we said in on the previous slide, 
Dialogue: 0,0:21:53.42,0:21:56.38,Default,,0,0,0,,我们把log分为从节点还没有确认的prefix部分\Nwe split the log into a prefix that we are not sending,
Dialogue: 0,0:21:56.38,0:21:58.36,Default,,0,0,0,,我们假定接收方已经拥有了prefix部分的log项\Nwhich we assume the recipient already has,
Dialogue: 0,0:21:58.36,0:22:00.82,Default,,0,0,0,,以及包含新log项的suffix部分\Nand the suffix, which contains the new log entries.
Dialogue: 0,0:22:00.82,0:22:02.58,Default,,0,0,0,,首先 我们必须检查\NWell, first of all, we have to check 
Dialogue: 0,0:22:02.58,0:22:08.14,Default,,0,0,0,,从节点prefix部分持有的log项确实是主节点认为我们持有的log项\Nthat prefix we actually do have as the sender of the message thought we might do.
Dialogue: 0,0:22:08.14,0:22:13.14,Default,,0,0,0,,我们首先必须检查从节点的log.length\NSo, first of all we have to check that the follower’s log.length 
Dialogue: 0,0:22:13.14,0:22:17.86,Default,,0,0,0,,log.length至少应该与主节点的prefix部分一样长\Nis at least as long as the prefix that we left out on the sender.
Dialogue: 0,0:22:18.22,0:22:21.72,Default,,0,0,0,,如果不满足这个条件 则意味着主节点和从节点之间的log项有缺口\NSo, if this is not the case, that means there would be a gap in the log,
Dialogue: 0,0:22:21.72,0:22:26.52,Default,,0,0,0,,主节点没有给我们发送一些应该已经发送过的log项\Nwhere there're some log entries that the leader didn't send us,
Dialogue: 0,0:22:26.80,0:22:28.62,Default,,0,0,0,,从节点没有这些log项\Nbut we also don't have on the follower.
Dialogue: 0,0:22:28.62,0:22:32.80,Default,,0,0,0,,这种情况下 log不符合要求 我们必须先把log项的缺口抹平\NAnd so, in that case, the log would not be OK. We have to fill in that gap first.
Dialogue: 0,0:22:32.80,0:22:38.00,Default,,0,0,0,,第二个要求是 或者prefixLen等于0\NThe second requirement is either the prefixLen is 0,
Dialogue: 0,0:22:38.00,0:22:40.38,Default,,0,0,0,,或者如果prefixLen不等于0\Nor if the prefixLen is not 0, 
Dialogue: 0,0:22:40.38,0:22:46.04,Default,,0,0,0,,我们查看从节点prefix部分的最后一个log项\Nthen we have to look at the last log entry in the prefix on the follower,
Dialogue: 0,0:22:46.04,0:22:49.88,Default,,0,0,0,,我们希望这个log项的任期数\Nlook at its term number, and we want that term number 
Dialogue: 0,0:22:49.88,0:22:56.24,Default,,0,0,0,,等于主节点对应log项的任期数\Nto be equal to the corresponding log entries term number on the leader.
Dialogue: 0,0:22:56.24,0:22:59.96,Default,,0,0,0,,这里的prefixTerm就是主节点对应log项的任期数 随消息发送了过来\NThis prefixTerm is just a variable that was sent as part of the message.
Dialogue: 0,0:22:59.96,0:23:06.80,Default,,0,0,0,,这么做的目的是 Raft在执行过程中会保证维持一个不变性\NSo, the purpose for this is Raft has a certain invariant that it guarantees.
Dialogue: 0,0:23:06.80,0:23:11.56,Default,,0,0,0,,即如果系统中的两个节点在特定索引值上都有一个log项\NAnd that is if there are two nodes in the system that have a certain log,
Dialogue: 0,0:23:11.56,0:23:16.70,Default,,0,0,0,,同时 如果此特定索引值上的两个log项是相同的\Nand that's at a certain index of the log, they have the same log entry,
Dialogue: 0,0:23:17.12,0:23:21.32,Default,,0,0,0,,特别地 如果这两个log项的任期数是相同的\Nin particular, they have the same term number in that log entry,
Dialogue: 0,0:23:21.32,0:23:23.72,Default,,0,0,0,,Raft将保证\Nthen, Raft will guarantee that 
Dialogue: 0,0:23:23.72,0:23:27.52,Default,,0,0,0,,两个节点到此索引值之前的所有log项也一定相同\Nthe entire log up to and including that index will be identical.
Dialogue: 0,0:23:27.52,0:23:33.70,Default,,0,0,0,,因此 log项的任期数将允许我们很快判断出\NSo, the term number in the log entries actually allows us to tell efficiently 
Dialogue: 0,0:23:33.70,0:23:36.68,Default,,0,0,0,,这两个节点持有的log项是否相同\Nwhether two nodes have the same log or not,
Dialogue: 0,0:23:36.68,0:23:41.68,Default,,0,0,0,,因为两个节点拥有不同log项的唯一方法是\Nbecause the only way that two nodes could end up with different logs is 
Dialogue: 0,0:23:41.68,0:23:45.18,Default,,0,0,0,,特定log项的任期不相同\Nby having different term numbers on a certain log entry.
Dialogue: 0,0:23:45.18,0:23:49.94,Default,,0,0,0,,因此 这里要保证的是\NAnd so, what this here now guarantees is that 
Dialogue: 0,0:23:49.94,0:23:52.52,Default,,0,0,0,,如果logOk的判断结果为true\Nif this logOk condition is true, 
Dialogue: 0,0:23:52.52,0:23:58.28,Default,,0,0,0,,这意味着主节点prefix部分的log项\Nthat means that the prefix of the log as it was on the leader 
Dialogue: 0,0:23:58.28,0:24:03.18,Default,,0,0,0,,与从节点prefix部分到prefixTerm为止的log项完全相同\Nis identical to the prefix of the log of the same length as it is on the follower.
Dialogue: 0,0:24:03.18,0:24:08.18,Default,,0,0,0,,因此 这里logOk检查的是 到prefixTerm为止的log项是否完全相同\NSo, this logOk condition checks that actually the up to that point, the logs are identical.
Dialogue: 0,0:24:08.18,0:24:10.58,Default,,0,0,0,,这非常重要\NThis is absolutely crucial 
Dialogue: 0,0:24:10.58,0:24:15.52,Default,,0,0,0,,这可以保证所有节点最终都会按照相同顺序传递相同的消息\Nfor ensuring that actually, all of the nodes end up with the same messages delivered.
Dialogue: 0,0:24:17.08,0:24:22.36,Default,,0,0,0,,现在 如果log符合要求 且如果消息的任期是正确的\NNow, if this log is OK, and if the message was for the correct term,
Dialogue: 0,0:24:22.36,0:24:27.08,Default,,0,0,0,,我们将继续前进\Nthen we can go ahead and process the new log entries 
Dialogue: 0,0:24:27.08,0:24:29.46,Default,,0,0,0,,处理这条LogRequest消息中包含的新log项\Nthat were in this LogRequest message.
Dialogue: 0,0:24:29.46,0:24:31.38,Default,,0,0,0,,我们的具体处理方法是\NAnd the way we're going to do this is 
Dialogue: 0,0:24:31.38,0:24:34.90,Default,,0,0,0,,调用这个APPENDENTRIES（追加项）函数 我稍后会具体讲解这个函数\Nwe're going to call the APPENDENTRIES function that I will show you in a minute.
Dialogue: 0,0:24:34.90,0:24:41.08,Default,,0,0,0,,我们会为函数传入suffix部分 即传入新的log项 并传入其他一些变量\NAnd we're going to pass it the suffix, the new log entries, and a few other variables.
Dialogue: 0,0:24:41.08,0:24:44.56,Default,,0,0,0,,我们还要给主节点发送一个确认（ack）\NAnd we're going to also send an acknowledgement back to the leader, 
Dialogue: 0,0:24:44.56,0:24:48.68,Default,,0,0,0,,称：“我已经收到你的log项并处理完毕了”\Nsaying, “Hey, we received your log entries. It's all fine.”
Dialogue: 0,0:24:48.68,0:24:51.44,Default,,0,0,0,,这个确认就是另一个整数\NAnd this acknowledgement is going to be just another integer.
Dialogue: 0,0:24:51.44,0:24:54.54,Default,,0,0,0,,这个整数将告诉主节点\NAnd it's going to be the integers telling 
Dialogue: 0,0:24:54.54,0:24:57.68,Default,,0,0,0,,从节点已经从主节点\Nhow many log entries from the start of the log 
Dialogue: 0,0:24:57.68,0:25:00.66,Default,,0,0,0,,成功收到的log项数量\Nthat we have successfully received from the leader.
Dialogue: 0,0:25:00.66,0:25:04.08,Default,,0,0,0,,这个整数等于尚未回复确认的数量（prefixLen）\NAnd that is going to be the length of the prefix that was not sent 
Dialogue: 0,0:25:04.08,0:25:07.86,Default,,0,0,0,,加上主节点发送的suffix中所包含的log项数量（suffix.length）\Nplus the number of log entries in the suffix that was sent.
Dialogue: 0,0:25:07.86,0:25:10.28,Default,,0,0,0,,这就是处理完此条消息后\NSo, that's the total number of log entries 
Dialogue: 0,0:25:10.28,0:25:13.90,Default,,0,0,0,,从节点从主节点收到的log项总数量\Nthat we have from the leader after processing this message.
Dialogue: 0,0:25:13.90,0:25:18.28,Default,,0,0,0,,我们将把这个ack整数打包到一条消息中\NAnd this ack integer, we're just going to pack into a message.
Dialogue: 0,0:25:18.28,0:25:21.48,Default,,0,0,0,,我们要创建LogResponse（日志回复）消息 并将其发送回主节点\NSo, we're going to make a LogResponse message that we sent back to the leader.
Dialogue: 0,0:25:21.48,0:25:24.26,Default,,0,0,0,,这条消息将包含LogResponse消息的发送方id（nodeId）\NIt's going to contain the id of the sender of LogResponse,
Dialogue: 0,0:25:24.26,0:25:26.36,Default,,0,0,0,,当前任期数（currentTerm）\Nthe current term number as always,
Dialogue: 0,0:25:26.88,0:25:28.14,Default,,0,0,0,,我之前已经解释过ack\Nthe act that I just explained,
Dialogue: 0,0:25:28.14,0:25:32.06,Default,,0,0,0,,以及一个true 表明处理成功\Nand true to indicate that this was successful.
Dialogue: 0,0:25:32.06,0:25:36.82,Default,,0,0,0,,此时 从节点已经成功处理了这条LogRequest消息\NSo, the follower was successfully able to process this LogRequest message.
Dialogue: 0,0:25:36.82,0:25:38.64,Default,,0,0,0,,另一方面 如果不满足判断条件\NOn the other hand, if something is not OK,
Dialogue: 0,0:25:38.64,0:25:42.46,Default,,0,0,0,,即如果任期数是错误的 或者logOk为false\Nso, if the term number is wrong, or if the logOk is false,
Dialogue: 0,0:25:42.46,0:25:46.52,Default,,0,0,0,,则从节点发送回一条LogResponse消息 其最后一个变量为false\Nthen we send back a LogResponse message in which the last element is false.
Dialogue: 0,0:25:46.52,0:25:48.58,Default,,0,0,0,,这将告诉主节点\NAnd that tells the leader that 
Dialogue: 0,0:25:48.58,0:25:52.20,Default,,0,0,0,,从节点无法成功处理这条LogRequest消息\Nwe were not able to process that LogRequest message correctly.
Dialogue: 0,0:25:53.60,0:25:57.16,Default,,0,0,0,,我们来看看我前面提到的这个APPENDENTRIES函数\NLet's look at this APPENDENTRIES function that I just mentioned.
Dialogue: 0,0:25:57.16,0:26:02.04,Default,,0,0,0,,当检查并确定log符合要求后 我们就会调用APPENDENTRIES函数\NSo, APPENDENTRIES here is called if we have checked that the log is OK.
Dialogue: 0,0:26:02.04,0:26:06.00,Default,,0,0,0,,我们想把LogRequest消息中的新log项\NAnd we want to append the new entries from the LogRequest message 
Dialogue: 0,0:26:06.00,0:26:07.76,Default,,0,0,0,,追加进从节点的log中\Nto the follower’s log.
Dialogue: 0,0:26:07.76,0:26:10.26,Default,,0,0,0,,我们现在要做的第一件事情是进行检查\NAnd so, the first thing we now need to check is, 
Dialogue: 0,0:26:10.26,0:26:11.76,Default,,0,0,0,,有可能出现的一种情况是\Nwell, it could be that 
Dialogue: 0,0:26:11.76,0:26:16.80,Default,,0,0,0,,从节点已经持有了此条消息中的一些log项\Nthe follower already has some of the log entries that are contained within this message.
Dialogue: 0,0:26:16.80,0:26:20.06,Default,,0,0,0,,如果出现这种情况 我们需要检查这些log项是否相同\NAnd if so, we need to check whether those are the same.
Dialogue: 0,0:26:20.06,0:26:23.90,Default,,0,0,0,,首先 如果suffix部分非空\NSo, first of all, if the suffix is non-empty,
Dialogue: 0,0:26:23.90,0:26:28.08,Default,,0,0,0,,这意味着LogRequest消息的确包含新的log项\Nso, that means the LogRequest message did contain new log entries,
Dialogue: 0,0:26:28.08,0:26:35.36,Default,,0,0,0,,且如果从节点的log长度（log.length）大于prefixLen\Nand if the length of the follower’s log is longer than the prefixLen,
Dialogue: 0,0:26:35.36,0:26:40.12,Default,,0,0,0,,也就是说 从节点的一些log项已经超过了prefix部分的log项\Nso, that is, the follower already has some log entries that go beyond the prefix,
Dialogue: 0,0:26:40.12,0:26:44.94,Default,,0,0,0,,此时 新的log项 也就是suffix部分的log项\Nso, at this point, we have the suffix, the new log entries 
Dialogue: 0,0:26:44.94,0:26:49.90,Default,,0,0,0,,与从节点已经持有的log项存在一些重叠\Noverlapping with the log entries that the follower already has.
Dialogue: 0,0:26:49.90,0:26:54.52,Default,,0,0,0,,这种情况下 我们将找到从节点与主节点\NIn that case, we're going to find the last log entry that we can compare 
Dialogue: 0,0:26:54.52,0:26:57.10,Default,,0,0,0,,可以对比的最后一个log项所在的位置\Nbetween the follower’s state and the leader’s state.
Dialogue: 0,0:26:57.10,0:26:58.86,Default,,0,0,0,,可比较的最后一个log项位置\NAnd that's going to be 
Dialogue: 0,0:26:58.86,0:27:03.94,Default,,0,0,0,,或者等于从节点的log.length-1\Neither the log.length-1,
Dialogue: 0,0:27:03.94,0:27:08.26,Default,,0,0,0,,或者等于prefixLen+suffix.length-1\Nor it's going to be the prefixLen+suffix.length-1，
Dialogue: 0,0:27:08.64,0:27:11.26,Default,,0,0,0,,取这两个值的较小值\Nwhichever of those two is smaller.
Dialogue: 0,0:27:11.26,0:27:15.80,Default,,0,0,0,,这就是我们要比较的log项所对应的索引值\NAnd that is going to be the index of the log entry that we're going to compare.
Dialogue: 0,0:27:15.80,0:27:21.40,Default,,0,0,0,,对于这个特定的索引值 我们将比较\NAnd for that particular index, we are going to compare 
Dialogue: 0,0:27:22.04,0:27:24.94,Default,,0,0,0,,从节点log项的任期数\Nthe term number in the follower’s log 
Dialogue: 0,0:27:24.94,0:27:30.74,Default,,0,0,0,,和新log项 也就是从主节点收到的suffix部分\Nto the term number in the corresponding entry in the suffix, in the new log entries, 
Dialogue: 0,0:27:30.74,0:27:32.76,Default,,0,0,0,,对应log项的任期数\Nthat we received from the leader.
Dialogue: 0,0:27:32.76,0:27:35.58,Default,,0,0,0,,如果这两个log项的任期数不相同\NAnd if those are not the same term number,
Dialogue: 0,0:27:35.58,0:27:40.00,Default,,0,0,0,,这意味着log项存在不一致的情况 我们需要截断从节点的log项\Nthat means we have an inconsistency in the log, and we have to truncate the log.
Dialogue: 0,0:27:40.00,0:27:42.06,Default,,0,0,0,,我们接下来要做的是\NAnd so, what we're going to do then is 
Dialogue: 0,0:27:42.06,0:27:47.84,Default,,0,0,0,,只保留从节点截至prefixLen的log项\Nto actually keep only the follower’s log up to prefixLen,
Dialogue: 0,0:27:47.84,0:27:51.72,Default,,0,0,0,,我们把从节点所有超过prefixLen的log项都扔掉\Nand everything beyond prefixLen, we're going to throw away.
Dialogue: 0,0:27:52.24,0:27:54.00,Default,,0,0,0,,这么做是正确的\NThat is the correct thing to do here, 
Dialogue: 0,0:27:54.00,0:27:57.66,Default,,0,0,0,,因为前面的log项可能来自于前面的主节点\Nbecause those previous log entries might have come from a previous leader,
Dialogue: 0,0:27:58.36,0:28:00.18,Default,,0,0,0,,且这些log项还没有被提交\Nand they will not yet be committed.
Dialogue: 0,0:28:00.18,0:28:08.54,Default,,0,0,0,,Raft要保证的一个关键性质是 如果一个log项已被提交\NSo, a key property that Raft ensures is that if a log entry is committed,
Dialogue: 0,0:28:08.54,0:28:10.98,Default,,0,0,0,,则此log项将不会被修改 也不会被丢弃\Nthen it will never change, and it won't be discarded,
Dialogue: 0,0:28:10.98,0:28:13.88,Default,,0,0,0,,此log项不会因为这里的截断操作而被移除\Nand it won't be removed by this truncation process here.
Dialogue: 0,0:28:14.84,0:28:18.22,Default,,0,0,0,,但如果一个log项尚未被提交\NBut a log entry that is not yet committed, 
Dialogue: 0,0:28:18.22,0:28:22.82,Default,,0,0,0,,则此log项有可能被这里的截断操作移除\Nit could happen that that log entry gets removed as part of this truncation.
Dialogue: 0,0:28:24.14,0:28:29.14,Default,,0,0,0,,如果这两个log项的任期数相同 则我前面已经解释过\NSo, if these term numbers are the same, then as I explained earlier 
Dialogue: 0,0:28:29.14,0:28:32.02,Default,,0,0,0,,Raft会保证 包括这一特定的索引值在内\NRaft guarantees that then the logs are identical 
Dialogue: 0,0:28:32.02,0:28:35.38,Default,,0,0,0,,所有之前的log项也都相同\Nup to that point including that particular index.
Dialogue: 0,0:28:35.82,0:28:39.94,Default,,0,0,0,,这种情况下 我们不需要截断log 因为我们知道\NAnd in that case, we don't need to truncate the logs, because we know that 
Dialogue: 0,0:28:39.94,0:28:44.14,Default,,0,0,0,,主节点的log和从节点的log是一致的\Nthe leader’s log and the follower’s log are consistent with each other.
Dialogue: 0,0:28:44.14,0:28:48.26,Default,,0,0,0,,无论我们是否会截断log\NEither way, regardless of whether we need it to truncate or not,
Dialogue: 0,0:28:48.26,0:28:52.56,Default,,0,0,0,,我们现在都要把新的log项追加进从节点的log中\Nwe can now append any new log entries to the log.
Dialogue: 0,0:28:52.56,0:28:55.18,Default,,0,0,0,,这里有可能出现的情况是\NAnd so, it could be now here that 
Dialogue: 0,0:28:55.18,0:28:59.50,Default,,0,0,0,,suffix部分包含从节点已经持有的一些log项\Nthe suffix contains some log entries that the follower already has,
Dialogue: 0,0:28:59.50,0:29:01.78,Default,,0,0,0,,此时 我们就不需要追加这些log项了\Nin which case, we don't need to append them again.
Dialogue: 0,0:29:01.78,0:29:08.94,Default,,0,0,0,,我们将suffix部分中从节点尚未持有的第一个log项开始\NAnd we're just going to start off with the first entry in the suffix 
Dialogue: 0,0:29:08.94,0:29:11.92,Default,,0,0,0,,把从这里开始的log项追加进从节点的log中\Nthat the follower does not already have.
Dialogue: 0,0:29:11.92,0:29:14.36,Default,,0,0,0,,我们一直追加到suffix部分的最后一个log项\NAnd we go up to the last entry in the suffix.
Dialogue: 0,0:29:14.36,0:29:17.26,Default,,0,0,0,,我们把这些log项依次追加进从节点的log中\NAnd we append each of them to the follower's log.
Dialogue: 0,0:29:19.00,0:29:21.58,Default,,0,0,0,,这里有一个叫leaderCommit（主节点确认）的变量\NNow comes a variable called leaderCommit.
Dialogue: 0,0:29:21.58,0:29:24.00,Default,,0,0,0,,我之前没有介绍过这个变量的含义\NI've not talked about this very much yet.
Dialogue: 0,0:29:24.00,0:29:28.36,Default,,0,0,0,,但当我们讨论提交log项时 这个变量就变得非常重要了\NBut this will become important now when we talk about committing log entries.
Dialogue: 0,0:29:28.36,0:29:31.96,Default,,0,0,0,,leaderCommit是一个整数 它告诉我们…\NThe leaderCommit is just an integer, and it tells us…
Dialogue: 0,0:29:32.78,0:29:34.06,Default,,0,0,0,,这个leaderCommit变量\NThis leaderCommit variable, 
Dialogue: 0,0:29:34.06,0:29:37.44,Default,,0,0,0,,包含在主节点发来的LogRequest消息中\Nthis came as part of the LogRequest message from the leader,
Dialogue: 0,0:29:37.44,0:29:40.82,Default,,0,0,0,,commitLength是从节点存储的一个变量\NcommitLength is a variable that is stored under a follower.
Dialogue: 0,0:29:40.82,0:29:43.42,Default,,0,0,0,,这个变量追踪了\NAnd it keeps track of 
Dialogue: 0,0:29:43.42,0:29:48.48,Default,,0,0,0,,自启动开始 从节点已经提交的log项总数量\Nhow many log entries counted from the start of the log have we committed so far.
Dialogue: 0,0:29:48.48,0:29:52.72,Default,,0,0,0,,如果主节点已经提交的log项总数量\NAnd if the number of log entries that the leader has committed 
Dialogue: 0,0:29:52.72,0:29:56.76,Default,,0,0,0,,大于从节点已经提交的log项总数量\Nis greater than the log number of log entries that the follower has committed,
Dialogue: 0,0:29:56.76,0:30:00.24,Default,,0,0,0,,这意味着从节点可以准备提交更多的log项了\Nthat means more log entries are ready to be committed.
Dialogue: 0,0:30:00.24,0:30:04.06,Default,,0,0,0,,因此 是否可以提交一个log项是由主节点决定的\NSo, it's the leader that decides when a log entry can be committed 
Dialogue: 0,0:30:04.06,0:30:07.46,Default,,0,0,0,,决定方法是增加leaderCommit变量的值\Nby increasing this leaderCommit variable.
Dialogue: 0,0:30:07.46,0:30:10.02,Default,,0,0,0,,如果leaderCommit更大\NAnd so, if this leaderCommit is greater, 
Dialogue: 0,0:30:10.02,0:30:16.66,Default,,0,0,0,,这意味着从节点可以从commitLength开始的索引值取出log项\Nthat means we can now take the log indexes starting from commitLength 
Dialogue: 0,0:30:16.66,0:30:19.56,Default,,0,0,0,,一直取出到leaderCommit-1对应的log项\Nand all the way up to leaderCommit-1.
Dialogue: 0,0:30:19.56,0:30:21.44,Default,,0,0,0,,这些log项都准备好被提交了\NAnd those are ready to be committed.
Dialogue: 0,0:30:21.44,0:30:22.56,Default,,0,0,0,,具体提交过程是\NAnd to commit means, 
Dialogue: 0,0:30:22.56,0:30:26.98,Default,,0,0,0,,首先 从节点将commitLength更新为包含新提交的log项索引值\Nhere, first of all, we set the commitLength to include those indexes, 
Dialogue: 0,0:30:26.98,0:30:29.74,Default,,0,0,0,,随后 从节点将这些消息传递给应用\Nand also, we deliver those messages to the application.
Dialogue: 0,0:30:29.74,0:30:35.30,Default,,0,0,0,,这就是从节点传递全序顺序广播消息的位置\NSo, this is now the total order broadcast delivery as it happens on the followers.
Dialogue: 0,0:30:35.80,0:30:41.50,Default,,0,0,0,,下一页幻灯片将单独介绍主节点传递全序顺序广播消息的位置\NThe total broadcast delivery on the leader happens separately on the next slide.
Dialogue: 0,0:30:42.94,0:30:47.20,Default,,0,0,0,,这就是从节点涉及的所有操作了\NSo, that is actually all that happens on the followers.
Dialogue: 0,0:30:47.20,0:30:50.44,Default,,0,0,0,,我们讲完了从节点视角下的故事\NSo, that's completed the story from the point of view of the followers.
Dialogue: 0,0:30:50.44,0:30:53.96,Default,,0,0,0,,我们只需要再讲完主节点视角下的故事\NWe just need to finish the story from the point of view of the leader.
Dialogue: 0,0:30:53.96,0:30:55.88,Default,,0,0,0,,如果你还记得\NAnd so, if you remember, 
Dialogue: 0,0:30:56.60,0:31:01.40,Default,,0,0,0,,从节点在这里给主节点发送回了一个LogResponse消息\Nhere the followers sent a LogResponse message back to the leader, telling it 
Dialogue: 0,0:31:01.40,0:31:07.52,Default,,0,0,0,,告诉主节点 从节点是否接受了新的log项并追加进自己的log中\Nwhether the follower was able to accept the new log entries and append them to the log.
Dialogue: 0,0:31:07.52,0:31:09.30,Default,,0,0,0,,在这里\NAnd this is now 
Dialogue: 0,0:31:09.30,0:31:13.56,Default,,0,0,0,,当主节点从从节点收到这些LogResponse消息后\Nwhen the leader receives those LogResponse messages from the follower, 
Dialogue: 0,0:31:13.56,0:31:18.18,Default,,0,0,0,,主节点现在需要决定哪些log项已经准备好被提交了\Nand now the leader needs to decide which log entries are ready to be committed.
Dialogue: 0,0:31:18.18,0:31:20.76,Default,,0,0,0,,如果一个log项已经被系统中的多半quorum节点确认\NSo, a log entry is ready to be committed 
Dialogue: 0,0:31:20.76,0:31:25.82,Default,,0,0,0,,则这个log项就已经准备好被提交了\Nif it's been acknowledged by a quorum of nodes in the system.
Dialogue: 0,0:31:27.40,0:31:30.62,Default,,0,0,0,,当主节点收到其中一个LogResponse消息时\NWhen the leader receives one of these LogResponse messages,
Dialogue: 0,0:31:30.62,0:31:32.34,Default,,0,0,0,,和之前收到一条消息的处理过程一样\Nas always when receiving a message, 
Dialogue: 0,0:31:32.34,0:31:34.54,Default,,0,0,0,,主节点第一件要做的事情是检查任期数\Nthe first thing it has to do is check the term number.
Dialogue: 0,0:31:34.54,0:31:38.94,Default,,0,0,0,,如果LogResponse消息中的任期数大于主节点当前的任期数\NSo, if the term number in the LogResponse message is greater than the leader's term,
Dialogue: 0,0:31:38.94,0:31:42.40,Default,,0,0,0,,这意味着系统中出现了持有更高任期数的新节点\Nthat means, oh, there's a new node with a higher term number.
Dialogue: 0,0:31:42.40,0:31:47.36,Default,,0,0,0,,和之前一样 主节点必须接受此任期数 将自己转变为从节点状态\NAs always, we have to accept that term number and transition to follower state,
Dialogue: 0,0:31:47.36,0:31:52.20,Default,,0,0,0,,忘记上一任期中自己给哪个节点投了票 取消选举计时器\Nforget whoever we voted for in a previous term, and cancel the election timer.
Dialogue: 0,0:31:52.20,0:31:55.48,Default,,0,0,0,,当任期数正确时\NHowever, in the case where the term number is correct,
Dialogue: 0,0:31:55.48,0:31:58.54,Default,,0,0,0,,也就是消息中的任期数与主节点的任期数匹配\Nso, the term number matches the leader's term number,
Dialogue: 0,0:31:58.54,0:32:01.16,Default,,0,0,0,,且主节点现在仍然为主节点\Nand the leader is in fact still the leader,
Dialogue: 0,0:32:01.16,0:32:03.28,Default,,0,0,0,,主节点会继续往下\Nthen it can go ahead.
Dialogue: 0,0:32:03.28,0:32:07.42,Default,,0,0,0,,主节点需要先检查success字段是否为true\NNow, first, it has to check was the success field true.
Dialogue: 0,0:32:07.42,0:32:10.22,Default,,0,0,0,,这个success字段指的是主节点收到的从节点LogResponse消息中\NSo, this is the success field in the LogResponse message 
Dialogue: 0,0:32:10.22,0:32:12.24,Default,,0,0,0,,所包含的success字段\Nthat it received from the follower.
Dialogue: 0,0:32:12.24,0:32:14.84,Default,,0,0,0,,如果success字段为true\NAnd if this success field is true, 
Dialogue: 0,0:32:14.84,0:32:18.86,Default,,0,0,0,,且此消息中包含的确认值（ack）\Nand if the acknowledgement that was contained in that message 
Dialogue: 0,0:32:18.86,0:32:25.08,Default,,0,0,0,,至少等于相同从节点之前已经确认过的确认值\Nis at least the number that was previously acknowledged by the same follower,
Dialogue: 0,0:32:25.08,0:32:29.52,Default,,0,0,0,,这意味着从节点正在确认新的消息\Nthat means the follower’s acknowledging new messages now.
Dialogue: 0,0:32:29.52,0:32:33.10,Default,,0,0,0,,如果消息没有按照顺序传递 则现象是\NIf the messages get delivered out of order, it could happen that 
Dialogue: 0,0:32:33.62,0:32:39.02,Default,,0,0,0,,具有较高ack值的消息先被传递 具有较低ack值的消息后被传递\Na message with a higher act is delivered first, and then a message with a lower act later.
Dialogue: 0,0:32:39.02,0:32:42.58,Default,,0,0,0,,因此 这将保证无论消息按照何种顺序传递\NSo, this ensures that no matter which order the messages are delivered,
Dialogue: 0,0:32:42.98,0:32:44.98,Default,,0,0,0,,每个节点都会按照相同的顺序传递\Neverything ends up being fine.
Dialogue: 0,0:32:44.98,0:32:49.40,Default,,0,0,0,,如果判断结果和我们期待的一样\NSo, in the expected case, where the acknowledgement 
Dialogue: 0,0:32:49.40,0:32:52.64,Default,,0,0,0,,即ack值大于等于之前的ack值\Nis greater than whatever the previous acknowledgement was,
Dialogue: 0,0:32:52.64,0:32:56.52,Default,,0,0,0,,主节点可以判断\Nthe leader can now record the fact that 
Dialogue: 0,0:32:56.52,0:32:59.50,Default,,0,0,0,,它收到了此特定从节点的确认信息 主节点把确认信息记录下来\Nit has received an acknowledgement from this particular follower.
Dialogue: 0,0:32:59.50,0:33:00.24,Default,,0,0,0,,记录的方法是\NAnd it does this 
Dialogue: 0,0:33:00.24,0:33:05.72,Default,,0,0,0,,将sentLength变量和actedLength变量都更新为ack值\Nby updating both the sentLength variable and the actedLength variable to be that integer 
Dialogue: 0,0:33:05.72,0:33:10.82,Default,,0,0,0,,也就是更新为此特定从节点已确认的log项数量\Nthat is, the number of acknowledged log entries from that particular follower.
Dialogue: 0,0:33:10.82,0:33:13.04,Default,,0,0,0,,随后 主节点调用COMMITLOGENTRIES（确认日志项）函数\NAnd it then calls the COMMITLOGENTRIES function 
Dialogue: 0,0:33:13.04,0:33:14.72,Default,,0,0,0,,函数描述在下一页幻灯片中\Nwhich will be on the next slide 
Dialogue: 0,0:33:14.72,0:33:18.44,Default,,0,0,0,,从而确认哪些log项已经准备好被提交了\Nto actually decide which log entries are ready to be committed.
Dialogue: 0,0:33:19.60,0:33:24.14,Default,,0,0,0,,另一方面 如果LogResponse没有成功\NOn the other hand, if this LogResponse was not successful,
Dialogue: 0,0:33:25.20,0:33:29.42,Default,,0,0,0,,我们必须要检查sentLength\Nthen we have to check the sentLength.
Dialogue: 0,0:33:29.42,0:33:34.32,Default,,0,0,0,,如果LogResponse没有成功 有种情况是主节点和从节点的log项存在缺口\NAnd so, if it was not successful, it could be that there was a gap in the log.
Dialogue: 0,0:33:34.32,0:33:38.24,Default,,0,0,0,,大家还记得 我们把log拆分为prefix部分和suffix部分\NSo, remember, we split the log into a prefix and a suffix,
Dialogue: 0,0:33:38.24,0:33:40.96,Default,,0,0,0,,我们假设从节点持有prefix部分的所有log项\Nthe prefix we assumed the follower already has.
Dialogue: 0,0:33:40.96,0:33:44.22,Default,,0,0,0,,但如果从节点丢失了其中一部分log项呢？\NBut what if the follower lost part of its log?
Dialogue: 0,0:33:44.22,0:33:47.90,Default,,0,0,0,,如果是这样 则log项存在缺口 从节点未持有所有prefix部分的log项\NAnd there's actually a gap and it doesn't have the entire prefix.
Dialogue: 0,0:33:47.90,0:33:50.10,Default,,0,0,0,,这一部分代码就是处理这种情况的\NThat's the case that we handle here.
Dialogue: 0,0:33:50.10,0:33:52.90,Default,,0,0,0,,如果是因为这种情况使得LogResponse没有成功\NSo, in this case, if the success was not true, 
Dialogue: 0,0:33:52.90,0:33:59.32,Default,,0,0,0,,我们要递减从节点的sentLength变量\Nthen the sentLength variable for the follower, we're just going to decrement that.
Dialogue: 0,0:33:59.32,0:34:01.08,Default,,0,0,0,,我们要把从节点的sentLength变量减1\NSo, we're going to reduce it by 1,
Dialogue: 0,0:34:01.08,0:34:05.32,Default,,0,0,0,,这意味着我们要把prefix部分的长度缩小1\Nand that means now we're going to shrink the length of the prefix by 1,
Dialogue: 0,0:34:05.32,0:34:11.44,Default,,0,0,0,,我们要在下一次尝试中 向此从节点多发送一个log项\Nand we're going to send one more log entry to the follower on our next attempt.
Dialogue: 0,0:34:11.44,0:34:15.02,Default,,0,0,0,,如果从节点和主节点持有的log项\NNow, if there's a large gap between 
Dialogue: 0,0:34:15.02,0:34:19.20,Default,,0,0,0,,存在巨大的缺口\Nwhat the log that the follower has and the log that the leader has,
Dialogue: 0,0:34:19.20,0:34:21.16,Default,,0,0,0,,这个过程会被多次迭代\Nthis could take quite a few iterations 
Dialogue: 0,0:34:21.16,0:34:25.12,Default,,0,0,0,,我们在每次迭代中只把prefix部分的长度减小1\Nwhere we just reduce the length of the prefix by 1 every single time.
Dialogue: 0,0:34:25.54,0:34:27.92,Default,,0,0,0,,你可能会想象出更高效的处理方法\NSo, you could imagine more efficient ways of doing this,
Dialogue: 0,0:34:27.92,0:34:30.18,Default,,0,0,0,,但我们现在先按照简单的方式处理\Nbut for now, we're just going to keep it.
Dialogue: 0,0:34:30.18,0:34:33.92,Default,,0,0,0,,这个算法已经足够复杂了 我们不要再让算法变得更加复杂\NIt's complicated enough as it is. We're not going to over complicate it.
Dialogue: 0,0:34:33.92,0:34:36.70,Default,,0,0,0,,主节点只把sentLength减1\NAnd we're just going to reduce this sentLength by 1,
Dialogue: 0,0:34:36.70,0:34:38.72,Default,,0,0,0,,随后 主节点再次调用REPLICATELOG函数\Nand then, call the REPLICATELOG function again.
Dialogue: 0,0:34:38.72,0:34:40.90,Default,,0,0,0,,大家还记得 我们之前见过了REPLICATELOG函数\NRemember, we saw REPLICATELOG earlier.
Dialogue: 0,0:34:40.90,0:34:46.10,Default,,0,0,0,,这个函数的目的是向此从节点发送sentLength之后的所有log项\NAnd this is going to send all of the log entries that go beyond this sentLength.
Dialogue: 0,0:34:46.10,0:34:51.94,Default,,0,0,0,,这样就可以保证 我们最终总可以抹平log项缺口\NAnd so, this will ensure that eventually, we will fill in any gap in the log,
Dialogue: 0,0:34:51.94,0:34:56.48,Default,,0,0,0,,并保证从节点最终能够接受新的log项\Nand eventually, the follower will be able to apply the new log entries,
Dialogue: 0,0:34:57.50,0:35:02.18,Default,,0,0,0,,因为主节点可以通过这一过程把所有缺失的log项都发送给从节点\Nbecause we've sent all of the missing log entries from the leader to the follower.
Dialogue: 0,0:35:02.18,0:35:08.54,Default,,0,0,0,,这就是主节点的处理过程了 最后还差的是COMMITLOGENTRIES函数\NOK, and that is the leader side except for the COMMITLOGENTRIES function.
Dialogue: 0,0:35:08.54,0:35:11.70,Default,,0,0,0,,这是我们要学习的最后一个函数了\NSo, that's the last one that we need to look at.
Dialogue: 0,0:35:11.70,0:35:18.50,Default,,0,0,0,,这个函数会查看actedLength变量\NAnd this one here, it's now looks at this actedLength variable.
Dialogue: 0,0:35:18.50,0:35:20.30,Default,,0,0,0,,大家还记得 actedLength变量\NRemember, in the actedLength variable, 
Dialogue: 0,0:35:20.30,0:35:25.50,Default,,0,0,0,,记录了从每个从节点收到的\Nwe recorded for every follower the number of log entries that 
Dialogue: 0,0:35:25.50,0:35:28.52,Default,,0,0,0,,已经确认的log项数量\Nthat follower has confirmed as having received.
Dialogue: 0,0:35:28.52,0:35:34.34,Default,,0,0,0,,因此 我们这里从commitLength开始循环\NAnd so, here we are now going to start off with the variable commitLength.
Dialogue: 0,0:35:34.34,0:35:37.20,Default,,0,0,0,,commitLength是从log最开始到现在\NSo, that is, commitLength is the number of log entries 
Dialogue: 0,0:35:37.20,0:35:40.12,Default,,0,0,0,,系统所有节点已经提交的log项数量\Ncounted from the start of the log that we have already committed.
Dialogue: 0,0:35:40.12,0:35:41.18,Default,,0,0,0,,现在 我们希望判断\NAnd now, we want to see 
Dialogue: 0,0:35:41.18,0:35:45.86,Default,,0,0,0,,是否存在已经准备好提交的新log项\Nif there are any additional log entries that are also ready to be committed.
Dialogue: 0,0:35:45.86,0:35:51.04,Default,,0,0,0,,只要commitLength小于log.length\NAnd so, as long as commitLength is less than log.length,
Dialogue: 0,0:35:52.58,0:35:54.04,Default,,0,0,0,,我们就先把acks初始化为0\Nwe initialize acks to 0, 
Dialogue: 0,0:35:54.04,0:35:59.60,Default,,0,0,0,,这个acks变量将记录 包括从节点和主节点在内\Nand then this acks variable will count from how many nodes, 
Dialogue: 0,0:35:59.60,0:36:02.98,Default,,0,0,0,,有多少个节点\Nfrom how many followers and also the leader, 
Dialogue: 0,0:36:02.98,0:36:05.30,Default,,0,0,0,,已经确认了此log项\Nwe have an acknowledgement.
Dialogue: 0,0:36:05.30,0:36:09.04,Default,,0,0,0,,我们将遍历系统中的所有节点\NAnd so, we are going to go through all of the nodes in the system,
Dialogue: 0,0:36:09.60,0:36:11.12,Default,,0,0,0,,包括主节点和所有的从节点\Nthe leader and all of the followers,
Dialogue: 0,0:36:11.12,0:36:14.52,Default,,0,0,0,,我们将检查每个节点的actedLength变量\Nand we're going to check the actedLength variable for each of those nodes.
Dialogue: 0,0:36:14.52,0:36:18.34,Default,,0,0,0,,如果actedLength大于commitLength\NAnd if its value is greater than the commitLength,
Dialogue: 0,0:36:18.34,0:36:22.02,Default,,0,0,0,,这意味着从这个特定节点的视角看\Nthen that means from the point of view of that particular node,
Dialogue: 0,0:36:22.02,0:36:25.64,Default,,0,0,0,,它认为可以向前推进commitLength了\Nit's OK to move the commitLength forward.
Dialogue: 0,0:36:25.64,0:36:31.20,Default,,0,0,0,,也就是说 此节点已经确认了比commitLength更多的log项\NSo, it has already acknowledged more log entries beyond the existing commitLength.
Dialogue: 0,0:36:31.20,0:36:33.78,Default,,0,0,0,,我们把这个节点记录为已确认\NAnd so, we're going to count that as an acknowledgement.
Dialogue: 0,0:36:33.78,0:36:37.46,Default,,0,0,0,,现在 我们要查看索引值为commitLength的log项\NAnd now, we're going to see if the number of acknowledgments 
Dialogue: 0,0:36:37.46,0:36:42.16,Default,,0,0,0,,所收到的确认数量\Nthat we've received for the log entry at index commitLength,
Dialogue: 0,0:36:42.16,0:36:49.68,Default,,0,0,0,,如果确认数量达到多半 则这个log项就可以被提交了\Nif that is greater than a majority, then it's ready for that log entry to be committed.
Dialogue: 0,0:36:49.68,0:36:54.92,Default,,0,0,0,,这种情况下 我们就将传递索引值为commitLength的log项\NAnd so, in this case, we're now going to do the total order broadcast delivery
Dialogue: 0,0:36:54.92,0:36:59.76,Default,,0,0,0,,这样就保证了此消息的传递满足全序顺序广播要求\Nof the message at the log entry with index commitLength.
Dialogue: 0,0:36:59.76,0:37:02.90,Default,,0,0,0,,主节点就是在这里将这条消息传递给应用的\NThat's going to be delivered to the application. This is on the leader.
Dialogue: 0,0:37:02.90,0:37:07.70,Default,,0,0,0,,我们将递增commitLength变量的值\NAnd we're going to increment the value of the commitLength variable.
Dialogue: 0,0:37:07.70,0:37:11.86,Default,,0,0,0,,在我们下次调用REPLICATELOG函数时\NAnd this new variable will then be sent out to all of the followers 
Dialogue: 0,0:37:11.86,0:37:15.24,Default,,0,0,0,,我们会将这个变量发送给所有的从节点\Nthe next time we call the REPLICATELOG function.
Dialogue: 0,0:37:15.24,0:37:17.60,Default,,0,0,0,,我们继续执行这个循环\NAnd so, we keep going around this loop here, 
Dialogue: 0,0:37:17.60,0:37:23.00,Default,,0,0,0,,只要quorum节点超过多半 我们就提交log项\Nand committing log entries as long as we can reach this majority quorum.
Dialogue: 0,0:37:23.00,0:37:25.14,Default,,0,0,0,,如果在某一时刻 我们发现\NIf at some point, then we reach the point 
Dialogue: 0,0:37:25.14,0:37:27.86,Default,,0,0,0,,某个log项没有得到多半quorum节点的确认\Nwhere we don't have a majority quorum of acknowledgements yet,
Dialogue: 0,0:37:27.86,0:37:29.64,Default,,0,0,0,,我们就跳出这个循环\Nthen we just break out of the loop, 
Dialogue: 0,0:37:29.64,0:37:33.16,Default,,0,0,0,,因为这意味着在提交更多的log项之前\Nbecause that means we have to wait for more LogResponse messages 
Dialogue: 0,0:37:33.70,0:37:36.72,Default,,0,0,0,,我们必须等待更多的LogResponse消息\Nbefore we can do further commits.
Dialogue: 0,0:37:36.72,0:37:37.64,Default,,0,0,0,,介绍完毕\NAnd that's it.
Dialogue: 0,0:37:37.64,0:37:42.20,Default,,0,0,0,,这就是完整的Raft公式算法\NThat is the entirety of the Raft consensus algorithm.
Dialogue: 0,0:37:42.20,0:37:43.58,Default,,0,0,0,,我希望大家能跟得上\NI hope you were able to follow it.
Dialogue: 0,0:37:43.58,0:37:47.66,Default,,0,0,0,,我知道算法包含了大量的细节 但我认为\NI know it's a huge amount of detail, but I thought 
Dialogue: 0,0:37:47.66,0:37:51.42,Default,,0,0,0,,理解主节点和从节点之间的交互过程真的很有趣\Nit's really interesting to see that interplay between the leaders and the followers,
Dialogue: 0,0:37:51.42,0:37:54.16,Default,,0,0,0,,比如各个节点总要检查任期数之类的\Nalways having to check the term number, and so on.
Dialogue: 0,0:37:54.74,0:37:59.04,Default,,0,0,0,,你可以看到 共识算法如何通过仔细排序所有信息\NBut you can see by very carefully sequencing all of the things,
Dialogue: 0,0:37:59.04,0:38:03.20,Default,,0,0,0,,才实现的全序顺序广播\Nit is possible to actually achieve something like total order broadcast.
Dialogue: 0,0:38:03.20,0:38:05.70,Default,,0,0,0,,这就是本节课的内容了 下节课再见\NThat's all for this lecture. See you next time.
