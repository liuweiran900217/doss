[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 6.1_Consensus.mp4
Video File: 6.1_Consensus.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 269
Active Line: 276
Video Position: 32451

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.78,0:00:05.46,Default,,0,0,0,,大家好 欢迎来到分布式系统的第6课\NHello, and welcome to lecture 6 on distributed systems.
Dialogue: 0,0:00:05.46,0:00:07.66,Default,,0,0,0,,今天 我们将学习共识\NToday we will look at consensus,
Dialogue: 0,0:00:07.66,0:00:09.80,Default,,0,0,0,,这是分布式系统中\Nwhich is one of the most tricky,
Dialogue: 0,0:00:09.80,0:00:13.78,Default,,0,0,0,,最棘手、也是最重要的问题\Nbut also one of the most important problems in distributed systems.
Dialogue: 0,0:00:13.78,0:00:19.88,Default,,0,0,0,,我们在上一节课讨论了状态机复制\NAnd the context to this is, last lecture, we talked about state machine replication,
Dialogue: 0,0:00:19.88,0:00:23.38,Default,,0,0,0,,这是一种复制数据的好方法\Nwhich is a great way of replicating some data
Dialogue: 0,0:00:23.38,0:00:26.28,Default,,0,0,0,,可以将数据从一个节点/副本复制到另一个节点/副本\Nfrom one node to another, from one replica to another.
Dialogue: 0,0:00:26.28,0:00:28.56,Default,,0,0,0,,为了实现状态机复制\NAnd in order to do state machine replication,
Dialogue: 0,0:00:28.56,0:00:32.26,Default,,0,0,0,,我们需要保证所有副本按照相同的顺序执行更新操作\Nwe need to ensure that all of the replicas see the same updates in the same order,
Dialogue: 0,0:00:32.26,0:00:34.96,Default,,0,0,0,,我们可以用全序关系广播实现这一点\Nwhich we can do with total order broadcast.
Dialogue: 0,0:00:34.96,0:00:38.98,Default,,0,0,0,,这引出了一个问题 我们该如何实现全序关系广播\NThis now raises the question of how do we implement total order broadcast.
Dialogue: 0,0:00:38.98,0:00:40.94,Default,,0,0,0,,我们在前面介绍了一种实现方法\NWe saw one way of doing this is
Dialogue: 0,0:00:40.94,0:00:46.02,Default,,0,0,0,,由一个指定的节点来发送所有的消息 我们称此节点为主节点\Nto send all of the messages via a particular dedicated node that we call the leader.
Dialogue: 0,0:00:46.02,0:00:48.52,Default,,0,0,0,,此节点将排序所有消息\NAnd this node is going to order all of the messages
Dialogue: 0,0:00:48.52,0:00:53.06,Default,,0,0,0,,保证所有节点都按照相同的顺序传递消息\Nand make sure that they get delivered in the same order on all of the nodes.
Dialogue: 0,0:00:53.06,0:00:55.54,Default,,0,0,0,,不幸的是 如果主节点崩溃\NUnfortunately, if that leader crashes,
Dialogue: 0,0:00:55.54,0:00:58.40,Default,,0,0,0,,或者主节点因网络问题变得不可用\Nor it becomes unavailable due to a network problem,
Dialogue: 0,0:00:58.40,0:01:02.20,Default,,0,0,0,,或者主节点遇到硬件故障 或者主节点遇到任何导致错误的情况\Nor it has a hardware failure, or whatever anything goes wrong,
Dialogue: 0,0:01:02.84,0:01:06.82,Default,,0,0,0,,这种全序关系广播方法就无法继续工作了\Nthen this approach to total order broadcast stops working.
Dialogue: 0,0:01:06.82,0:01:09.76,Default,,0,0,0,,现在的问题是\NNow, the question is now really
Dialogue: 0,0:01:09.76,0:01:15.60,Default,,0,0,0,,如何解决主节点不可用的问题\Nhow can we deal with the problem of a leader becoming unavailable.
Dialogue: 0,0:01:15.60,0:01:20.40,Default,,0,0,0,,一种选择是人工切换新的主节点\NOne option is to manually switch over to a new leader,
Dialogue: 0,0:01:20.40,0:01:22.36,Default,,0,0,0,,切换主节点这一过程称为故障切换\Nand this process is called failover.
Dialogue: 0,0:01:22.36,0:01:28.46,Default,,0,0,0,,人工的意思是 当主节点失效时 有位人工操作员会收到通知\NSo, manually means there's a human operator who gets notified if the leader fails,
Dialogue: 0,0:01:28.46,0:01:32.12,Default,,0,0,0,,这个人会选择一个新的节点作为新主节点\Nand this human is then going to choose a new node as the new leader.
Dialogue: 0,0:01:32.12,0:01:34.44,Default,,0,0,0,,这个人将重配置系统\NAnd it's going to reconfigure the system,
Dialogue: 0,0:01:34.44,0:01:39.54,Default,,0,0,0,,让所有从节点都接受这个新的节点作为新主节点\Nso, change all of the followers to accepting this new node as their new leader,
Dialogue: 0,0:01:39.54,0:01:43.16,Default,,0,0,0,,同时告诉这个新节点 它已经成为主节点了\Ntelling this new node that it now has to be the leader,
Dialogue: 0,0:01:43.16,0:01:48.02,Default,,0,0,0,,并赋予它实现全序关系广播的能力\Nand act in this capacity to implement total order broadcast.
Dialogue: 0,0:01:48.02,0:01:53.26,Default,,0,0,0,,如果你能提前知道主节点将会下线 那么这种方法就是可行的\NAnd this works fine if you know in advance if the leader is going to go down,
Dialogue: 0,0:01:53.70,0:01:54.50,Default,,0,0,0,,确实有可能出现这种情况\Nwhich could happen,
Dialogue: 0,0:01:54.50,0:01:58.10,Default,,0,0,0,,例如 主节点因计划内的维护将会下线\Nfor example, if the leader is going down due to planned maintenance.
Dialogue: 0,0:01:58.10,0:01:59.68,Default,,0,0,0,,如果你能提前知道\NSo, if you know in advance that
Dialogue: 0,0:01:59.68,0:02:04.22,Default,,0,0,0,,为了安装某个软件更新 你想在今晚重启主节点\Nyou want to reboot the leader tonight in order to install some software updates,
Dialogue: 0,0:02:04.92,0:02:08.14,Default,,0,0,0,,那在安装软件更新之前\Nthen you just move the leader role to a different node
Dialogue: 0,0:02:08.14,0:02:09.92,Default,,0,0,0,,你只需要把主节点角色赋予给另一个节点\Nbefore you install the software updates,
Dialogue: 0,0:02:09.92,0:02:14.56,Default,,0,0,0,,随后 你就可以在不出现任何问题的情况下平稳地取下主节点了\Nand then, you can take it down in peace and quiet, and no problems at all.
Dialogue: 0,0:02:14.56,0:02:17.96,Default,,0,0,0,,不幸的是 这种方法在有些情况下是不可行的\NUnfortunately, this doesn't really help you in the case
Dialogue: 0,0:02:17.96,0:02:20.42,Default,,0,0,0,,例如主节点出现非预期内的崩溃\Nwhere the leader crashes unexpectedly,
Dialogue: 0,0:02:20.42,0:02:25.64,Default,,0,0,0,,或者如果主节点突然遇到硬件故障而停止工作\Nor if the leader suddenly develops a hardware fault and suddenly just stops working.
Dialogue: 0,0:02:25.64,0:02:29.30,Default,,0,0,0,,计算机有时候的确会出现这种情况 有时候确实会停止工作\NAnd computers do that sometimes. They do sometimes just stop working.
Dialogue: 0,0:02:29.30,0:02:32.42,Default,,0,0,0,,有时 计算机可能会在最不方便的时间停止工作\NIn that case, it'll probably stop working at the most inconvenient time,
Dialogue: 0,0:02:32.42,0:02:33.98,Default,,0,0,0,,例如凌晨3点停止工作\Nso, like 3:00 in the morning.
Dialogue: 0,0:02:33.98,0:02:36.46,Default,,0,0,0,,此时 有些人就会接到一个电话\NAnd so, somebody then has to get phoned,
Dialogue: 0,0:02:36.46,0:02:40.16,Default,,0,0,0,,他们得从床上爬起来 登录到计算机上\Nand they have to get out of bed and log into their computer,
Dialogue: 0,0:02:40.16,0:02:43.38,Default,,0,0,0,,为系统重新配置一个新的主节点\Nand reconfigure the system to use a new leader and so on.
Dialogue: 0,0:02:43.38,0:02:45.04,Default,,0,0,0,,这也是可行的\NAnd so, this is possible,
Dialogue: 0,0:02:45.04,0:02:49.38,Default,,0,0,0,,一些数据库系统就是通过这种方式实现的复制\Nand some database systems do implement replication in this way.
Dialogue: 0,0:02:49.38,0:02:54.84,Default,,0,0,0,,但这就引出了一个问题：我们能否以某种方式自动交接主节点\NBut it does beg the question can we somehow do this leader transition automatically
Dialogue: 0,0:02:54.84,0:02:58.52,Default,,0,0,0,,这样我们就不用在凌晨3点把人叫起来了\Nso that we don't have to wake people up at 3:00 o'clock in the morning.
Dialogue: 0,0:02:59.60,0:03:07.48,Default,,0,0,0,,这种主节点交接方法正是共识算法要做的事情\NAnd this transition to a new leader is exactly what consensus algorithms are all about.
Dialogue: 0,0:03:07.48,0:03:13.32,Default,,0,0,0,,共识和全序关系广播是两个不同的问题\NSo, consensus and total order broadcast are two different problems,
Dialogue: 0,0:03:13.32,0:03:16.82,Default,,0,0,0,,但他们实际上是密切相关的 我这就来解释一下\Nbut they're actually quite closely related as I'll explain now.
Dialogue: 0,0:03:16.82,0:03:22.08,Default,,0,0,0,,在分布式系统中 传统的共识定义是\NSo, the traditional way in which consensus is formulated in distributed systems is that
Dialogue: 0,0:03:22.08,0:03:26.32,Default,,0,0,0,,你有多个节点 每个节点可以提出一个值\Nyou've got multiple nodes, each node may propose a value,
Dialogue: 0,0:03:26.32,0:03:30.30,Default,,0,0,0,,你希望所有节点决定出一个相同的值\Nand you want all of the nodes to decide on the same value.
Dialogue: 0,0:03:30.30,0:03:34.52,Default,,0,0,0,,这就好像一些朋友要决定今天去哪里吃午饭\NSo, think of it as like several friends deciding where to go for lunch today,
Dialogue: 0,0:03:34.52,0:03:39.40,Default,,0,0,0,,朋友们推荐了不同的餐馆或购物中心\Nand like they propose different restaurants or shops to go to,
Dialogue: 0,0:03:39.40,0:03:45.46,Default,,0,0,0,,随后 朋友们应用某种处理方法选出了一个提议\Nand then, by some kind of process, one of those proposals is going to get picked,
Dialogue: 0,0:03:45.46,0:03:48.84,Default,,0,0,0,,所有人都会前往同一个购物中心或餐馆去就餐\Nand then, everybody is going to go to the same shop or restaurant for lunch.
Dialogue: 0,0:03:48.84,0:03:52.64,Default,,0,0,0,,这就是共识问题\NAnd so, this is the consensus problem.
Dialogue: 0,0:03:53.20,0:03:58.02,Default,,0,0,0,,我们希望节点能够对提出的一个值达成一致\NWe want the nodes to agree on one of the values that was proposed.
Dialogue: 0,0:03:58.02,0:04:02.14,Default,,0,0,0,,你可以认为这个过程与全序关系广播是等价的\NNow, you can think of this as being equivalent to total order broadcast,
Dialogue: 0,0:04:02.14,0:04:05.02,Default,,0,0,0,,因为在全序关系广播中\Nbecause in total order broadcast, what happens is
Dialogue: 0,0:04:05.02,0:04:09.60,Default,,0,0,0,,我们希望所有节点按照相同的顺序传递相同的消息\Nwe want all of the nodes to deliver the same messages in the same order.
Dialogue: 0,0:04:09.60,0:04:13.42,Default,,0,0,0,,所有节点需要达成一致的是\NAnd so, this agreement that the nodes need to come to
Dialogue: 0,0:04:13.42,0:04:17.74,Default,,0,0,0,,根据全序关系 下一个要传递的消息是什么\Nis the agreement on what is the next message to deliver in this total order.
Dialogue: 0,0:04:17.74,0:04:22.52,Default,,0,0,0,,你可以对需要传递的每条消息都执行一次共识\NAnd so, you can keep doing consensus once for each message that needs to be delivered.
Dialogue: 0,0:04:22.52,0:04:28.08,Default,,0,0,0,,共识将保证所有节点将做出相同的决定\NAnd the consensus will guarantee that all of the nodes will make the same decision.
Dialogue: 0,0:04:28.08,0:04:32.20,Default,,0,0,0,,在某一个时刻 一个节点决定好了特定的值\NAnd so, at some point, a node decides on a certain value,
Dialogue: 0,0:04:32.20,0:04:36.42,Default,,0,0,0,,这相当于在全序关系广播中 此节点传递了这条消息\Nwhich means in total order broadcast terms, it delivers that message.
Dialogue: 0,0:04:36.42,0:04:39.98,Default,,0,0,0,,共识保证一旦决定好了特定的值\NAnd consensus guarantees that once the value has been decided,
Dialogue: 0,0:04:39.98,0:04:42.14,Default,,0,0,0,,大家就不会再改变注意了\Nit's not going to change its mind about it.
Dialogue: 0,0:04:42.14,0:04:46.96,Default,,0,0,0,,在全序关系广播中 这意味着一旦传递了一条消息\NAnd so, for total order broadcast, this means now once a message has been delivered,
Dialogue: 0,0:04:46.96,0:04:50.56,Default,,0,0,0,,那么这就是这一时刻根据全序关系应该传递的消息\Nit has been delivered at a certain point in this total order.
Dialogue: 0,0:04:51.78,0:04:56.06,Default,,0,0,0,,因此 共识问题和全序关系广播\NAnd so, for this reason, the consensus problem and total order broadcast
Dialogue: 0,0:04:56.06,0:04:57.90,Default,,0,0,0,,在形式上是等价的\Nare actually formally equivalent to each other,
Dialogue: 0,0:04:57.90,0:05:00.12,Default,,0,0,0,,这意味着如果你得到了其中一个问题的算法\Nwhich means that if you have an algorithm for one,
Dialogue: 0,0:05:00.12,0:05:04.66,Default,,0,0,0,,你就可以将这个算法转换成另一个问题的算法 反过来也一样\Nthen you can convert it into an algorithm for the other and vice versa.
Dialogue: 0,0:05:04.66,0:05:09.10,Default,,0,0,0,,经典的共识算法叫Paxos\NNow, the classic consensus algorithm is called Paxos.
Dialogue: 0,0:05:09.94,0:05:15.12,Default,,0,0,0,,Paxos所做的实际上只是对单一值达成共识\NAnd what Paxos does actually is only consensus on a single value.
Dialogue: 0,0:05:15.12,0:05:19.36,Default,,0,0,0,,但可以把Paxos扩展为Multi-Paxos\NBut there's an extension to Paxos called Multi-Paxos,
Dialogue: 0,0:05:19.36,0:05:21.32,Default,,0,0,0,,应用Multi-Paxos可以实现全域关系广播\Nwhich actually provides total order broadcasts.
Dialogue: 0,0:05:21.32,0:05:25.00,Default,,0,0,0,,Multi-Paxos可以对值序列达成一致\NSo, that provides agreement on the sequence of values,
Dialogue: 0,0:05:25.00,0:05:27.92,Default,,0,0,0,,因此可以用来决定消息的传递顺序\Ni.e., a sequence of messages to be delivered.
Dialogue: 0,0:05:27.92,0:05:31.10,Default,,0,0,0,,还有很多其他的共识算法\NAnd there are a whole bunch of other consensus algorithms
Dialogue: 0,0:05:31.10,0:05:33.46,Default,,0,0,0,,包括Raft、视图戳复制（Viewstamped Replication）\Nincluding Raft, Viewstamped Replication,
Dialogue: 0,0:05:33.46,0:05:37.80,Default,,0,0,0,,以及Zab 即ZooKeeper原子广播（ZooKeeper atomic broadcast）\Nand ZooKeeper atomic broadcast, Zab.
Dialogue: 0,0:05:37.80,0:05:42.16,Default,,0,0,0,,可以用上述这些共识算法设计出开箱即用的全序关系广播\NAnd they are actually designed to provide total order broadcast right out of the box.
Dialogue: 0,0:05:42.16,0:05:45.92,Default,,0,0,0,,在这节课中 我们将较为详细地介绍Raft\NSo, in this lecture, we're going to look at Raft in a more detailed way,
Dialogue: 0,0:05:45.92,0:05:48.72,Default,,0,0,0,,因为这可能是最容易理解的共识算法了\Nbecause that is perhaps the easiest to understand,
Dialogue: 0,0:05:48.72,0:05:53.02,Default,,0,0,0,,当然 所有这些共识算法都相当复杂、相当精妙\Nalthough all of these algorithms are rather complicated and rather subtle.
Dialogue: 0,0:05:55.64,0:05:59.44,Default,,0,0,0,,大家还记得 我们在第2节课讨论了不同的系统模型\NNow, remember from lecture 2, we talked about different system models.
Dialogue: 0,0:05:59.44,0:06:03.44,Default,,0,0,0,,当我们讨论共识算法时 系统模型起到了非常重要的作用\NAnd this becomes very important now when we are talking about consensus.
Dialogue: 0,0:06:03.44,0:06:07.30,Default,,0,0,0,,大家还记得 当我们讨论节点行为时\NSo, remember that when we were talking about node behavior, for example,
Dialogue: 0,0:06:07.30,0:06:11.06,Default,,0,0,0,,我们可以选择崩溃停止模型、崩溃恢复模型\Nwe could choose between do we want crash-stop, or crash-recovery,
Dialogue: 0,0:06:11.06,0:06:16.40,Default,,0,0,0,,或者节点可以任意执行恶意行为的拜占庭模型\Nor Byzantine, in which case nodes can behave arbitrarily maliciously.
Dialogue: 0,0:06:17.24,0:06:22.78,Default,,0,0,0,,在网络模型方面 我们可以选择公平丢包链路\NIn terms of network, do we want to assume fair-loss, for example.
Dialogue: 0,0:06:22.78,0:06:26.72,Default,,0,0,0,,在同步时间方面 我们可以假设\NAnd in terms of synchrony timing, are we going to assume
Dialogue: 0,0:06:26.72,0:06:33.06,Default,,0,0,0,,异步系统、部分同步系统、或同步系统\Nan asynchronous system, or a partially synchronous system, or a synchronous system.
Dialogue: 0,0:06:33.06,0:06:38.22,Default,,0,0,0,,Paxos、Raft、以及所有流行的共识算法\NAnd what Paxos and Raft and all these popular consensus algorithms do is
Dialogue: 0,0:06:38.22,0:06:42.94,Default,,0,0,0,,都选择了部分同步、崩溃恢复系统模型\Nthey choose a partially synchronous, crash-recovery system model.
Dialogue: 0,0:06:43.66,0:06:47.76,Default,,0,0,0,,你可能会问 为什么会选择这样的系统模型\NAnd you might wonder like why particular these choices.
Dialogue: 0,0:06:47.76,0:06:51.92,Default,,0,0,0,,同步性是一个非常重要的问题\NSo, in particular, the question of synchrony is an important one,
Dialogue: 0,0:06:52.42,0:06:57.88,Default,,0,0,0,,因为我们说过 完全同步模型是不现实的\Nbecause we've said that a fully synchronous model is unrealistic,
Dialogue: 0,0:06:57.88,0:07:01.30,Default,,0,0,0,,因为实际系统总会出现网络延迟\Nbecause in real systems, you do get network delays,
Dialogue: 0,0:07:01.30,0:07:04.68,Default,,0,0,0,,不同时间点会出现不同的延迟情况\Nand you do get various delays that happen at various points.
Dialogue: 0,0:07:04.68,0:07:06.08,Default,,0,0,0,,当通过网络发送消息时\NAnd so, we can't rely on
Dialogue: 0,0:07:06.08,0:07:10.06,Default,,0,0,0,,我们所设计的协议不能要求网络存在延迟上界\Nany upper bound of message latency when sending over the network.
Dialogue: 0,0:07:10.06,0:07:13.42,Default,,0,0,0,,我们能期望的最好结果是部分同步模型\NSo, the best we can hope for really is partially synchronous,
Dialogue: 0,0:07:13.42,0:07:16.46,Default,,0,0,0,,即大多数情况下 网络表现良好\Nwhere most of the time, the network is well behaved,
Dialogue: 0,0:07:16.46,0:07:20.58,Default,,0,0,0,,但偶尔也会出现消息长时延的情况\Nbut occasionally, it has periods where messages are delayed for a long time,
Dialogue: 0,0:07:20.58,0:07:24.80,Default,,0,0,0,,或者出现节点在较长时间内暂停执行的情况\Nor nodes pause their execution for a long time.
Dialogue: 0,0:07:24.80,0:07:28.88,Default,,0,0,0,,理想情况下 我们甚至希望共识算法可以在异步系统中工作\NNow, ideally, we would want consensus to even work in an asynchronous system,
Dialogue: 0,0:07:28.88,0:07:31.70,Default,,0,0,0,,这样我们就不需要设置任何时间假设了\Nwhere we make no timing assumptions at all.
Dialogue: 0,0:07:31.70,0:07:33.84,Default,,0,0,0,,但事实证明 这是不可能做到的\NBut it turns out that this is actually impossible.
Dialogue: 0,0:07:33.84,0:07:39.98,Default,,0,0,0,,有一个叫做FLP结果的不可能性证明 此结果证明了\NSo, there is an impossibility proof which is called the FLP result, which proves that
Dialogue: 0,0:07:39.98,0:07:48.92,Default,,0,0,0,,不可能在异步系统下实现一个共识算法\Nit is not possible to implement a consensus algorithm in an asynchronous system
Dialogue: 0,0:07:49.70,0:07:52.52,Default,,0,0,0,,且要求此算法总能够终止\Nin such a way that this algorithm will always terminate.
Dialogue: 0,0:07:52.52,0:07:58.78,Default,,0,0,0,,如果你有一个异步系统 即使你只假设存在崩溃停止节点\NSo, if you have an asynchronous system, and even if you only allow crash-stop failures,
Dialogue: 0,0:07:58.78,0:08:01.58,Default,,0,0,0,,甚至假设不存在任何复杂的节点故障情况\Nso, even not any of the more complex failures,
Dialogue: 0,0:08:02.58,0:08:07.88,Default,,0,0,0,,共识算法中总会因一部分执行过程\Nthen there will always be some executions of the consensus algorithm
Dialogue: 0,0:08:07.88,0:08:10.68,Default,,0,0,0,,导致算法无法终止\Nin which the algorithm doesn't terminate.
Dialogue: 0,0:08:10.68,0:08:13.12,Default,,0,0,0,,如果你希望算法可以终止\NAnd so, if you want termination, that is,
Dialogue: 0,0:08:13.12,0:08:16.84,Default,,0,0,0,,也就是说 如果你希望算法可以进行处理并总能做出最终决定\Nif you want the algorithm to make progress and eventually decide on something,
Dialogue: 0,0:08:16.84,0:08:20.22,Default,,0,0,0,,或者说你希望全序关系广播总能传递一条消息\Nor for total order broadcast to eventually deliver a message,
Dialogue: 0,0:08:20.22,0:08:23.72,Default,,0,0,0,,那么我们就必须设置时间假设\Nthen we have to make these timing assumptions.
Dialogue: 0,0:08:23.72,0:08:26.90,Default,,0,0,0,,我们必须至少假设是部分同步系统模型\NSo, we have to assume at least partial synchrony,
Dialogue: 0,0:08:26.90,0:08:31.20,Default,,0,0,0,,这意味着我们需要设置超时时钟并处理超时情况\Nwhich means in effect that we use clocks for timeouts,
Dialogue: 0,0:08:31.64,0:08:35.24,Default,,0,0,0,,换句话说 我们有一个基于超时的失效检查器\Nor in other words, we have a timeout-based failure detector,
Dialogue: 0,0:08:35.66,0:08:39.68,Default,,0,0,0,,我们用这个失效检查器判断主节点是否失效\Nwhich we use in order to figure out if the leader has failed or not.
Dialogue: 0,0:08:39.68,0:08:41.26,Default,,0,0,0,,很重要的一点是\NNow, importantly,
Dialogue: 0,0:08:41.26,0:08:46.48,Default,,0,0,0,,算法的正确性完全不依赖于时间\Nthe correctness of the algorithm doesn't really depend on the timing at all.
Dialogue: 0,0:08:46.48,0:08:51.72,Default,,0,0,0,,即使系统的时间变得非常怪异\NSo, even if the timing in the system goes really bizarre,
Dialogue: 0,0:08:51.72,0:08:54.26,Default,,0,0,0,,共识算法也可以保证\Nconsensus algorithm will still guarantee that
Dialogue: 0,0:08:54.26,0:08:57.26,Default,,0,0,0,,消息会按照相同的顺序传递\Nthe same sequence of messages is delivered in the same order.
Dialogue: 0,0:08:57.26,0:09:01.80,Default,,0,0,0,,时间唯一会影响的是节点何时传递消息\NThe only thing that timing affects is when that delivery happens.
Dialogue: 0,0:09:01.80,0:09:07.64,Default,,0,0,0,,因此 如果你的系统会出现很多奇怪的延迟情况\NAnd so, if you have a system in which there are lots of weird delays happening,
Dialogue: 0,0:09:07.64,0:09:14.30,Default,,0,0,0,,则消息传递会被延迟很长一段时间\Nthen it could be that the delivery of the messages is delayed for some amount of time
Dialogue: 0,0:09:14.30,0:09:16.22,Default,,0,0,0,,直到系统自行解决了时延问题\Nuntil the system sorts itself out.
Dialogue: 0,0:09:16.22,0:09:23.64,Default,,0,0,0,,因此 时间确实会影响系统的活性 但不会影响系统的安全性\NSo, the timing does affect the liveness of the system here, but not the safety.
Dialogue: 0,0:09:23.64,0:09:26.86,Default,,0,0,0,,我们有可能\NNow, it is also possible to
Dialogue: 0,0:09:27.08,0:09:30.22,Default,,0,0,0,,进一步弱化崩溃恢复系统假设\Nweaken the assumption about the crash-recovery system model.
Dialogue: 0,0:09:30.22,0:09:34.52,Default,,0,0,0,,我们有可能把假设弱化到拜占庭系统假设\NAnd so, it is actually possible to go all the way down to a Byzantine system model,
Dialogue: 0,0:09:34.52,0:09:37.62,Default,,0,0,0,,我们假设一部分节点可以存在恶意行为\Nwhere we assume that some of the nodes may behave maliciously.
Dialogue: 0,0:09:37.62,0:09:40.62,Default,,0,0,0,,有可能为这类系统构造出共识协议\NAnd it is possible to do consensus in that kind of system.
Dialogue: 0,0:09:41.06,0:09:45.00,Default,,0,0,0,,这类拜占庭容错共识协议\NAnd these types of Byzantine fault-tolerant consensus algorithms
Dialogue: 0,0:09:45.00,0:09:50.98,Default,,0,0,0,,被应用在密码货币、区块链等相关领域\Nare used in the context of some cryptocurrencies and blockchains and that sort of area.
Dialogue: 0,0:09:51.80,0:09:54.42,Default,,0,0,0,,然而 这些拜占庭容错算法\NHowever, these Byzantine fault-tolerant algorithms
Dialogue: 0,0:09:54.42,0:09:57.92,Default,,0,0,0,,要比崩溃恢复算法复杂得多\Nare rather more complex than the crash-recovery algorithms.
Dialogue: 0,0:09:57.92,0:10:01.08,Default,,0,0,0,,这些算法的效率也低得多\NAnd they are also a lot less efficient.
Dialogue: 0,0:10:01.08,0:10:03.28,Default,,0,0,0,,出于本课程的目的\NAnd so, for the purpose of this course,
Dialogue: 0,0:10:03.28,0:10:08.36,Default,,0,0,0,,我们将目光集中在Raft这个非拜占庭算法上\Nwe're just going to concentrate on Raft, which is a non-Byzantine algorithm.
Dialogue: 0,0:10:08.36,0:10:10.76,Default,,0,0,0,,Raft只假设了崩溃恢复模型\NSo, it just assumes a crash-recovery model.
Dialogue: 0,0:10:11.58,0:10:16.80,Default,,0,0,0,,我们暂且不讨论拜占庭算法\NAnd we will leave the Byzantine algorithms out of scope for now.
Dialogue: 0,0:10:18.20,0:10:23.52,Default,,0,0,0,,我前面提到过 共识算法的关键是选举出一个主节点\NSo, as we said, the key thing that we need of consensus is to elect a leader.
Dialogue: 0,0:10:23.52,0:10:24.86,Default,,0,0,0,,一旦我们有了主节点\NAnd then, once we've got a leader,
Dialogue: 0,0:10:24.86,0:10:29.34,Default,,0,0,0,,此主节点就可以来决定消息的传递顺序\Nthat leader can decide on the order in which the messages should be delivered.
Dialogue: 0,0:10:29.34,0:10:32.64,Default,,0,0,0,,我刚刚提到的所有共识算法\NAnd all of the consensus algorithms I just mentioned
Dialogue: 0,0:10:32.64,0:10:35.80,Default,,0,0,0,,都会让主节点来决定消息的顺序\Ndo actually use a leader in order to sequence the messages.
Dialogue: 0,0:10:35.80,0:10:39.42,Default,,0,0,0,,如何使用主节点、如何选举主节点\NThe details of how exactly they use the leader and how they elect a leader,
Dialogue: 0,0:10:39.42,0:10:41.24,Default,,0,0,0,,是算法与算法之间的差异点\Nthey differ from algorithm to algorithm.
Dialogue: 0,0:10:41.24,0:10:45.08,Default,,0,0,0,,我将主要介绍Raft算法\NSo, I'll be focusing on what Raft does in particular.
Dialogue: 0,0:10:45.08,0:10:49.42,Default,,0,0,0,,我们会使用超时机制\NAnd so, what we have is we use a timeout.
Dialogue: 0,0:10:49.80,0:10:55.00,Default,,0,0,0,,我们使用本地时钟来怀疑主节点是否已失效\NWe use local clocks in order to suspect whether a leader has failed or not.
Dialogue: 0,0:10:55.00,0:10:56.22,Default,,0,0,0,,如果你还记得\NSo, if you remember,
Dialogue: 0,0:10:56.22,0:10:59.72,Default,,0,0,0,,在部分同步系统中 失效检查器的检查结果\Nthe failure detectors that we can have in a partially synchronous system
Dialogue: 0,0:10:59.72,0:11:00.88,Default,,0,0,0,,不一定总是准确的\Nare not always accurate.
Dialogue: 0,0:11:00.88,0:11:05.00,Default,,0,0,0,,可能我们认为一个主节点已经崩溃了\NSo, it could be that we think that a leader has crashed
Dialogue: 0,0:11:05.00,0:11:08.86,Default,,0,0,0,,但实际上 主节点工作正常 只是网络问题\Nwhen in fact, the lead is working just fine, but there's just a network problem
Dialogue: 0,0:11:09.34,0:11:12.18,Default,,0,0,0,,阻止我们与主节点进行通信\Nwhich is stopping us from communicating with the leader.
Dialogue: 0,0:11:12.18,0:11:16.08,Default,,0,0,0,,这就是为什么我说我们只能怀疑主节点崩溃了\NSo, that's why I say we can only have a suspected leader crash.
Dialogue: 0,0:11:16.08,0:11:17.82,Default,,0,0,0,,我们永远无法确定\NWe can never be actually certain
Dialogue: 0,0:11:17.82,0:11:21.36,Default,,0,0,0,,当超时发生时 主节点是不是真的失效了\Nif the timeout happened, that it was in fact a leader failure.
Dialogue: 0,0:11:21.36,0:11:23.40,Default,,0,0,0,,我们希望\NAnd what we want is that
Dialogue: 0,0:11:23.40,0:11:28.40,Default,,0,0,0,,共识算法应该阻止系统同时存在两个主节点\Nthe consensus algorithm should prevent having two leaders at the same time,
Dialogue: 0,0:11:28.40,0:11:31.18,Default,,0,0,0,,因为如果我们有两个主节点 它们可能会做出互相矛盾的决定\Nbecause if we have two leaders, they might make contradictory decisions,
Dialogue: 0,0:11:31.18,0:11:34.18,Default,,0,0,0,,此时 我们算法要保证的所有性质就都无法得到满足了\Nand then all of our algorithm’s guarantees are off.
Dialogue: 0,0:11:34.18,0:11:36.98,Default,,0,0,0,,系统出现两个不同的主节点\NAnd this situation where you have two different leaders,
Dialogue: 0,0:11:36.98,0:11:39.32,Default,,0,0,0,,它们都相信自己是主节点\Nthey both believe that they're the leader,
Dialogue: 0,0:11:39.32,0:11:40.98,Default,,0,0,0,,这种情况被称为脑裂\Nthis is called split brain.
Dialogue: 0,0:11:40.98,0:11:44.88,Default,,0,0,0,,如果分布式系统发生了脑裂 这可是个非常糟糕的消息\NAnd if this happens in a distributed system, it's usually really bad news,
Dialogue: 0,0:11:44.88,0:11:47.58,Default,,0,0,0,,因为这一般意味着一些数据将会遭到破坏\Nbecause it's probably going to mean that some data is going to get corrupted,
Dialogue: 0,0:11:47.58,0:11:49.48,Default,,0,0,0,,或者意味着你将丢失一些数据\Nor you're going to lose some data.
Dialogue: 0,0:11:49.48,0:11:52.02,Default,,0,0,0,,我们希望避免脑裂情况\NAnd so, we want to avoid split brain.
Dialogue: 0,0:11:52.02,0:11:55.66,Default,,0,0,0,,必须谨慎设计共识算法\NAnd the consensus algorithm has to be designed in a very careful way
Dialogue: 0,0:11:55.66,0:11:57.98,Default,,0,0,0,,使系统不出现脑裂情况\Nso that it doesn't suffer from split brain.
Dialogue: 0,0:11:59.12,0:12:03.44,Default,,0,0,0,,Raft使用任期这一概念来解决脑裂问题\NAnd the way this works in Raft is that we have a concept of a term.
Dialogue: 0,0:12:03.44,0:12:06.84,Default,,0,0,0,,任期就是一个整数变量\NSo, a term is just an integer variable.
Dialogue: 0,0:12:06.84,0:12:10.44,Default,,0,0,0,,每次需要选举主节点时\NAnd every time that there's a leader election,
Dialogue: 0,0:12:10.44,0:12:12.90,Default,,0,0,0,,主节点选举会发生在特定的任期中\Nthat leader election takes place in a certain term.
Dialogue: 0,0:12:12.90,0:12:17.02,Default,,0,0,0,,每次我们启动一个新的主节点选举时 我们都需要递增任期\NAnd every time we start a new leader election, we just increment the term.
Dialogue: 0,0:12:17.02,0:12:22.12,Default,,0,0,0,,Raft提供的主节点选举过程会保证\NAnd the guarantee that the leader election provides in Raft is that
Dialogue: 0,0:12:22.12,0:12:25.56,Default,,0,0,0,,给定任期内 最多只能选举出一个主节点\Nthere will be at most one leader elected in a given term.
Dialogue: 0,0:12:25.56,0:12:29.88,Default,,0,0,0,,主节点选举有可能出现失败情况 一届任期内没有选举出主节点\NIt could be that the leader election fails and that no leader is elected in a term.
Dialogue: 0,0:12:29.88,0:12:34.14,Default,,0,0,0,,但给定任期内 不可能选举出超过一个主节点\NBut there will never be more than one leader in a given term.
Dialogue: 0,0:12:34.14,0:12:37.36,Default,,0,0,0,,Raft确保满足这一性质的方法是\NAnd the way this is ensured in Raft is that
Dialogue: 0,0:12:37.36,0:12:42.72,Default,,0,0,0,,Raft提出了一个规则：每个任期内 只允许一个节点投一票\Nwe have a rule that in each term, a node is only allowed to vote once.
Dialogue: 0,0:12:42.72,0:12:47.38,Default,,0,0,0,,就像在议会选举那样 只允许你投一票\NSo, just like in a parliamentary election, you're only allowed to cast one vote.
Dialogue: 0,0:12:47.38,0:12:52.84,Default,,0,0,0,,这里也非常类似 假设我们有一个包含5个节点的系统\NVery similar here, say, if we have a system of 5 nodes,
Dialogue: 0,0:12:52.84,0:12:57.08,Default,,0,0,0,,假设5个中的3个节点要选举出新的主节点\Nand, say, 3-out-of-5 elect a new leader,
Dialogue: 0,0:12:57.08,0:13:00.00,Default,,0,0,0,,A、B、C已经为新节点投票了\NA, B, C have voted in favor of the new leader.
Dialogue: 0,0:13:00.00,0:13:06.48,Default,,0,0,0,,随后 如果C、D和E尝试在相同任期内选举出另一个主节点\NNow, later, if C, D and E try to elect a different leader in the same term,
Dialogue: 0,0:13:06.48,0:13:07.76,Default,,0,0,0,,它们无法完成选举\Nthey will not be able to,
Dialogue: 0,0:13:07.76,0:13:13.12,Default,,0,0,0,,因为C知道自己在这个特定的任期内已经投过票了\Nbecause C knows that C has already voted once in this particular term,
Dialogue: 0,0:13:13.12,0:13:18.36,Default,,0,0,0,,因此 C无法在相同任期内为另一个不同的候选人投票\Nand therefore, it will not vote again for a different candidate in the same term.
Dialogue: 0,0:13:18.36,0:13:25.50,Default,,0,0,0,,在新任期、新开始、选举新主节点时 每个节点又可以再次投票\NIn a new term, new start, new leader election, so, in that case, every node can vote again.
Dialogue: 0,0:13:25.50,0:13:30.02,Default,,0,0,0,,在共识算法中\NAnd so, what we typically require in a consensus algorithm is that
Dialogue: 0,0:13:30.02,0:13:31.88,Default,,0,0,0,,每当我们想选举一个主节点时\Nevery time we want to elect a leader,
Dialogue: 0,0:13:31.88,0:13:37.86,Default,,0,0,0,,我们需要quorum节点通过投票选举出该特定任期的主节点\Nwe need a quorum of nodes to vote in favor of that leader in that particular term.
Dialogue: 0,0:13:37.86,0:13:42.92,Default,,0,0,0,,举例来说 假设我们有5个节点\NAnd so, in this case, here if we have 5 nodes, for example,
Dialogue: 0,0:13:42.92,0:13:46.16,Default,,0,0,0,,我们要求有3个quorum节点 数量占到总节点数量的多半\Nthen we could have a majority quorum of 3-out-of-5.
Dialogue: 0,0:13:46.16,0:13:49.94,Default,,0,0,0,,5个节点中的任意3个节点都有能力选举出新的主节点\NSo, any 3-out-of-5 nodes are able to elect a new leader,
Dialogue: 0,0:13:49.94,0:13:54.10,Default,,0,0,0,,这意味着系统可以容忍2个节点不可用\Nwhich means that the system can tolerate 2 nodes being unavailable,
Dialogue: 0,0:13:54.10,0:13:56.38,Default,,0,0,0,,此时 5个节点中的剩余3个节点\Nand the remaining 3 nodes out of 5
Dialogue: 0,0:13:56.38,0:13:59.50,Default,,0,0,0,,仍然可以继续前进 在必要时选举出新的主节点\Ncan still make progress and still elect a new leader if necessary.
Dialogue: 0,0:13:59.50,0:14:02.84,Default,,0,0,0,,这是系统可以容错的基本思想\NSo, this is what gives us the fault tolerance.
Dialogue: 0,0:14:02.84,0:14:08.22,Default,,0,0,0,,每个任期只允许节点投一次票的方法\NAnd so, this approach here of allowing a vote only once per term
Dialogue: 0,0:14:08.22,0:14:12.22,Default,,0,0,0,,保证给定任期内只能选举出唯一的一个主节点\Nensures that within a given term, there is a unique leader.
Dialogue: 0,0:14:12.22,0:14:18.66,Default,,0,0,0,,然而 这实际上无法保证系统不会出现多个主节点\NHowever, this does not actually guarantee that we will not have multiple leaders,
Dialogue: 0,0:14:18.66,0:14:20.56,Default,,0,0,0,,因为可能发生的一种情况是\Nbecause what could happen is that
Dialogue: 0,0:14:20.56,0:14:26.54,Default,,0,0,0,,不同任期内存在不同的主节点 但它们互相之间还不知道\Nthere are different nodes that are leaders in different terms and they just don't realize it.
Dialogue: 0,0:14:26.54,0:14:31.66,Default,,0,0,0,,想象这样一个场景 我们有3个节点：节点1、节点2和节点3\NSo, imagine this scenario here, we've got 3 nodes, 1, 2, and 3,
Dialogue: 0,0:14:31.66,0:14:36.54,Default,,0,0,0,,假设节点1在任期t被选举成为主节点\Nand say that node 1 was elected to be the leader in term t.
Dialogue: 0,0:14:36.54,0:14:39.14,Default,,0,0,0,,但随后出现了网络问题\NBut then, a network problem happens,
Dialogue: 0,0:14:39.14,0:14:42.48,Default,,0,0,0,,节点1无法与节点2和节点3通信\Nand node 1 is no longer able to communicate with nodes 2 and 3.
Dialogue: 0,0:14:42.48,0:14:45.48,Default,,0,0,0,,节点1仍然活着 节点1仍然是主节点\NNode 1 is still alive. Node 1 is still a leader.
Dialogue: 0,0:14:45.48,0:14:49.06,Default,,0,0,0,,但现在 节点2和节点3无法收到主节点发来的任何消息了\NBut now, node 2 and 3 don't hear anything from their leader anymore.
Dialogue: 0,0:14:49.06,0:14:51.50,Default,,0,0,0,,在某一时刻 节点2和节点3说\NAnd so, at some point, node 2 and 3 are going to say
Dialogue: 0,0:14:51.50,0:14:56.74,Default,,0,0,0,,“好像我们的主节点不在了 我们需要在新任期内选举出一个新的主节点”\N“Well, probably our leader is dead. So, we're going to elect a new leader in a new term.”
Dialogue: 0,0:14:56.74,0:15:01.54,Default,,0,0,0,,在任期t+1内 节点2和节点3将在它们之间选举出一个新的主节点\NSo, call a term t+1, node 2 and 3 are going to elect a new leader among themselves.
Dialogue: 0,0:15:01.54,0:15:04.34,Default,,0,0,0,,举例来说 节点2成为了新的主节点\NMaybe node 2 is going to be the new leader, for example.
Dialogue: 0,0:15:04.34,0:15:06.38,Default,,0,0,0,,系统现在实际上出现了两个主节点\NAnd now the system has actually got two leaders.
Dialogue: 0,0:15:06.38,0:15:09.18,Default,,0,0,0,,任期t的主节点是节点1\NIt's got node 1, which is the leader in term t,
Dialogue: 0,0:15:09.18,0:15:13.04,Default,,0,0,0,,任期t+1的主节点是节点2\Nand node 2, which is the leader in term t+1.
Dialogue: 0,0:15:13.04,0:15:15.96,Default,,0,0,0,,这看起来像是发生了脑裂 对吧？\NAnd this looks like split brain, doesn't it?
Dialogue: 0,0:15:15.96,0:15:19.80,Default,,0,0,0,,我们有了两个主节点 这太糟糕了 我们不希望发生这样的情况\NSo, we've got two leaders. This is bad. We want to not be in the situation.
Dialogue: 0,0:15:19.80,0:15:23.38,Default,,0,0,0,,但不幸的是 因为出现了网络问题\NBut unfortunately, because the network is interrupted,
Dialogue: 0,0:15:23.38,0:15:26.92,Default,,0,0,0,,节点1无法通过任何方法知道\Nthere is no way for node 1 to know that
Dialogue: 0,0:15:27.36,0:15:30.64,Default,,0,0,0,,它不再是主节点了 它已经被取代了\Nit is no longer the leader, that has been superseded,
Dialogue: 0,0:15:30.64,0:15:33.68,Default,,0,0,0,,因为涉及节点1的所有消息都无法被成功传输\Nbecause the communication simply isn't getting through.
Dialogue: 0,0:15:33.68,0:15:37.90,Default,,0,0,0,,因此 我们需要处理\NAnd so, therefore, we need to actually deal with this possibility
Dialogue: 0,0:15:37.90,0:15:43.98,Default,,0,0,0,,系统在不同任期内同时出现不同主节点的这种可能性\Nthere are different leaders existing in the system at the same time in different terms.
Dialogue: 0,0:15:44.40,0:15:48.12,Default,,0,0,0,,否则 这些主节点可能会在一段时间内做出互相矛盾的决定\NAnd those leaders may for a little while make contradictory decisions.
Dialogue: 0,0:15:48.12,0:15:52.74,Default,,0,0,0,,然而 即使我们有多个主节点 我们也必须要保证\NAnd we have to nevertheless ensure that we have total order broadcast
Dialogue: 0,0:15:52.74,0:16:00.14,Default,,0,0,0,,我们的全序关系广播不能违反其本该具有的性质\Nthat we don't violate our properties even though we might have multiple leaders.
Dialogue: 0,0:16:00.14,0:16:04.72,Default,,0,0,0,,共识算法解决此问题的方法是\NAnd the way that consensus algorithms do this is that
Dialogue: 0,0:16:04.72,0:16:08.42,Default,,0,0,0,,如果一个主节点决定传递一条特定的消息\Nif a leader wants to decide to deliver a certain message, for example,
Dialogue: 0,0:16:08.42,0:16:11.74,Default,,0,0,0,,主节点实际上不能自作主张\Nthe leader cannot actually make that decision by itself,
Dialogue: 0,0:16:11.74,0:16:17.08,Default,,0,0,0,,主节点需要回过头来询问quorum节点\Nbut the leader has to again go and ask a quorum of nodes
Dialogue: 0,0:16:17.08,0:16:20.18,Default,,0,0,0,,是否可以传递这条特定的消息\Nif they are OK to deliver a certain message.
Dialogue: 0,0:16:20.18,0:16:24.52,Default,,0,0,0,,协议通信流如下图所示\NAnd so, what the communication flow looks like is something like this now.
Dialogue: 0,0:16:24.52,0:16:29.38,Default,,0,0,0,,左侧是主节点 右侧是两个从节点\NSay, we have leader on the left and two followers.
Dialogue: 0,0:16:29.38,0:16:34.90,Default,,0,0,0,,首先 位于左侧的左节点被选举成为主节点\NAnd so, first of all, the left node on the left needs to be elected the leader.
Dialogue: 0,0:16:34.90,0:16:39.10,Default,,0,0,0,,它会联系其他节点 并问道：“我可以成为新的主节点吗？”\NAnd so, it's going to contact the others, say, “Are you OK for me to be your new leader?”
Dialogue: 0,0:16:39.10,0:16:41.26,Default,,0,0,0,,其它节点回复“可以”\NAnd then, the others respond “OK”.
Dialogue: 0,0:16:41.26,0:16:44.08,Default,,0,0,0,,这意味着quorum节点投票选择出了新的主节点\NNow, it's got a quorum of votes in favor of being a leader.
Dialogue: 0,0:16:44.08,0:16:47.98,Default,,0,0,0,,经过一轮选举 左侧节点成为了主节点\NSo now, the node on the left is the leader after one round of election.
Dialogue: 0,0:16:47.98,0:16:51.86,Default,,0,0,0,,现在 主节点想要传递一条消息\NNow, the leader wants to deliver a message.
Dialogue: 0,0:16:51.86,0:16:52.70,Default,,0,0,0,,但我前面说过\NBut as I said,
Dialogue: 0,0:16:52.70,0:16:59.80,Default,,0,0,0,,主节点不能自作主张 直接传递这条消息\Nthe leader cannot just make that decision by itself to simply deliver a message.
Dialogue: 0,0:16:59.80,0:17:03.50,Default,,0,0,0,,主节点必须再次联系从节点 并问道：\NBut instead, the leader has to go to the followers again and say,
Dialogue: 0,0:17:03.50,0:17:09.94,Default,,0,0,0,,“是否可以在任期t内把消息m作为下一个要传递的消息？”\N“Are you OK to deliver message m in term t as the next message?”
Dialogue: 0,0:17:09.94,0:17:14.34,Default,,0,0,0,,从节点组成的quorum节点再次回复称：\NAnd only if a quorum of followers again responds here and say,
Dialogue: 0,0:17:14.34,0:17:17.36,Default,,0,0,0,,“好的 可以在任期t传递消息m”\N“OK, yes, we're OK with this message m in term t.”
Dialogue: 0,0:17:17.36,0:17:20.10,Default,,0,0,0,,只有当从节点没有听到其他主节点在任期t+1发出的消息时\NAnd the followers will only respond positively
Dialogue: 0,0:17:20.10,0:17:24.42,Default,,0,0,0,,从节点才会给出正面回复\Nif they haven't heard of any other leader in term t+1.
Dialogue: 0,0:17:24.42,0:17:30.62,Default,,0,0,0,,现在 主节点再次得到了quorum节点的正面回复\NSo now, the leader again gets this quorum of positive responses.
Dialogue: 0,0:17:30.62,0:17:34.84,Default,,0,0,0,,现在 主节点可以放心地决定传递消息m\NNow, the leader can safely make the decision to deliver m.
Dialogue: 0,0:17:34.84,0:17:36.98,Default,,0,0,0,,它可以告诉其他节点称：\NAnd it can tell the other nodes that,
Dialogue: 0,0:17:36.98,0:17:41.60,Default,,0,0,0,,“好的 在我们的全序关系广播中 下一个要传递的消息是m”\N“OK, m is now the next message to be delivered in our total order broadcast.”
Dialogue: 0,0:17:41.60,0:17:48.04,Default,,0,0,0,,这就是共识的基本原则 协议实际上包含两个投票阶段\NSo, this is the principle that we have effectively two phases of voting.
Dialogue: 0,0:17:48.04,0:17:53.34,Default,,0,0,0,,第一个阶段 由部分节点组成的quorum节点要投票选举出主节点\NFirst of all, a node needs to get elected leader by a quorum of nodes.
Dialogue: 0,0:17:53.34,0:17:55.34,Default,,0,0,0,,第二个阶段\NAnd then a second round happens
Dialogue: 0,0:17:55.34,0:18:01.70,Default,,0,0,0,,主节点检查是否可以决定下一个传递的消息\Nin which the leader checks if it's OK to decide on a certain message next.
Dialogue: 0,0:18:01.70,0:18:04.38,Default,,0,0,0,,我们提到的所有共识协议\NAnd this is actually the underlying principle of
Dialogue: 0,0:18:04.38,0:18:06.98,Default,,0,0,0,,都满足这一基本原则\Nall of the consensus algorithms that we've seen.
Dialogue: 0,0:18:06.98,0:18:09.20,Default,,0,0,0,,我们将在下一小节详细介绍\NAnd in the next section, we will look in detail
Dialogue: 0,0:18:09.20,0:18:12.36,Default,,0,0,0,,Raft实现这一系统的具体方法\Nat how Raft implements this particular system.
