[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 2.4_Fault tolerance.mp4
Video File: 2.4_Fault tolerance.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.250000
Scroll Position: 27
Active Line: 28
Video Position: 3075

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:00.00,0:00:03.26,Default,,0,0,0,,我想在本节课的最后一部分和大家讨论\NIn the last bit of this lecture, I want to talk a little bit about
Dialogue: 0,0:00:03.26,0:00:09.78,Default,,0,0,0,,现实中处理故障、构建高可用服务时所面临的问题\Na practical real-life context for handling faults and making highly available services.
Dialogue: 0,0:00:09.78,0:00:13.20,Default,,0,0,0,,举例来说 假设你在运行一个在线商店\NSo, imagine you are running an online shop, for example,
Dialogue: 0,0:00:13.20,0:00:18.12,Default,,0,0,0,,你可能希望商店每周7天、每天24小时都在线\Nyou probably want that shop to be available 24 hours a day, 7 days a week,
Dialogue: 0,0:00:18.12,0:00:20.50,Default,,0,0,0,,谁知道白天或者晚上\Nbecause who knows at what time of day or night
Dialogue: 0,0:00:20.50,0:00:23.48,Default,,0,0,0,,会不会有人要看看你的在线商店\Nsomebody might decide that they want to go and look at your shop
Dialogue: 0,0:00:23.48,0:00:24.54,Default,,0,0,0,,买点东西呢\Nand maybe buy something.
Dialogue: 0,0:00:24.54,0:00:29.08,Default,,0,0,0,,你的商店或服务如果在某些时刻不可用\NAnd so, any time during which your shop, your service is not available
Dialogue: 0,0:00:29.08,0:00:30.78,Default,,0,0,0,,那就会面临收入损失\Nactually means losing money.
Dialogue: 0,0:00:31.08,0:00:32.96,Default,,0,0,0,,再想象另一个场景\NIn other cases, you might imagine that
Dialogue: 0,0:00:32.96,0:00:38.52,Default,,0,0,0,,你的服务甚至可能与客户签订了合同\Na service may even have contractual relationships with its customers
Dialogue: 0,0:00:38.52,0:00:42.58,Default,,0,0,0,,合同要求你的服务要在多大比例的时间内保证可用性\Nspecifying what percentage of time a service needs to be available.
Dialogue: 0,0:00:42.58,0:00:48.14,Default,,0,0,0,,当我们讨论可用性时 一个典型的模型指标是\NAnd so, a typical model for how we usually talk about availability is
Dialogue: 0,0:00:48.14,0:00:52.78,Default,,0,0,0,,服务可以正确提供功能的时间占比\Nthe fraction of time during which a service is functioning correctly.
Dialogue: 0,0:00:52.78,0:00:57.48,Default,,0,0,0,,举个例子 如果一个服务可以在99%的时间内正确提供功能\NAnd so, if a service is functioning correctly 99% of the time, for example,
Dialogue: 0,0:00:57.48,0:01:00.92,Default,,0,0,0,,这意味着每年服务的不可用时间\Nthat means that there might be 3 to 4 days a year
Dialogue: 0,0:01:00.92,0:01:03.78,Default,,0,0,0,,总计差不多有3到4天\Nduring which the service is not available, in total.
Dialogue: 0,0:01:03.78,0:01:06.46,Default,,0,0,0,,当然了 服务不可用时间的占比还是比较小的\NOf course, this might be several smaller outages.
Dialogue: 0,0:01:06.46,0:01:10.40,Default,,0,0,0,,如果你把此指标提高到99.9%\NOr if you go up to 99.9% of the time,
Dialogue: 0,0:01:10.40,0:01:14.24,Default,,0,0,0,,则每年服务不可用时间最多不超过9小时\Nyou're allowed a maximum of 9 hours per year of outage.
Dialogue: 0,0:01:14.24,0:01:18.12,Default,,0,0,0,,你可以继续增加9的个数 进一步提高服务的可用性保证\NAnd you can increase this further to as many nines as you like.
Dialogue: 0,0:01:19.02,0:01:24.26,Default,,0,0,0,,例如 电话网络一般会提供5个9的可用性保证\NSo, the telephone network, for example, is apparently designed for 5 nines.
Dialogue: 0,0:01:24.26,0:01:30.20,Default,,0,0,0,,这个可用性保证指的是老式固定电话网络 不是移动网络\NAnd so, this is the old-fashioned fixed-line telephone network, not mobile networks.
Dialogue: 0,0:01:30.20,0:01:33.92,Default,,0,0,0,,当然也不是指互联网 互联网无法提供如此高的可用性保证\NCertainly not the Internet, they don't have this sort of availability.
Dialogue: 0,0:01:34.40,0:01:37.54,Default,,0,0,0,,电话网络使用了非常保守的设计方法\NThe telephone network is designed in a very conservative way
Dialogue: 0,0:01:37.54,0:01:40.94,Default,,0,0,0,,这才使电话网络可以达到如此高的可靠性\Nin order to achieve this very high reliability.
Dialogue: 0,0:01:40.94,0:01:42.50,Default,,0,0,0,,但高可用性确实是可实现的\NBut it is possible.
Dialogue: 0,0:01:42.50,0:01:49.62,Default,,0,0,0,,我们一般还会使用SLO和SLA来定义可用性\NAnd typically, terms that you get in the context of availability is SLO and SLA.
Dialogue: 0,0:01:49.62,0:01:52.40,Default,,0,0,0,,SLO的意思是服务水平目标\NSo, SLO is Service-Level Objective.
Dialogue: 0,0:01:52.40,0:01:57.56,Default,,0,0,0,,目标是要求你对服务提供具体指标下的可用性保证\NIt is the goal that you are setting yourself in terms of the availability of a service.
Dialogue: 0,0:01:57.56,0:02:03.54,Default,,0,0,0,,一般是指请求得到正确响应的比例\NSo, this might specify the percentage of requests that need to get a correct response,
Dialogue: 0,0:02:04.48,0:02:08.86,Default,,0,0,0,,得到正确响应所需的最大响应时间\Nwhere the maximum time that it's allowed to take for that response,
Dialogue: 0,0:02:08.86,0:02:11.26,Default,,0,0,0,,例如最大响应时间为200毫秒等\Nsay 200 milliseconds or whatever,
Dialogue: 0,0:02:11.26,0:02:13.84,Default,,0,0,0,,以及在多长时间周期内要保证上述响应指标\Nand the period of time over which you're going to measure it.
Dialogue: 0,0:02:13.84,0:02:15.14,Default,,0,0,0,,举例来说 你可以将SLO设置为\NSo, you're going to take that
Dialogue: 0,0:02:15.14,0:02:20.58,Default,,0,0,0,,每天可以正确回复99.9%的请求\N99.9% over the cause of all of the requests made in one day, for example.
Dialogue: 0,0:02:20.58,0:02:23.24,Default,,0,0,0,,SLA一般出现在\NAnd then, SLA is basically a contract
Dialogue: 0,0:02:23.24,0:02:26.72,Default,,0,0,0,,服务方与客户或消费者签订的合同中\Nbetween a service and its customers or its consumers,
Dialogue: 0,0:02:27.16,0:02:32.04,Default,,0,0,0,,以明确期望达到的服务水平是什么\Nspecifying what the expected service level is.
Dialogue: 0,0:02:32.04,0:02:37.02,Default,,0,0,0,,在分布式系统中 我们一般要构建容错机制\NNow, in order to achieve that sort of very high availability,
Dialogue: 0,0:02:37.02,0:02:41.58,Default,,0,0,0,,以保证系统满足所需的高可用性\Nthe way we typically do that in distributed systems is by fault tolerance.
Dialogue: 0,0:02:41.58,0:02:45.46,Default,,0,0,0,,故障是指系统的一部分无法工作\NSo, a fault is when some part of the system isn't working.
Dialogue: 0,0:02:45.46,0:02:49.00,Default,,0,0,0,,我们这里讨论的节点故障 包含节点本身的崩溃情况\NWe talked about node faults, which might be a crash, for example,
Dialogue: 0,0:02:49.00,0:02:51.68,Default,,0,0,0,,也包含网络故障 例如出现了网络分区\Nor network faults, which might be a network partition.
Dialogue: 0,0:02:51.68,0:02:56.90,Default,,0,0,0,,我们希望系统能够容忍一定数量的故障\NAnd what we want is the system to tolerate some number of faults.
Dialogue: 0,0:02:56.90,0:03:01.58,Default,,0,0,0,,让系统容忍所有故障是毫无意义的\NSo, it doesn't make sense to say that the system will tolerate all faults,
Dialogue: 0,0:03:01.58,0:03:04.00,Default,,0,0,0,,因为如果所有节点都在同一时刻崩溃\Nbecause if all of your nodes crash at the same time,
Dialogue: 0,0:03:04.00,0:03:06.60,Default,,0,0,0,,如果所有网络链路都在同一时刻断开\Nand all of your network links go down at the same time,
Dialogue: 0,0:03:06.60,0:03:09.18,Default,,0,0,0,,系统很显然无法做出任何响应\Nthe system is not going to be able to do anything, obliviously.
Dialogue: 0,0:03:09.18,0:03:12.10,Default,,0,0,0,,没有任何方法可以容忍此类故障\NThere's no way it can make any progress in that case.
Dialogue: 0,0:03:12.10,0:03:14.62,Default,,0,0,0,,但可以在一定程度上做到容错\NBut what you might be able to say is that
Dialogue: 0,0:03:14.62,0:03:17.42,Default,,0,0,0,,例如 系统作为整体仍然可以运作的条件是\Nthe system as a whole will continue working
Dialogue: 0,0:03:17.42,0:03:20.92,Default,,0,0,0,,有小于1/2的节点崩溃\Nif fewer than half of our nodes have crashed, for example.
Dialogue: 0,0:03:20.92,0:03:26.16,Default,,0,0,0,,或有小于1/3的节点崩溃 或有小于2/5的节点崩溃\NSo, you allow 1/3 to crash, or you allow 2/5 to crash,
Dialogue: 0,0:03:26.16,0:03:30.08,Default,,0,0,0,,剩余节点仍然可以运作 正常对外提供服务\Nand the remaining nodes can still continue running the service.
Dialogue: 0,0:03:30.08,0:03:38.56,Default,,0,0,0,,当系统中的部分节点或部分网络链路可能出现故障时\NAnd so, in a system in which some nodes or some network links are allowed to be faulty,
Dialogue: 0,0:03:39.18,0:03:41.60,Default,,0,0,0,,我们要避免的是所谓的单点失效\Nwe avoid what is called a single point of failure.
Dialogue: 0,0:03:41.60,0:03:43.08,Default,,0,0,0,,单点失效是指\NSo, a single point of failure would be say
Dialogue: 0,0:03:43.08,0:03:48.60,Default,,0,0,0,,系统中存在一个节点 如果此节点崩溃 则整个系统都不可用\None node that if that one node crashes, then the system as a whole becomes unavailable.
Dialogue: 0,0:03:49.14,0:03:52.32,Default,,0,0,0,,如果我们可以设计一个不会出现单点失效的系统\NBut if we can design a system without a single point of failure,
Dialogue: 0,0:03:52.32,0:03:56.32,Default,,0,0,0,,这意味着我们可以移除系统的任何一部分\Nthat means that we can take out any one component of the system,
Dialogue: 0,0:03:56.32,0:03:59.60,Default,,0,0,0,,而系统作为整体仍然可以运作\Nand the system as a whole will hopefully still continue working.
Dialogue: 0,0:04:01.94,0:04:07.58,Default,,0,0,0,,为了实现容错 我们必须要完成的一项工作是\NIn order to enable to tolerate faults, usually the first thing we have to do is
Dialogue: 0,0:04:07.58,0:04:10.74,Default,,0,0,0,,检查出故障 能检查出故障才能处理故障\Nto detect a fault, and then we can handle it.
Dialogue: 0,0:04:10.74,0:04:16.38,Default,,0,0,0,,检查故障的机制叫做失效检查器\NSo, the mechanism for detecting a fault is known as a failure detector.
Dialogue: 0,0:04:16.38,0:04:18.14,Default,,0,0,0,,这个术语有点奇怪\NTerminology is a little bit odd.
Dialogue: 0,0:04:18.14,0:04:22.20,Default,,0,0,0,,更合理的术语应该是故障检查器\NIt actually should be called a fault detector that would make more sense.
Dialogue: 0,0:04:22.20,0:04:24.84,Default,,0,0,0,,不过失效检查器已经是一个公认的术语了\NBut a failure detector is the common term that is used.
Dialogue: 0,0:04:24.84,0:04:26.14,Default,,0,0,0,,因此 我这里沿用这一术语\NSo, we're going to stick with that.
Dialogue: 0,0:04:26.14,0:04:29.54,Default,,0,0,0,,失效检查器可以是一个软件算法\NSo, a failure detector, it could be like a software algorithm,
Dialogue: 0,0:04:29.54,0:04:31.60,Default,,0,0,0,,也可以是一部分硬件 也可以是其他形式\Nor it could be a piece of hardware or something,
Dialogue: 0,0:04:31.60,0:04:35.44,Default,,0,0,0,,这是一种检查另一个节点是否出现故障的机制\Nsome mechanism for detecting whether another node is faulty.
Dialogue: 0,0:04:35.44,0:04:39.90,Default,,0,0,0,,理想状态下 我们希望得到的是一个完美失效检查器\NAnd ideally, what we would love to have is a perfect failure detector,
Dialogue: 0,0:04:39.90,0:04:43.38,Default,,0,0,0,,也就是说 这个机制可以准确告知我们\Nthat is, some mechanism that is always accurate at telling us
Dialogue: 0,0:04:43.38,0:04:46.26,Default,,0,0,0,,另一个节点是否出现了故障\Nwhether another node is faulty or not.
Dialogue: 0,0:04:46.26,0:04:52.86,Default,,0,0,0,,我们目前一般使用超时机制来实现失效检查器\NNow, the way we typically implement failure detectors is we use timeouts.
Dialogue: 0,0:04:52.86,0:04:55.30,Default,,0,0,0,,我们简单地向节点发送一条消息 消息的内容是\NSo, we simply send a message to a node, and say,
Dialogue: 0,0:04:55.30,0:04:57.88,Default,,0,0,0,,“如果你还活着 请回复这条消息”\N“Hey, please respond to this message if you're alive”.
Dialogue: 0,0:04:57.88,0:05:01.24,Default,,0,0,0,,如果在特定的时间内没有收到任何回复 我们就会说\NAnd then, if we don't get a response within some amount of time, then we say,
Dialogue: 0,0:05:01.24,0:05:04.44,Default,,0,0,0,,“好吧 我没有收到任何回复 那个节点可能已经不在了”\N“Well, OK, we didn't get a response. That node must be dead”.
Dialogue: 0,0:05:04.44,0:05:06.98,Default,,0,0,0,,“那个节点一定是崩溃了 或者发生了其他什么事情”\N“So, it must have crashed or something like that”.
Dialogue: 0,0:05:06.98,0:05:10.34,Default,,0,0,0,,这个机制效果很好 也很实用\NAnd this is fine. This is practical.
Dialogue: 0,0:05:10.34,0:05:15.82,Default,,0,0,0,,但不幸的是 正如我们在系统模型部分见到的那样\NBut unfortunately, as we have seen in the context of our system models,
Dialogue: 0,0:05:15.82,0:05:20.70,Default,,0,0,0,,如果我们假设的是一个部分同步系统 甚至假设的是一个异步系统\Nif we assume a partially synchronous or even an asynchronous system,
Dialogue: 0,0:05:20.70,0:05:25.46,Default,,0,0,0,,则超时并不能准确告诉我们某个节点是否崩溃了\Nthen a timeout doesn't necessarily tell us that the node has crashed,
Dialogue: 0,0:05:25.46,0:05:27.84,Default,,0,0,0,,因为非同步系统自身也可能出现超时的情况\Nbecause then timeout could also happen,
Dialogue: 0,0:05:27.84,0:05:32.20,Default,,0,0,0,,当我们在此类系统中发送一条消息时 此消息可能会在网络中丢失\Nbecause we sent a message, and the message was lost in the network,
Dialogue: 0,0:05:32.20,0:05:34.24,Default,,0,0,0,,响应消息也可能会在网络中丢失\Nor the response was lost in the network,
Dialogue: 0,0:05:34.24,0:05:37.28,Default,,0,0,0,,消息的传输可能会出现网络延迟\Nor the message was delayed in the network,
Dialogue: 0,0:05:37.28,0:05:40.10,Default,,0,0,0,,消息虽然最终仍然能到达目的地 只是一定时间内还没到达\Nand it will actually still arrive, it just hasn't arrived yet,
Dialogue: 0,0:05:40.10,0:05:42.42,Default,,0,0,0,,响应的传输也可能会出现网络延迟\Nor the response was delayed in the network,
Dialogue: 0,0:05:42.42,0:05:45.02,Default,,0,0,0,,节点有可能还活着\Nor maybe the node is actually alive,
Dialogue: 0,0:05:45.02,0:05:47.92,Default,,0,0,0,,但是节点处于暂停状态 正在执行较长时间的垃圾回收\Nbut it's just experiencing a long garbage collection pause,
Dialogue: 0,0:05:47.92,0:05:51.12,Default,,0,0,0,,节点可能需要完成垃圾回收后才能响应消息\Nand so, it will respond to your message in one minute's time
Dialogue: 0,0:05:51.12,0:05:53.72,Default,,0,0,0,,可能需要过一分钟才会响应消息\Nonce it's finished its garbage collection,
Dialogue: 0,0:05:53.72,0:05:55.52,Default,,0,0,0,,当然了 节点也有可能真的崩溃了\Nor of course, the note might have crashed.
Dialogue: 0,0:05:55.52,0:05:58.54,Default,,0,0,0,,节点可能发生上述所有情况 超时机制无法区分出节点具体发生了什么\NAnd it's impossible to tell the difference between any of these.
Dialogue: 0,0:05:58.54,0:06:04.48,Default,,0,0,0,,因此 发送检查消息的发送方不可能获知\NSo, it's impossible for the sender of these check messages to tell
Dialogue: 0,0:06:04.48,0:06:08.58,Default,,0,0,0,,没有收到响应的原因到底是由网络问题导致的\Nwhether the absence of a response is due to a network problem
Dialogue: 0,0:06:08.58,0:06:12.58,Default,,0,0,0,,还是由某种随机延迟导致的\Nor due to just some kind of random delay,
Dialogue: 0,0:06:13.10,0:06:16.42,Default,,0,0,0,,还是真的因为节点已经崩溃才无法收到响应的\Nor due to problems because the node is actually crashed.
Dialogue: 0,0:06:16.42,0:06:20.66,Default,,0,0,0,,我们可以构建出完美失效检查器的条件是\NNow, we can build a perfect failure detector
Dialogue: 0,0:06:20.66,0:06:22.70,Default,,0,0,0,,我们使用同步系统模型\Nif we have a synchronous system model,
Dialogue: 0,0:06:22.70,0:06:26.52,Default,,0,0,0,,且我们只假设存在崩溃停止节点\Nand if we're going to assume only crash-stop failures,
Dialogue: 0,0:06:26.52,0:06:31.92,Default,,0,0,0,,假设系统中的节点不会出现任何拜占庭行为\Nand certainly not going to assume any Byzantine behavior in the system.
Dialogue: 0,0:06:31.92,0:06:36.52,Default,,0,0,0,,但只要切换到部分同步模型\NBut as soon as you go to a partially synchronous model,
Dialogue: 0,0:06:36.52,0:06:42.10,Default,,0,0,0,,则超时机制就无法准确检测出故障了\Nthen timeouts are no longer an exact way of detecting failures.
Dialogue: 0,0:06:42.10,0:06:46.18,Default,,0,0,0,,在部分同步网络系统中 我们能实现的最佳效果是\NSo, the best we can do in a partially synchronous system is what is called
Dialogue: 0,0:06:46.18,0:06:48.76,Default,,0,0,0,,最终完美失效检查器\Nan eventually perfect failure detector.
Dialogue: 0,0:06:48.76,0:06:51.48,Default,,0,0,0,,我很喜欢这个术语 没有人是完美的\NI love this term. Nobody is perfect.
Dialogue: 0,0:06:51.48,0:06:56.08,Default,,0,0,0,,我认为我最终能做到完美 可能大家也能最终变得完美\NI like to think of myself as eventually perfect. Maybe you are also eventually perfect.
Dialogue: 0,0:06:56.08,0:06:59.80,Default,,0,0,0,,在失效检查器场景下 最终完美的意思是\NAnd then, in the context of a failure detector, eventually perfect means that
Dialogue: 0,0:06:59.80,0:07:02.26,Default,,0,0,0,,失效检查器可能在某个时刻内犯错\Nthe failure detector might be wrong from time to time.
Dialogue: 0,0:07:02.26,0:07:05.24,Default,,0,0,0,,失效检查器有时虽然检查到了超时情况\NSo, the failure detector might detect a timeout
Dialogue: 0,0:07:05.24,0:07:07.46,Default,,0,0,0,,但此时节点可能并没有崩溃\Neven though the other node hasn't actually crashed yet,
Dialogue: 0,0:07:07.46,0:07:09.72,Default,,0,0,0,,只是因为消息传输出现了一点延迟\Njust because a message happened to be delayed a bit.
Dialogue: 0,0:07:09.72,0:07:15.46,Default,,0,0,0,,这意味着 应用超时机制无法准确指出节点是否已经崩溃\NSo, it means a timeout does not accurately indicate that a crash has happened.
Dialogue: 0,0:07:16.10,0:07:19.08,Default,,0,0,0,,失效检查器无法立即得到真实的检查结果\NAlso, a failure detector is not immediate.
Dialogue: 0,0:07:19.08,0:07:23.76,Default,,0,0,0,,如果节点已经崩溃 需要花费一定的时间才能检查到真的出现了崩溃\NSo, if a crash has happened, it might actually take a while until we detect that crash.
Dialogue: 0,0:07:23.76,0:07:26.66,Default,,0,0,0,,崩溃检查并不是瞬时完成的\NThe detection of the crash is not instantaneous.
Dialogue: 0,0:07:26.66,0:07:28.34,Default,,0,0,0,,我们可能会犯错\NSo, we might be wrong.
Dialogue: 0,0:07:28.34,0:07:31.90,Default,,0,0,0,,我们在一定时间内可能会出现误报或漏报\NWe might have both false positives and false negatives for a while.
Dialogue: 0,0:07:31.90,0:07:33.02,Default,,0,0,0,,但最终我们总能做到\NBut eventually,
Dialogue: 0,0:07:33.02,0:07:38.30,Default,,0,0,0,,当且仅当节点崩溃时 失效检查器将此节点标记为崩溃\Nthe failure detector labels a node as crashed if and only if it really has crashed.
Dialogue: 0,0:07:38.30,0:07:45.28,Default,,0,0,0,,这意味着临时怀疑另一个节点出现故障的情况最终会被纠正\NSo, that means that any temporarily suspecting another node of being failed will stop.
Dialogue: 0,0:07:45.28,0:07:48.54,Default,,0,0,0,,我们能重新将某个节点标记为正确节点\NAnd we'll go back to thinking that a node is correct
Dialogue: 0,0:07:48.94,0:07:51.16,Default,,0,0,0,,当然了 前提是这确实还是一个正确节点\Nprovided that the node really is still correct.
Dialogue: 0,0:07:51.16,0:07:55.70,Default,,0,0,0,,如果一个节点出现故障 我们最终可以检查到确实出现了故障\NAnd also, if a node has failed, then eventually we will detect it as failed.
Dialogue: 0,0:07:55.70,0:08:00.62,Default,,0,0,0,,这就是故障检查我们能做到的最好效果了\NAnd so, this is about the best we can do in terms of failure detection.
Dialogue: 0,0:08:01.10,0:08:02.20,Default,,0,0,0,,但即使做到这样也很不错\NBut it's still quite useful.
Dialogue: 0,0:08:02.20,0:08:07.56,Default,,0,0,0,,即使失效检查器仅能做到最终完美\NSo, even though we might have this failure detector that is only eventually perfect,
Dialogue: 0,0:08:07.56,0:08:11.12,Default,,0,0,0,,对于构建一些可用的算法来说也已经足够了\Nthis is actually sufficient in order to build some useful algorithms
Dialogue: 0,0:08:11.12,0:08:14.64,Default,,0,0,0,,我们后面会具体展开讨论\Nas we will see in some of the future lectures.
Dialogue: 0,0:08:14.64,0:08:17.74,Default,,0,0,0,,这就是今天有关系统模型的全部内容了\NSo, that's all for today on system models.
