[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 2.3_System models.mp4
Video File: 2.3_System models.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 254
Active Line: 287
Video Position: 29708

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:00.00,0:00:04.30,Default,,0,0,0,,我们现在已经学习了两将军问题和拜占庭将军问题\NWe've now seen the two generals problem and the Byzantine generals problem.
Dialogue: 0,0:00:04.30,0:00:05.80,Default,,0,0,0,,在两将军问题中\NIn the two generals problem,
Dialogue: 0,0:00:05.80,0:00:09.78,Default,,0,0,0,,我们假定节点是诚实的 但消息可能会丢失\Nwe assume that nodes are honest, but messages might get lost.
Dialogue: 0,0:00:09.78,0:00:11.24,Default,,0,0,0,,在拜占庭将军问题中\NIn the Byzantine generals problem,
Dialogue: 0,0:00:11.24,0:00:15.42,Default,,0,0,0,,我们假定消息传输可靠 但节点可能是不诚实的\Nwe assumed that messages are reliable, but nodes might be dishonest.
Dialogue: 0,0:00:15.42,0:00:18.64,Default,,0,0,0,,现在 我们会把两种情况放到一起\NSo now, well, we should put the two together really,
Dialogue: 0,0:00:18.64,0:00:21.74,Default,,0,0,0,,尝试为系统设计系统模型\Nand try and design system models for system
Dialogue: 0,0:00:21.74,0:00:25.64,Default,,0,0,0,,模型允许节点和网络可能存在各种不同的错误情况\Nin which both nodes and networks might go wrong in various ways.
Dialogue: 0,0:00:25.64,0:00:30.58,Default,,0,0,0,,系统模型是分布式系统中所有算法的基石\NAnd so, this is really the foundation of any algorithms in distributed systems.
Dialogue: 0,0:00:30.58,0:00:35.68,Default,,0,0,0,,我们需要明确假设系统拥有哪些特性\NWe need to assume certain things about what properties the system is going to have.
Dialogue: 0,0:00:35.68,0:00:41.38,Default,,0,0,0,,一般来说 我们会考虑三个方向\NAnd typically, we do that by looking at three different areas of interest.
Dialogue: 0,0:00:41.38,0:00:45.66,Default,,0,0,0,,第一 我们需要定义网络可能出现的情况\NSo, first of all, we need to describe how we assume the network is going to behave.
Dialogue: 0,0:00:45.66,0:00:48.88,Default,,0,0,0,,第二 我们需要定义节点可能出现的情况\NSecondly, we're going to assume how nodes are going to behave.
Dialogue: 0,0:00:48.88,0:00:52.92,Default,,0,0,0,,第三 我们需要定义系统中的时间情况\NAnd thirdly, we need to assume how the timing in the system is going to work.
Dialogue: 0,0:00:52.92,0:00:56.22,Default,,0,0,0,,时间会同时影响到网络和节点\NSo, the timing affects both networks and nodes.
Dialogue: 0,0:00:56.22,0:00:59.84,Default,,0,0,0,,这是系统模型所需要描述的三个方面\NSo, those are the three aspects of a system model
Dialogue: 0,0:00:59.84,0:01:02.38,Default,,0,0,0,,在本节中 我们将分别介绍这三方面的内容\Nthat we're going to look at now in this section.
Dialogue: 0,0:01:02.38,0:01:04.46,Default,,0,0,0,,我们先从网络开始\NLet's start with networks.
Dialogue: 0,0:01:04.46,0:01:08.42,Default,,0,0,0,,我已经重复强调了很多次 网络是不可靠的\NSo, I've repeated over and over again that networks are unreliable,
Dialogue: 0,0:01:08.42,0:01:10.58,Default,,0,0,0,,但我需要再次强调\Nbut just to re-emphasize that
Dialogue: 0,0:01:10.58,0:01:14.66,Default,,0,0,0,,消息可能由于各种各样的原因在网络中丢失\Nthere are many reasons why message might get lost in a network.
Dialogue: 0,0:01:15.30,0:01:18.34,Default,,0,0,0,,有些时候 消息丢失可能只是因为网络临时超载\NSome of them are just temporary overload.
Dialogue: 0,0:01:18.34,0:01:21.12,Default,,0,0,0,,缓存区已经满了 一条消息因此被舍弃了\NA buffer gets full, and so a message gets dropped.
Dialogue: 0,0:01:21.12,0:01:23.38,Default,,0,0,0,,即使你小心谨慎地设计系统 使缓存区永远不会溢出\NBut also, there are some more fundamental problems,
Dialogue: 0,0:01:23.38,0:01:26.64,Default,,0,0,0,,系统仍然会面临很多基础问题\Neven if you design it carefully so that your buffers never overflow.
Dialogue: 0,0:01:26.64,0:01:30.98,Default,,0,0,0,,有些负责运行系统的人可能会插错网线\NSome human operating a system might just unplug the wrong network cable.
Dialogue: 0,0:01:30.98,0:01:33.74,Default,,0,0,0,,当网线插错了的时候 网络肯定会中断一段时间\NAnd that means the network will be interrupted for the time
Dialogue: 0,0:01:33.74,0:01:36.90,Default,,0,0,0,,我们不能回避这类问题\Nthat this network cable is unplugged. No way around it.
Dialogue: 0,0:01:36.90,0:01:41.66,Default,,0,0,0,,还有很多因自然环境导致网络中断的奇奇怪怪的原因\NThere are also various other curious interactions with nature that happen.
Dialogue: 0,0:01:42.08,0:01:44.40,Default,,0,0,0,,举例来说 谷歌观察到\NSo, Google was observing, for example,
Dialogue: 0,0:01:44.40,0:01:49.26,Default,,0,0,0,,它们的海底光缆出现了莫名其妙的损坏情况\Non their subsea fiber optic cables that they were strange damaged.
Dialogue: 0,0:01:49.26,0:01:52.32,Default,,0,0,0,,它们观察到光缆上有奇怪的损坏痕迹\NThey observed strange damage on these cables.
Dialogue: 0,0:01:52.32,0:01:54.00,Default,,0,0,0,,它们安装了一些海底摄像头\NAnd they installed some underwater cameras
Dialogue: 0,0:01:54.00,0:01:58.84,Default,,0,0,0,,结果观察到鲨鱼在咬光缆\Nand actually managed to observe sharks biting into their cables.
Dialogue: 0,0:01:58.84,0:02:01.02,Default,,0,0,0,,你可以看看幻灯片中链接的视频\NYou can see the video at the link here on the slide.
Dialogue: 0,0:02:01.02,0:02:02.82,Default,,0,0,0,,力荐此视频 特别好玩\NDo watch it. It's incredibly cute.
Dialogue: 0,0:02:03.98,0:02:09.14,Default,,0,0,0,,在陆地上 人们也可能观察到奶牛踩踏光纤等问题\NOn land, people have observed problems with cows stepping on fiber optic cables.
Dialogue: 0,0:02:09.14,0:02:13.40,Default,,0,0,0,,光纤一般会沿着电力线部署\NSo, a fiber optic cable was supposed to run along a power line,
Dialogue: 0,0:02:13.68,0:02:15.80,Default,,0,0,0,,但最后总要落回到地表上\Nbut ended up trailing on the ground.
Dialogue: 0,0:02:15.80,0:02:20.26,Default,,0,0,0,,奶牛踩了上去 奶牛的踩踏动作使光纤出现严重扭曲\NCow steps on it, and the cow makes enough of a kink in the cable
Dialogue: 0,0:02:20.26,0:02:24.16,Default,,0,0,0,,光无法在严重扭曲的光纤中传播\Nthat the light can't get through the kink in the fiber optic cable,
Dialogue: 0,0:02:24.16,0:02:26.62,Default,,0,0,0,,因此 网络连接出现了中断\Nand thus, the network link gets interrupted.
Dialogue: 0,0:02:26.62,0:02:29.10,Default,,0,0,0,,确实有可能发生这类情况\NThis stuff really happens honestly.
Dialogue: 0,0:02:29.10,0:02:32.52,Default,,0,0,0,,网络可能因为多种多样的原因出现故障\NSo, lots of reasons why networks might fail.
Dialogue: 0,0:02:32.52,0:02:34.52,Default,,0,0,0,,我们把这些故障往上抽象一层\NLet's take this to a bit more abstract level
Dialogue: 0,0:02:34.52,0:02:37.80,Default,,0,0,0,,以便我们可以更形式化地描述可能出现的故障\Nso that we can reason about it in a more formal way.
Dialogue: 0,0:02:37.80,0:02:42.12,Default,,0,0,0,,在分布式系统中 当我们设计分布式算法时\NSo, typically in distributed systems, and when we're designing distributed algorithms,
Dialogue: 0,0:02:42.12,0:02:45.08,Default,,0,0,0,,我们一般假定节点之间是点对点通信的\Nwe are going to assume some kind of point-to-point communication.
Dialogue: 0,0:02:45.08,0:02:48.82,Default,,0,0,0,,我们假定消息有一个发送方和一个接收方\NSo, we're going to assume that messages have one sender and one recipient.
Dialogue: 0,0:02:48.82,0:02:51.00,Default,,0,0,0,,他们通过双向链路发送数据\NAnd they are sent over a bi-directional link
Dialogue: 0,0:02:51.00,0:02:54.92,Default,,0,0,0,,这使得接收方可以向发送方回复响应\Nso that the recipient can then reply back to the sender.
Dialogue: 0,0:02:54.92,0:02:58.48,Default,,0,0,0,,不管我们前面讨论的链路具体是如何构建的 我们都把它抽象成这种形式\NSo, that's everything the type of link we've been talking about so far.
Dialogue: 0,0:02:58.48,0:03:03.88,Default,,0,0,0,,我们可以进一步假设链路的可靠程度\NAnd we can then choose how reliable we are going to assume this link is.
Dialogue: 0,0:03:03.88,0:03:06.52,Default,,0,0,0,,最简单的可靠程度假设模型是\NAnd so, the simplest model to program against is
Dialogue: 0,0:03:06.52,0:03:09.20,Default,,0,0,0,,我们简单地假设链路是可靠的\Nif we simply assume that the link is reliable,
Dialogue: 0,0:03:09.20,0:03:11.82,Default,,0,0,0,,也就是说 消息总能够被成功传输\Nand that is, that messages always get through.
Dialogue: 0,0:03:11.82,0:03:14.18,Default,,0,0,0,,当发送一条消息时 这条消息一定能被接收到\NIf a message is sent, then it is received.
Dialogue: 0,0:03:14.18,0:03:18.42,Default,,0,0,0,,如果接收到一条消息 那这条消息一定是前面发送的消息\NAnd if a message is received, then it was previously sent.
Dialogue: 0,0:03:18.42,0:03:20.76,Default,,0,0,0,,链路不会丢失消息\NSo, the link doesn't lose messages,
Dialogue: 0,0:03:20.76,0:03:24.02,Default,,0,0,0,,链路也不会平白无故地制造消息\Nand the link also doesn't fabricate messages out of thin air.
Dialogue: 0,0:03:24.02,0:03:26.22,Default,,0,0,0,,接收的消息一定是之前发送的消息\NSo, a message is only received if it was sent.
Dialogue: 0,0:03:26.22,0:03:28.78,Default,,0,0,0,,但我们会假设消息的顺序可能会被打乱\NBut we're going to assume that messages can be reordered.
Dialogue: 0,0:03:28.78,0:03:31.50,Default,,0,0,0,,这当然是一个非常强的链路假设\NAnd so, that is quite a strong assumption, of course,
Dialogue: 0,0:03:31.50,0:03:34.66,Default,,0,0,0,,因为实际中的链路不可能做到如此可靠\Nbecause links may not actually be this reliable in practice.
Dialogue: 0,0:03:34.66,0:03:36.76,Default,,0,0,0,,我们后面就会介绍如何获得可靠链路\NBut we'll get to that in a moment.
Dialogue: 0,0:03:36.76,0:03:39.88,Default,,0,0,0,,我们会为链路设定的第二个假设是\NThe second assumption we could make about network links is
Dialogue: 0,0:03:39.88,0:03:42.04,Default,,0,0,0,,公平丢包链路\Nwhat is called a fair-loss link.
Dialogue: 0,0:03:42.04,0:03:45.58,Default,,0,0,0,,公平丢包链路是指\NSo, a fair-loss link is one in which
Dialogue: 0,0:03:45.58,0:03:50.32,Default,,0,0,0,,当你发送一条消息时 消息会有非零的概率传输成功\Nwhenever you send a message, it has a non-zero probability of being delivered.
Dialogue: 0,0:03:50.32,0:03:53.92,Default,,0,0,0,,当你发送一条消息时 这条消息可能会被发送到 也可能不会被发送到\NSo, when you send a message, it might get through, it might not get through.
Dialogue: 0,0:03:53.92,0:03:56.82,Default,,0,0,0,,但如果你持续重复地发送这条消息\NBut if you keep repeating the sending of that message,
Dialogue: 0,0:03:56.82,0:03:59.48,Default,,0,0,0,,那么我们可以假定此消息最终一定能被成功传输\Nthen we're going to assume that eventually it will get through.
Dialogue: 0,0:03:59.48,0:04:02.26,Default,,0,0,0,,我们不会假设消息需要花费多长时间才能被成功传输\NWe're not going to make any assumptions about how long that might take.
Dialogue: 0,0:04:02.26,0:04:05.54,Default,,0,0,0,,消息可能要花费相当长的时间才能被成功传输\NSo, it might take a long time until the message does finally get through.
Dialogue: 0,0:04:05.54,0:04:10.02,Default,,0,0,0,,但我们会假设 如果你的服务执行时间为无穷长\NBut we're going to assume that if you assume an infinitely long execution time,
Dialogue: 0,0:04:10.02,0:04:13.90,Default,,0,0,0,,那么在有限长时间内的某个时刻\Nthere will at some point within a finite amount of time be a point
Dialogue: 0,0:04:13.90,0:04:16.40,Default,,0,0,0,,所有消息都会被成功传输\Nwhen every message is delivered.
Dialogue: 0,0:04:16.40,0:04:22.36,Default,,0,0,0,,我们对网络链路能设定的第三个 也是最弱的假设是任意网络\NAnd the third, the weakest assumption we could make about network links is arbitrary.
Dialogue: 0,0:04:22.36,0:04:25.06,Default,,0,0,0,,我们允许此类网络链路发生任何事情\NSo, the network link is allowed to do anything.
Dialogue: 0,0:04:25.06,0:04:26.42,Default,,0,0,0,,我们可以将此链路建模为\NWe can model this
Dialogue: 0,0:04:26.42,0:04:32.04,Default,,0,0,0,,存在一个恶意的主动攻击者 他可以修改网络流量\Nin terms of a malicious active adversary who modifies the network traffic.
Dialogue: 0,0:04:32.04,0:04:35.42,Default,,0,0,0,,在真实的互联网中 确实存在这样的链路\NAnd so, this actually does happen on the real Internet.
Dialogue: 0,0:04:35.42,0:04:39.60,Default,,0,0,0,,如果你连接到咖啡店的Wi-Fi 则此Wi-Fi的拥有者\NIf you're connecting to a coffee shop Wi-Fi, the owner of that Wi-Fi
Dialogue: 0,0:04:39.60,0:04:42.82,Default,,0,0,0,,可能会用任何方式干扰你发送的网络数据包\Ncould be interfering with your network packets in arbitrary ways,
Dialogue: 0,0:04:42.82,0:04:46.56,Default,,0,0,0,,也就是说 他们不仅会查看你的网络通信内容\Nand that means they might not just be looking at your network communication,
Dialogue: 0,0:04:46.56,0:04:48.64,Default,,0,0,0,,即监听网络流\Nlike eavesdropping on it,
Dialogue: 0,0:04:48.64,0:04:50.86,Default,,0,0,0,,他们甚至可能会修改数据包\Nbut they might actually modify the packets.
Dialogue: 0,0:04:50.86,0:04:55.84,Default,,0,0,0,,他们可能会记录数据包 在后续的某个时间内重放此数据包\NThey might record packets, and then replay them at some later point of time.
Dialogue: 0,0:04:55.84,0:04:59.48,Default,,0,0,0,,他们可能会伪装成某个网站 实施仿冒攻击\NThey might pretend to be some website and spoof it.
Dialogue: 0,0:05:00.12,0:05:02.88,Default,,0,0,0,,当然了 他们也可能会丢弃你发送的消息\NAnd of course, they might drop messages as well.
Dialogue: 0,0:05:02.88,0:05:06.50,Default,,0,0,0,,我们允许任意链路发生任何可能发生的事情\NAnd so, an arbitrary link is allowed to do any of these things.
Dialogue: 0,0:05:06.50,0:05:13.78,Default,,0,0,0,,很不幸 用这一链路模型描述正在使用的互联网才是合理的\NAnd unfortunately, this is actually a reasonable model of how the Internet works today.
Dialogue: 0,0:05:13.78,0:05:17.92,Default,,0,0,0,,我想介绍的最后一个术语和概念是\NNow, a final piece of terminology that I want to introduce here
Dialogue: 0,0:05:17.92,0:05:20.06,Default,,0,0,0,,网络分区\Nis the concept of a network partition.
Dialogue: 0,0:05:20.06,0:05:24.16,Default,,0,0,0,,网络分区是指 你有一些节点\NSo, network partition is just if you have some nodes
Dialogue: 0,0:05:24.16,0:05:27.02,Default,,0,0,0,,这些节点仍然可以持续运行\Nwhere the nodes are still continuing to run fine,
Dialogue: 0,0:05:27.02,0:05:30.24,Default,,0,0,0,,但节点间的通信链路可能会被中断\Nbut the communication link between them is interrupted.
Dialogue: 0,0:05:30.24,0:05:34.34,Default,,0,0,0,,一般来说 我们认为网络会在有限的时间内发生中断\NUsually, we talk about this interruption of being for some finite period of time.
Dialogue: 0,0:05:34.34,0:05:37.26,Default,,0,0,0,,也就是说 网络分区最终总能被修复\NSo, eventually, the network partition does get repaired.
Dialogue: 0,0:05:37.26,0:05:40.58,Default,,0,0,0,,在未来的某个时刻 节点间又可以重新进行通信了\NAnd at some point in the future, they will be able to communicate again.
Dialogue: 0,0:05:40.58,0:05:43.74,Default,,0,0,0,,但中断周期可能会非常长\NBut the period of interruption might be quite substantial.
Dialogue: 0,0:05:43.74,0:05:46.84,Default,,0,0,0,,这是一个非常重要的概念 请大家牢记\NAnd this is an important thing to keep in mind.
Dialogue: 0,0:05:46.84,0:05:48.74,Default,,0,0,0,,举例来说 你可能有一个系统\NSo, you might have systems, for example,
Dialogue: 0,0:05:48.74,0:05:51.94,Default,,0,0,0,,系统中的一个节点子群允许相互通信\Nwhere one subgroup of nodes is able to communicate,
Dialogue: 0,0:05:51.94,0:05:55.64,Default,,0,0,0,,系统中的另一个节点子群也允许相互通信\Na different subgroup of nodes is able to communicate,
Dialogue: 0,0:05:55.64,0:05:58.54,Default,,0,0,0,,但这两个子群之间无法相互通信\Nbut those two groups cannot communicate between them,
Dialogue: 0,0:05:58.54,0:06:01.66,Default,,0,0,0,,因为这两个子群之间的网络链路发生了中断\Nbecause the network link between the two groups is interrupted.
Dialogue: 0,0:06:01.66,0:06:03.92,Default,,0,0,0,,这种情况是绝对有可能会发生的\NSo, this could absolutely happen.
Dialogue: 0,0:06:03.92,0:06:08.62,Default,,0,0,0,,围绕这三个网络行为模型 有一个非常有趣的结论\NSo now, the interesting thing with the three models of network behavior is that
Dialogue: 0,0:06:08.62,0:06:12.94,Default,,0,0,0,,总能将一个网络模型转换为另一个网络模型\Nit's actually almost possible to convert one model into another.
Dialogue: 0,0:06:12.94,0:06:16.02,Default,,0,0,0,,特别地 如果我们有一个公平丢包链路\NSo, in particular, if we have a fair-loss link,
Dialogue: 0,0:06:16.02,0:06:19.14,Default,,0,0,0,,我们可以把这个公平丢包链路转换为可靠链路\Nwe can turn a fair-loss link into a reliable link.
Dialogue: 0,0:06:19.14,0:06:24.06,Default,,0,0,0,,实现转换的方法非常简单 只需要一直重试发送消息 直到消息被成功传输\NAnd the way we can do that is we simply keep retrying messages until they get through.
Dialogue: 0,0:06:24.06,0:06:27.20,Default,,0,0,0,,这也意味着接收方侧会收到重复消息\NAnd on the recipient side, that means we might get duplicate messages.
Dialogue: 0,0:06:27.20,0:06:30.50,Default,,0,0,0,,因此 我们需要在接收方侧对消息进行去重处理\NSo, we have to also deduplicate the messages on the recipient side.
Dialogue: 0,0:06:30.50,0:06:33.90,Default,,0,0,0,,因为我们在公平丢包链路中假设\NAnd because with a fair-loss link, we are assuming that
Dialogue: 0,0:06:33.90,0:06:36.98,Default,,0,0,0,,如果我们一直重试 消息最终都能被成功传输\Nif we keep retrying, a message will eventually get through,
Dialogue: 0,0:06:36.98,0:06:41.12,Default,,0,0,0,,因此 总可以将公平丢包链路转换为可靠链路\Nthen it is actually possible to turn this into a reliable link
Dialogue: 0,0:06:41.12,0:06:43.10,Default,,0,0,0,,因为我们假定消息最终一定能被成功传输\Nbecause we're assuming it will eventually get through
Dialogue: 0,0:06:43.10,0:06:47.44,Default,,0,0,0,,因此 只要一直重试 消息就一定能被成功传输\Nand therefore, by keep retrying, it will eventually get through.
Dialogue: 0,0:06:48.24,0:06:50.80,Default,,0,0,0,,当然了 我们没有明确这要花费多长的时间\NOf course, we're not saying anything about how long that is going to take.
Dialogue: 0,0:06:50.80,0:06:53.66,Default,,0,0,0,,消息被成功传输所花费的时间可能会非常长\NIt could potentially take a very long time for a message to get through,
Dialogue: 0,0:06:53.66,0:06:55.88,Default,,0,0,0,,但最终总能被成功传输\Nbut it will eventually get through.
Dialogue: 0,0:06:55.88,0:07:02.24,Default,,0,0,0,,有趣的是 一般情况下 总能将一个任意链路转换为一个公平丢包链路\NInterestingly, it's also almost possible to convert an arbitrary link into a fair-loss link.
Dialogue: 0,0:07:02.24,0:07:06.92,Default,,0,0,0,,实现此转换的方法是使用类似TLS的密码学协议\NAnd the way we can do that is by using a cryptographic protocol such as TLS.
Dialogue: 0,0:07:06.92,0:07:10.16,Default,,0,0,0,,TLS表示传输层安全协议\NSo, TLS, which stands for Transport Layer Security,
Dialogue: 0,0:07:10.16,0:07:12.86,Default,,0,0,0,,它为你的浏览器带来了一个小绿锁\Nis what gives you the little green padlock in the browser,
Dialogue: 0,0:07:12.86,0:07:15.02,Default,,0,0,0,,它为你的HTTP协议带来了额外的字母S\Nit's what gives you the S in HTTPS.
Dialogue: 0,0:07:15.02,0:07:21.32,Default,,0,0,0,,这是一个安全协议 允许客户端和服务端之间实现通信\NSo, it's a security protocol that allows typically a client and a server to communicate
Dialogue: 0,0:07:21.32,0:07:26.56,Default,,0,0,0,,且保证通信链路可以抵抗网络流中发生的人为干扰\Nin a way that is resilient to people interfering with the network traffic.
Dialogue: 0,0:07:26.56,0:07:29.46,Default,,0,0,0,,也就是说 即使网络中存在主动攻击者\NSo, even if there's some active adversary on the network
Dialogue: 0,0:07:29.46,0:07:32.74,Default,,0,0,0,,他可以操纵你的网络通信链路\Nwho is manipulating your network communication,
Dialogue: 0,0:07:32.74,0:07:36.08,Default,,0,0,0,,TLS协议有能力保证\Nthe TLS protocol is able to guarantee that
Dialogue: 0,0:07:36.08,0:07:39.84,Default,,0,0,0,,只要通信成功 则通信的消息就不会被篡改\Nif the communication is successful, then it hasn't been tampered with.
Dialogue: 0,0:07:39.84,0:07:43.34,Default,,0,0,0,,这是一个认证通信链路 可以抵御仿冒攻击\NAnd it is authentic communication. It hasn't been spoofed.
Dialogue: 0,0:07:43.34,0:07:45.48,Default,,0,0,0,,当你想和网站通信时\NYou don't have some other person
Dialogue: 0,0:07:45.48,0:07:48.84,Default,,0,0,0,,其他人无法伪装成这个网站和你通信\Nimpersonating the website you're trying to communicate with, and so on.
Dialogue: 0,0:07:49.32,0:07:52.56,Default,,0,0,0,,因为数据经过了加密 因此通信链路也是私密的\NAnd the communication is private, because it's encrypted.
Dialogue: 0,0:07:52.56,0:07:56.50,Default,,0,0,0,,通过使用TLS这类协议\NAnd so, by using a protocol like TLS,
Dialogue: 0,0:07:56.50,0:08:01.10,Default,,0,0,0,,我们实际上有能力将任意链路转换为公平丢包链路\Nwe're actually able to almost change an arbitrary link into a fair-loss link.
Dialogue: 0,0:08:01.10,0:08:03.68,Default,,0,0,0,,我们唯一无法做到是\NThe only thing we cannot do is
Dialogue: 0,0:08:03.68,0:08:07.36,Default,,0,0,0,,如果主动攻击者直接决定阻断所有的通信链路 那我们就无能为力了\Nif the active adversary just decides to block all communication ever.
Dialogue: 0,0:08:07.36,0:08:10.16,Default,,0,0,0,,很显然 在这种情况下 任何消息都不可能被成功传输\NIn that case, of course, nothing is going to get through.
Dialogue: 0,0:08:10.16,0:08:12.40,Default,,0,0,0,,我们也无法将这种任意链路转换为公平丢包链路\NAnd you can't turn that into a fair-loss link,
Dialogue: 0,0:08:12.40,0:08:14.04,Default,,0,0,0,,因为我们无法保证\Nbecause we can't make any guarantee that
Dialogue: 0,0:08:14.04,0:08:17.16,Default,,0,0,0,,如果持续重试 消息就一定能被成功传输\Neventually a message will get through if you keep retrying.
Dialogue: 0,0:08:17.78,0:08:19.14,Default,,0,0,0,,但如果我们可以假设\NBut if we're willing to assume that
Dialogue: 0,0:08:19.14,0:08:24.22,Default,,0,0,0,,攻击者只会干扰有限数量的数据包\Nthe adversary will only interfere, say, with a finite number of packets,
Dialogue: 0,0:08:24.22,0:08:25.94,Default,,0,0,0,,那我们就可以称\Nthen we could say that,
Dialogue: 0,0:08:25.94,0:08:29.56,Default,,0,0,0,,可以将任意链路升级为公平丢包链路\NOK, the arbitrary link can be actually upgraded to a fair-loss link,
Dialogue: 0,0:08:29.56,0:08:31.90,Default,,0,0,0,,而通过持续重试和数据包去重\Nand from there, through retrying and deduplication,
Dialogue: 0,0:08:31.90,0:08:34.56,Default,,0,0,0,,我们可以进一步把链路转换为可靠链路\Nwe can actually turn it into a reliable link.
Dialogue: 0,0:08:34.56,0:08:38.06,Default,,0,0,0,,这就是我们的网络行为模型\NSo, that's our model of network behavior.
Dialogue: 0,0:08:38.06,0:08:41.98,Default,,0,0,0,,系统模型的下一部分是 如何为节点行为建模\NThe next part of the system model is how the nodes behave.
Dialogue: 0,0:08:41.98,0:08:45.64,Default,,0,0,0,,很显然 节点也有很多不同类型的故障\NSo, of course, nodes might fail in various ways as well.
Dialogue: 0,0:08:45.64,0:08:50.46,Default,,0,0,0,,我们考虑的第一种故障是崩溃故障\NAnd the first type of fault that we want to consider here is a crash fault.
Dialogue: 0,0:08:50.46,0:08:55.64,Default,,0,0,0,,我们将此类进程故障抽象为崩溃停止 崩溃停止的意思是\NAnd so, in the crash-stop abstraction for a process, what this means is that
Dialogue: 0,0:08:55.64,0:08:58.46,Default,,0,0,0,,我们假设进程在某个时刻崩溃了\Nwe assume that a process might crash at any moment.
Dialogue: 0,0:08:58.46,0:09:00.54,Default,,0,0,0,,一旦进程崩溃\NAnd once a process has crashed,
Dialogue: 0,0:09:00.54,0:09:03.56,Default,,0,0,0,,它将再也无法恢复 永远处于死机状态\Nthen it will never come back again, it's just dead forever.
Dialogue: 0,0:09:04.18,0:09:07.42,Default,,0,0,0,,节点一旦崩溃便永远死机 这很显然是一种非常简化的假设\NSo, this is a simplifying assumption, of course, that it's going to be dead forever.
Dialogue: 0,0:09:07.42,0:09:09.02,Default,,0,0,0,,在某些情况下 这种故障定义是准确的\NIn some cases, this is accurate.
Dialogue: 0,0:09:09.02,0:09:11.72,Default,,0,0,0,,如果你的节点是你的手机\NSo, if your node is your phone,
Dialogue: 0,0:09:11.72,0:09:16.04,Default,,0,0,0,,你一没留神 手机掉到了马桶里面 手机因此彻底损坏了\Nand you drop your phone in the toilet, and the phone is there after broken,
Dialogue: 0,0:09:16.04,0:09:18.96,Default,,0,0,0,,手机相当于突然从这个世界上消失了\Nthe phone has suddenly disappeared off the face of the earth,
Dialogue: 0,0:09:18.96,0:09:20.66,Default,,0,0,0,,它再也修不好了\Nand it's never going to come back again,
Dialogue: 0,0:09:20.66,0:09:22.52,Default,,0,0,0,,我们再也无法与这台手机通信了\Nit's never going to be able to communicate again.
Dialogue: 0,0:09:22.52,0:09:26.08,Default,,0,0,0,,你可以把这种情况建模为崩溃停止故障\NSo, therefore, you can model this as a crash stop failure.
Dialogue: 0,0:09:26.08,0:09:28.56,Default,,0,0,0,,也就是说 崩溃指的并不一定是软件崩溃\NSo, the crash might not just be a software crash.
Dialogue: 0,0:09:28.56,0:09:31.14,Default,,0,0,0,,也可以是灾难性的硬件崩溃\NIt could also be a catastrophic hardware failure,
Dialogue: 0,0:09:31.14,0:09:35.34,Default,,0,0,0,,节点有可能被破坏 再也无法恢复了\Nwhere a node is simply destroyed, and it will never be able to come back again.
Dialogue: 0,0:09:35.86,0:09:39.70,Default,,0,0,0,,但在其他系统中 我们一般会假设\NBut in other systems, we might want to assume actually that
Dialogue: 0,0:09:39.70,0:09:41.72,Default,,0,0,0,,节点可能会崩溃 但后面还能恢复\Nnodes might crash and then come back again.
Dialogue: 0,0:09:41.72,0:09:44.34,Default,,0,0,0,,经过某个时间阶段后 节点可能会恢复\NThey might recover after some period of time.
Dialogue: 0,0:09:44.34,0:09:47.08,Default,,0,0,0,,当一个节点崩溃时 我们一般会假设\NWhen a node crashes, we probably want to assume that
Dialogue: 0,0:09:47.08,0:09:49.42,Default,,0,0,0,,节点的所有内存状态都会丢失\Nany in-memory state that it had is lost.
Dialogue: 0,0:09:49.42,0:09:55.54,Default,,0,0,0,,任何未写入硬盘或其他非易失存储设备的状态都会丢失\NSo, any state that is not written to disk or to other some non-volatile storage will be lost.
Dialogue: 0,0:09:56.38,0:10:02.70,Default,,0,0,0,,但所有已经写入稳态存储器的数据都可以在崩溃中存活下来\NBut any data that is stored in stable storage is able to survive the crash,
Dialogue: 0,0:10:02.70,0:10:05.40,Default,,0,0,0,,当节点恢复时 这些数据也能得到恢复\Nand will be there after the node recovers.
Dialogue: 0,0:10:05.70,0:10:09.44,Default,,0,0,0,,当然了 崩溃恢复模型中的节点也有可能崩溃后再也无法恢复\NOf course, crash-recovery model nodes might still crash and never come back again.
Dialogue: 0,0:10:09.44,0:10:11.16,Default,,0,0,0,,这种概率也是存在的\NSo, that's still a possibility.
Dialogue: 0,0:10:11.16,0:10:16.12,Default,,0,0,0,,我们只是增加了一种可能性：节点崩溃后还有可能恢复\NWe're just adding the additional possibility that the node might recover after our crash.
Dialogue: 0,0:10:16.12,0:10:18.60,Default,,0,0,0,,第三个节点模型是拜占庭模型\NAnd the third model of nodes is Byzantine,
Dialogue: 0,0:10:18.60,0:10:22.58,Default,,0,0,0,,这里的“拜占庭”就是拜占庭将军问题中的“拜占庭”\Nso, exactly as in the Byzantine generals problem.
Dialogue: 0,0:10:23.38,0:10:28.82,Default,,0,0,0,,拜占庭故障节点的意思是 节点可能会偏离其需要执行的算法\NWhat it means for a node to be Byzantine faulty is just it deviates from the algorithm.
Dialogue: 0,0:10:28.82,0:10:32.28,Default,,0,0,0,,我们假定节点会遵从算法的执行流程\NSo, we specify an algorithm that all of the nodes are supposed to follow,
Dialogue: 0,0:10:32.28,0:10:35.42,Default,,0,0,0,,但拜占庭故障节点可能不会遵从算法的执行流程\Nbut a Byzantine faulty node may not follow the algorithm.
Dialogue: 0,0:10:35.42,0:10:37.28,Default,,0,0,0,,它可能会假装遵从算法的执行流程\NIt might pretend to follow the algorithm.
Dialogue: 0,0:10:37.28,0:10:40.92,Default,,0,0,0,,它可能会让自己看起来像一个诚实节点\NIt might do stuff to try and make it look honest,
Dialogue: 0,0:10:40.92,0:10:43.52,Default,,0,0,0,,但它有可能实际上在执行恶意行为\Neven though it's actually behaving in some malicious way.
Dialogue: 0,0:10:43.52,0:10:48.32,Default,,0,0,0,,我们不会对拜占庭故障节点的行为做出任何限制\NSo, we're not going to constrain the behavior of a Byzantine faulty node in any way.
Dialogue: 0,0:10:48.32,0:10:49.76,Default,,0,0,0,,我们只是假设\NWe're just going to assume that
Dialogue: 0,0:10:49.76,0:10:54.06,Default,,0,0,0,,此类节点可能会做出包括恶意行为在内的任何行为\Nit can do anything that it wants, including malicious behavior.
Dialogue: 0,0:10:54.06,0:10:56.58,Default,,0,0,0,,这里还涉及到一个术语\NAnd so, a piece of terminology here is
Dialogue: 0,0:10:56.58,0:11:01.78,Default,,0,0,0,,我们总可以把节点分类为故障节点和正确节点\Nwe can always categorize a node as either faulty or correct.
Dialogue: 0,0:11:02.32,0:11:04.64,Default,,0,0,0,,例如 如果节点崩溃了 那它就属于故障节点\NSo, a node is faulty if it crashes, for example,
Dialogue: 0,0:11:04.64,0:11:09.56,Default,,0,0,0,,或者在拜占庭模型中 如果节点偏离了算法 那它就属于故障节点\Nor in the Byzantine model, a node is faulty if it deviates from the algorithm.
Dialogue: 0,0:11:09.56,0:11:11.48,Default,,0,0,0,,如果节点没有发生故障 那它就属于正确节点\NA node is correct if it's not faulty.
Dialogue: 0,0:11:11.48,0:11:13.50,Default,,0,0,0,,总之 节点有这两种可能的状态\NSo, those are the two possibilities.
Dialogue: 0,0:11:13.50,0:11:20.96,Default,,0,0,0,,一个节点可以不必知道另一个节点是正确节点还是故障节点\NNow, one node does not necessarily know whether another node is correct or faulty.
Dialogue: 0,0:11:21.40,0:11:26.18,Default,,0,0,0,,我们稍后会介绍实现故障检查所需面对的问题\NAnd we will come to the problem of fault detection in a little while.
Dialogue: 0,0:11:26.18,0:11:29.56,Default,,0,0,0,,我们已经讨论了网络模型和节点模型\NSo, we've talked about models for network, models for nodes.
Dialogue: 0,0:11:29.56,0:11:32.28,Default,,0,0,0,,第三部分是为时间模型\NThe third part is models for timing.
Dialogue: 0,0:11:32.28,0:11:36.60,Default,,0,0,0,,同样地 我们有三种可以选择的模型\NAnd so, here again, they are one of three choices that we could make.
Dialogue: 0,0:11:36.60,0:11:40.52,Default,,0,0,0,,我们的第一个选择是同步系统模型\NSo, the first choice we could make is a synchronous system model.
Dialogue: 0,0:11:40.52,0:11:43.38,Default,,0,0,0,,在同步系统模型中 我们假设\NAnd in a synchronous system model, we assume that
Dialogue: 0,0:11:43.38,0:11:46.50,Default,,0,0,0,,所有活动发生的时长都是已知的\Nbasically everything takes a known length of time.
Dialogue: 0,0:11:46.50,0:11:48.58,Default,,0,0,0,,当我们通过网络发送一条消息时\NSo, when we send a message over the network,
Dialogue: 0,0:11:48.58,0:11:53.88,Default,,0,0,0,,消息传递成功或失败有一个最大时长\Nthere is some maximum time after which the message will be either delivered or lost,
Dialogue: 0,0:11:53.88,0:11:54.72,Default,,0,0,0,,我们假设\Nbut we assume that
Dialogue: 0,0:11:54.72,0:11:59.68,Default,,0,0,0,,任何消息到达的时间都不会超过最大时长\Nno message will take longer than some maximum amount of time to arrive.
Dialogue: 0,0:11:59.68,0:12:04.40,Default,,0,0,0,,我们同样假设 节点总会按照已知的速度执行代码\NAlso, we're going to assume that nodes always execute their code at a known speed.
Dialogue: 0,0:12:04.40,0:12:07.56,Default,,0,0,0,,对于每一步执行流程 对于每一步算法\NSo, every step of execution, every step of the algorithm,
Dialogue: 0,0:12:07.56,0:12:13.20,Default,,0,0,0,,节点执行的时长都存在一个上界\Nthere's an upper bound for the length of time that that execution is going to take.
Dialogue: 0,0:12:13.20,0:12:15.42,Default,,0,0,0,,这是一个很强的假设\NThis is a very strong assumption.
Dialogue: 0,0:12:15.42,0:12:20.70,Default,,0,0,0,,我们可以做出的另一个假设是部分同步模型\NNow, another assumption we could make is a partially synchronous model,
Dialogue: 0,0:12:20.70,0:12:25.42,Default,,0,0,0,,在一段时间周期内 系统的行为满足同步模型的定义\Nwhere for some periods of time, the system behaves as in the synchronous model,
Dialogue: 0,0:12:25.42,0:12:28.92,Default,,0,0,0,,在另一段时间周期内 系统的行为是异步的\Nand for other periods of time, it behaves in a way that's asynchronous.
Dialogue: 0,0:12:28.92,0:12:30.80,Default,,0,0,0,,我需要解释一下什么叫做异步\NAnd so, I need to explain asynchronous.
Dialogue: 0,0:12:30.80,0:12:34.68,Default,,0,0,0,,在异步模型中 我们不对时间做出任何假设\NSo, in an asynchronous model, we make no timing assumptions at all.
Dialogue: 0,0:12:34.68,0:12:37.70,Default,,0,0,0,,这意味着 如果我们通过网络发送一条消息\NSo, that means if you send a message over the network,
Dialogue: 0,0:12:37.70,0:12:40.28,Default,,0,0,0,,此消息可能花了20年才传输成功\Nit may arrive in 20 years' time, OK?
Dialogue: 0,0:12:40.28,0:12:42.02,Default,,0,0,0,,我们不保证\NWe're not making any guarantees about
Dialogue: 0,0:12:42.02,0:12:44.66,Default,,0,0,0,,消息需要花费多长时间才能到达目的地\Nhow long it's going to take for messages to arrive.
Dialogue: 0,0:12:44.66,0:12:47.32,Default,,0,0,0,,我们不假设消息延迟时长存在上界\NWe assume no upper bound on message latency.
Dialogue: 0,0:12:47.32,0:12:50.90,Default,,0,0,0,,当然了 大多数消息可能很快就会被成功传输\NOf course, it might be that messages are mostly delivered quite quickly,
Dialogue: 0,0:12:50.90,0:12:53.32,Default,,0,0,0,,但我们不会假设\Nbut we're just not going to make any assumptions about
Dialogue: 0,0:12:53.32,0:12:55.76,Default,,0,0,0,,消息传输存在某个时延上界\Nthe maximum latency that might occur.
Dialogue: 0,0:12:55.76,0:12:59.14,Default,,0,0,0,,进一步 我们不会假设\NMoreover, we're not going to make any assumptions about
Dialogue: 0,0:12:59.14,0:13:02.20,Default,,0,0,0,,节点会以多快的速度执行算法\Nhow fast nodes are going to execute the algorithm.
Dialogue: 0,0:13:02.20,0:13:07.84,Default,,0,0,0,,我们假设节点可能会在任何时刻暂停执行\NSo, we're going to assume that a node might pause its execution at any moment,
Dialogue: 0,0:13:07.84,0:13:13.70,Default,,0,0,0,,节点会在一段时间内停止执行算法 随后又会恢复执行\Nand just like stop executing its steps for a while, and then later resume executing again.
Dialogue: 0,0:13:13.70,0:13:16.94,Default,,0,0,0,,这当然是有可能发生的 大家也知道 线程有可能会被挂起\NAnd of course, this can happen, because a thread can be suspended as you know.
Dialogue: 0,0:13:16.94,0:13:20.34,Default,,0,0,0,,线程可能会暂停执行一段时间\NAnd so, a thread can just pause execution for a while,
Dialogue: 0,0:13:20.34,0:13:22.86,Default,,0,0,0,,随后再恢复执行\Nand then resume executing sometime later.
Dialogue: 0,0:13:23.76,0:13:27.64,Default,,0,0,0,,我们定义了同步模型这种极端情况\NAnd so, we have here the synchronous model as one extreme
Dialogue: 0,0:13:27.64,0:13:31.86,Default,,0,0,0,,在这种极端情况下 我们对网络延迟和节点处理速度\Nwhere like we're making very strong assumptions about
Dialogue: 0,0:13:32.42,0:13:36.06,Default,,0,0,0,,设置了一个很强的假设\Nthe network latency and the node processing speed,
Dialogue: 0,0:13:36.06,0:13:39.26,Default,,0,0,0,,而在异步模型中 我们没有设置任何假设\Nand the asynchronous model where we're making no assumptions at all.
Dialogue: 0,0:13:39.26,0:13:44.26,Default,,0,0,0,,部分同步模型是这两种极端情况的折中情况\NSo, the partially synchronous model is kind of a compromise between those two,
Dialogue: 0,0:13:44.26,0:13:46.86,Default,,0,0,0,,我们一般认为\Nwhere we're saying that actually
Dialogue: 0,0:13:46.86,0:13:51.06,Default,,0,0,0,,系统最好能支持异步模型\Nthe asynchronous model is great if we can work in the asynchronous model,
Dialogue: 0,0:13:51.06,0:13:55.02,Default,,0,0,0,,但确实有一些特定的问题无法在异步模型中解决\Nbut there are certain problems that simply cannot be solved in the asynchronous model.
Dialogue: 0,0:13:55.02,0:13:58.32,Default,,0,0,0,,在某些情况下 我们不得不对时间做出一些假设\NSo, in some cases, we do have to make timing assumptions.
Dialogue: 0,0:13:58.32,0:14:01.58,Default,,0,0,0,,但于此同时 我们不能简单的认为\NBut at the same time, it's unsafe to assume that
Dialogue: 0,0:14:01.58,0:14:04.06,Default,,0,0,0,,设置的时间假设总是成立的\Nthose timing assumptions are always true,
Dialogue: 0,0:14:04.06,0:14:07.68,Default,,0,0,0,,如果你在同步模型下写出了一个算法\Nbecause if you write an algorithm in the synchronous model,
Dialogue: 0,0:14:07.68,0:14:10.12,Default,,0,0,0,,但系统实际上是异步的\Nand the system is ever asynchronous,
Dialogue: 0,0:14:10.12,0:14:15.22,Default,,0,0,0,,举例来说 如果系统传递消息的时间超过了你假设的时延上界\Nif the system ever takes longer than your upper bound to deliver a message, for example,
Dialogue: 0,0:14:15.22,0:14:18.10,Default,,0,0,0,,那你的算法可能会灾难性地失败\Nthen your algorithm might fail catastrophically.
Dialogue: 0,0:14:18.10,0:14:23.38,Default,,0,0,0,,同步模型下的算法可能会对时间假设异常敏感\NSo, the algorithms are very very sensitive to your timing assumptions here.
Dialogue: 0,0:14:23.38,0:14:27.34,Default,,0,0,0,,在大多数情况下 假设系统满足同步模型是非常危险的\NAnd in most cases, it is very dangerous to assume a synchronous model,
Dialogue: 0,0:14:27.34,0:14:33.62,Default,,0,0,0,,因为现实世界中的网络行为与部分同步模型假设有些类似\Nbecause real networks do in fact behave in partially synchronous ways.
Dialogue: 0,0:14:33.62,0:14:36.66,Default,,0,0,0,,部分同步模型假设是一个折中假设\NSo, partially synchronous model is really our compromise
Dialogue: 0,0:14:36.66,0:14:40.74,Default,,0,0,0,,在部分同步模型中 我们认为系统行为在大多数情况下都是同步的\Nwhere we're saying most of the time the system is well behaved and kind of synchronous,
Dialogue: 0,0:14:40.74,0:14:42.78,Default,,0,0,0,,但系统偶尔会出现奇怪的情况\Nand occasionally it just goes weird,
Dialogue: 0,0:14:42.78,0:14:45.58,Default,,0,0,0,,消息偶尔会花费很长的时间才能传输成功\Nand occasionally messages take a really long time to arrive,
Dialogue: 0,0:14:45.58,0:14:48.02,Default,,0,0,0,,节点的执行速度偶尔会变得特别慢\Nand occasionally nodes are really slow to execute.
Dialogue: 0,0:14:48.02,0:14:51.20,Default,,0,0,0,,随后 在某个时刻 系统又会返回到同步状态\NAnd then, at some point, they'll return back into a synchronous state,
Dialogue: 0,0:14:51.20,0:14:55.20,Default,,0,0,0,,但我们不知道当前系统到底处于同步状态还是异步状态\Nbut we don't know whether they're asynchronous or synchronous right now.
Dialogue: 0,0:14:55.20,0:14:59.62,Default,,0,0,0,,让我来解释一下直接假设同步模型会遇到的问题\NSo, let me just explain the problems of assuming synchrony.
Dialogue: 0,0:14:59.62,0:15:03.28,Default,,0,0,0,,你可能会认为 大多数时间内的网络传输都是很流畅的\NSo, you might think that, you know, usually networks are quite fast,
Dialogue: 0,0:15:03.28,0:15:05.90,Default,,0,0,0,,一般来说 发送的一条消息很快就能传输成功\Nand usually if you send a message, then it'll be arrived,
Dialogue: 0,0:15:05.90,0:15:08.54,Default,,0,0,0,,到达时间一般都不会超过某个最长时间\Nit'll arrive within some maximum time.
Dialogue: 0,0:15:08.54,0:15:09.74,Default,,0,0,0,,但很不幸的是\NBut unfortunately,
Dialogue: 0,0:15:09.74,0:15:15.44,Default,,0,0,0,,有很多原因会导致消息偶尔会出现很长的传输时延\Nthere are lots of reasons why messages might take longer occasionally.
Dialogue: 0,0:15:15.44,0:15:19.62,Default,,0,0,0,,第一个可能的原因是 消息就是丢失了 需要重试\NAnd so, one reason might be that a message is lost and needs to be retried.
Dialogue: 0,0:15:19.62,0:15:24.52,Default,,0,0,0,,我前面也提到 在公平丢包链路升级为可靠链路的场景下\NAnd so, like we had earlier, in our case of upgrading a fair-loss link to a reliable link,
Dialogue: 0,0:15:24.52,0:15:28.30,Default,,0,0,0,,升级为可靠链路的主要开销来自于\Nthe cost of that upgrade in reliability was that
Dialogue: 0,0:15:28.30,0:15:30.30,Default,,0,0,0,,有时我们可能需要等待很长的时间才能发送出消息\Npotentially we have to wait for a very long time.
Dialogue: 0,0:15:30.30,0:15:31.68,Default,,0,0,0,,如果存在网络分区\NIf there's a network partition,
Dialogue: 0,0:15:31.68,0:15:34.58,Default,,0,0,0,,可能需要等待几分钟、几个小时、甚至几天的时间\Nwe might have to wait for minutes, or even hours, or even days
Dialogue: 0,0:15:34.58,0:15:36.00,Default,,0,0,0,,消息才能传输成功\Nbefore the message gets through.
Dialogue: 0,0:15:36.00,0:15:41.48,Default,,0,0,0,,在这种情况下 我们不能假设消息传输有一个最大延时上界\NSo, in this case, we can't assume any upper bound really on message latency,
Dialogue: 0,0:15:41.48,0:15:46.72,Default,,0,0,0,,因为延时可能会等于网络分区的修复时长\Nbecause it might be up to the length that it takes for our network partition to be healed.
Dialogue: 0,0:15:46.72,0:15:49.88,Default,,0,0,0,,网络延迟突然变高的另一个原因\NOther reasons why network latency might suddenly increase
Dialogue: 0,0:15:49.88,0:15:52.48,Default,,0,0,0,,也可能是网络发生了阻塞和排队的情况\Nis just congestion and queuing in the network,
Dialogue: 0,0:15:52.48,0:15:56.46,Default,,0,0,0,,还可能发生的一个例子是网络配置发生了修改\Nor there have even been examples of a network reconfiguration
Dialogue: 0,0:15:56.46,0:16:00.66,Default,,0,0,0,,这使得数据包在交换缓存区中卡了几分钟后\Nwhere packets just get stuck in a switch buffer for over a minute
Dialogue: 0,0:16:00.66,0:16:02.34,Default,,0,0,0,,才能被传输出去\Nbefore they're eventually delivered.
Dialogue: 0,0:16:02.34,0:16:07.26,Default,,0,0,0,,因此 即使在数据中心网络这种管理有方的网络场景\NAnd so, even in data center networks which are normally very well-managed,
Dialogue: 0,0:16:07.26,0:16:12.24,Default,,0,0,0,,也可能会偶发性地出现极高的消息传输延迟\Nit is possible to actually occasionally have really extremely high message latency.
Dialogue: 0,0:16:12.24,0:16:18.38,Default,,0,0,0,,因此 我们设计的任何算法都需要考虑\NAnd so, any algorithm that we design must take into account this possibility that
Dialogue: 0,0:16:18.38,0:16:21.78,Default,,0,0,0,,出现偶发性超高消息传输延迟的可能性\Noccasionally messages might take a very long time to arrive.
Dialogue: 0,0:16:21.78,0:16:26.80,Default,,0,0,0,,对于节点执行速度 我们一般会期望\NIn terms of the execution speed of nodes, again, we would expect normally like
Dialogue: 0,0:16:26.80,0:16:30.24,Default,,0,0,0,,计算机会按照固定的时钟速率下执行算法\Ncomputers run at a kind of fixed speed, a fixed clock speed.
Dialogue: 0,0:16:30.24,0:16:32.40,Default,,0,0,0,,但我们不能认为执行速率就会变得非常非常稳定\NSo, we don't expect that to very very much.
Dialogue: 0,0:16:32.40,0:16:33.62,Default,,0,0,0,,有很多原因会导致\NBut there are many reasons
Dialogue: 0,0:16:33.62,0:16:37.64,Default,,0,0,0,,节点执行过程中出现偶发性中断\Nwhy a node's execution might be interrupted for a little while.
Dialogue: 0,0:16:37.64,0:16:41.14,Default,,0,0,0,,大家在本课程的并发系统部分已经学过\NSo, as you know from the concurrent systems part of this course,
Dialogue: 0,0:16:41.14,0:16:42.46,Default,,0,0,0,,系统实现可能包含上下文切换\Nyou can have a context switch,
Dialogue: 0,0:16:42.46,0:16:46.62,Default,,0,0,0,,你的某个线程可能会被临时挂起 而其他进程还在正常运行\Nyou can have a thread that temporarily gets suspended while other processes run.
Dialogue: 0,0:16:46.62,0:16:49.24,Default,,0,0,0,,可能要等待一段时间\NAnd so, this might take a while
Dialogue: 0,0:16:49.24,0:16:53.18,Default,,0,0,0,,操作系统的调度算法才能回过头来再次启动你的线程\Nbefore the operating system scheduler comes back and starts running your thread again,
Dialogue: 0,0:16:53.18,0:16:58.10,Default,,0,0,0,,尤其是当系统出现一些问题时 例如系统发生了优先级倒置\NEspecially if there's some kind of problem going on, like priority inversion in the system,
Dialogue: 0,0:16:58.10,0:17:03.02,Default,,0,0,0,,此时 进程可能会出现长时间的暂停\Nit could be that a process is actually paused for a significant amount of time
Dialogue: 0,0:17:03.02,0:17:04.30,Default,,0,0,0,,随后才能重新运行起来\Nbefore it gets to run again.
Dialogue: 0,0:17:04.30,0:17:06.86,Default,,0,0,0,,在多线程下\NAnd as you know from multi-threading,
Dialogue: 0,0:17:06.86,0:17:11.08,Default,,0,0,0,,进程或线程可能会在任何时刻暂停\Na process can or a thread can get paused that absolutely any moment.
Dialogue: 0,0:17:11.08,0:17:15.90,Default,,0,0,0,,代码中的任何位置都有可能遇到暂停情况\NThere's any point in the code it could decide to pause.
Dialogue: 0,0:17:15.90,0:17:20.96,Default,,0,0,0,,即使在算法最不适合暂停的地方\NAnd so, even at the most inconvenient place possible in an algorithm,
Dialogue: 0,0:17:20.96,0:17:23.96,Default,,0,0,0,,也可能会发生线程暂停或上下文切换\Nyou might have a thread pause or a context switch.
Dialogue: 0,0:17:23.96,0:17:27.50,Default,,0,0,0,,在实际中可能发生的另一个问题是垃圾回收\NAnother real problem that happens in practice is garbage collection,
Dialogue: 0,0:17:27.50,0:17:29.92,Default,,0,0,0,,举个例子 Java这样的语言\Nso, in a language like Java, for example,
Dialogue: 0,0:17:29.92,0:17:32.52,Default,,0,0,0,,会执行自动化内存管理\Nwhich performs automatic memory management,
Dialogue: 0,0:17:32.52,0:17:35.86,Default,,0,0,0,,它会使用垃圾回收机制释放内存\Nand which uses garbage collection to free up memory,
Dialogue: 0,0:17:36.38,0:17:40.44,Default,,0,0,0,,你可能会遇到所谓的“停止一切”垃圾回收暂停机制\Nyou can have what is called a “stop-the-world” garbage collection pause,
Dialogue: 0,0:17:40.44,0:17:44.22,Default,,0,0,0,,垃圾回收器会让所有正在运行的线程停止一段时间\Nwhere the garbage collector just has to stop all of the running threads for a while,
Dialogue: 0,0:17:44.22,0:17:46.12,Default,,0,0,0,,执行垃圾回收\Nwhile it performs the garbage collection.
Dialogue: 0,0:17:46.12,0:17:52.06,Default,,0,0,0,,如果你的堆空间很大 则暂停时间有时甚至会达到分钟级\NAnd those pauses can last minutes sometimes if you have a large heap size.
Dialogue: 0,0:17:52.06,0:17:54.54,Default,,0,0,0,,这是进程或线程\NSo, that again is another reason
Dialogue: 0,0:17:54.54,0:18:00.56,Default,,0,0,0,,可能会暂停执行一段时间的另一个原因\Nwhy a process or a thread might just pause execution for a while.
Dialogue: 0,0:18:00.56,0:18:04.06,Default,,0,0,0,,最后 操作系统当然也可能出现很多意想不到的情况\NAnd finally, of course, there are lots of other things in the operating system
Dialogue: 0,0:18:04.06,0:18:08.06,Default,,0,0,0,,分页错误等都有可能导致不可预知的处理延迟\Nthat cause variable delays, such as page faults and so on,
Dialogue: 0,0:18:08.06,0:18:09.94,Default,,0,0,0,,内存空间受限时尤其可能出现延迟\Nespecially if memory is tight.
Dialogue: 0,0:18:09.94,0:18:11.92,Default,,0,0,0,,确实有可能避免操作系统出现上述情况\NSo, it is possible to get around these things.
Dialogue: 0,0:18:11.92,0:18:15.76,Default,,0,0,0,,实时操作系统会提供调度保证机制\NSo, real-time operating systems will provide scheduling guarantees.
Dialogue: 0,0:18:15.76,0:18:21.64,Default,,0,0,0,,实时操作系统会保证每行代码的执行时间间隔不会超过10毫秒\NThey might guarantee that your code always runs at least once every 10 milliseconds.
Dialogue: 0,0:18:22.14,0:18:25.34,Default,,0,0,0,,但大多数分布式系统不是基于实时操作系统构建的\NBut most distributed systems are not built on real-time operating systems.
Dialogue: 0,0:18:25.34,0:18:27.40,Default,,0,0,0,,它们一般都构建在通用操作系统上\NThey're built on general purpose operating systems,
Dialogue: 0,0:18:27.40,0:18:31.58,Default,,0,0,0,,通用操作系统不能为进程调度提供任何时延保证\Nwhich make no guarantees about how processes are going to get scheduled.
Dialogue: 0,0:18:31.58,0:18:33.78,Default,,0,0,0,,即使你使用的就是实时操作系统\NAnd even if you are using a real-time operating system,
Dialogue: 0,0:18:33.78,0:18:38.72,Default,,0,0,0,,也很难保证时间调度机制永远满足时间要求\Nit's very hard work to actually ensure that those timing guarantees always hold.
Dialogue: 0,0:18:38.72,0:18:41.24,Default,,0,0,0,,对于大多数实际场景下的分布式系统来说\NSo, for most practical distributed systems,
Dialogue: 0,0:18:41.24,0:18:45.08,Default,,0,0,0,,我们无法对时长设置任何上界\Nwe cannot assume any upper bound on how long it might take
Dialogue: 0,0:18:45.08,0:18:50.58,Default,,0,0,0,,这里的时长包括消息传递时长和进程单步执行时长\Nfor both a message to be delivered, or a process to execute one step,
Dialogue: 0,0:18:51.10,0:18:59.30,Default,,0,0,0,,因为在任何时刻下 延迟的发生都是不确定的 也是不可预测的\Nbecause these delays can occur unpredictably and non-deterministically at any point.
Dialogue: 0,0:18:59.30,0:19:01.38,Default,,0,0,0,,我们对这部分介绍的内容做个总结\NSo, that's a summary. This is what we talked about.
Dialogue: 0,0:19:01.38,0:19:04.36,Default,,0,0,0,,系统模型包含三个部分\NSystem model consists of three parts.
Dialogue: 0,0:19:04.36,0:19:06.64,Default,,0,0,0,,我们可以假设网络的可靠性\NWe can make an assumption about the network,
Dialogue: 0,0:19:06.64,0:19:10.44,Default,,0,0,0,,假设网络是可靠的、公平丢包的、还是任意的\Nhow reliable we want the network to be reliable, fair-loss or arbitrary.
Dialogue: 0,0:19:10.44,0:19:13.88,Default,,0,0,0,,我们可以假设节点可能的行为\NWe make an assumption about how nodes are going to behave.
Dialogue: 0,0:19:13.88,0:19:17.90,Default,,0,0,0,,我们可以假设崩溃停止节点 意思是节点一旦崩溃就再也无法恢复了\NSo, are we going to assume crash-stop, where crash means a node never comes back,
Dialogue: 0,0:19:17.90,0:19:21.82,Default,,0,0,0,,也可以假设崩溃恢复节点 甚至假设拜占庭节点\Nor crash-recovery, or even Byzantine behavior of nodes.
Dialogue: 0,0:19:21.82,0:19:24.66,Default,,0,0,0,,第三部分是时间模型\NAnd then, thirdly for the timing, we can choose
Dialogue: 0,0:19:24.66,0:19:29.70,Default,,0,0,0,,我们可以选择同步执行、部分同步执行、以及异步执行\Nbetween synchronous or partially synchronous or asynchronous execution.
Dialogue: 0,0:19:29.70,0:19:34.92,Default,,0,0,0,,这些抽象模型的选择结果对分布式系统来说非常重要\NAnd these choices of abstraction are absolutely crucial.
Dialogue: 0,0:19:34.92,0:19:37.44,Default,,0,0,0,,如果你在设计一个分布式系统\NSo, if you're designing a distributed algorithm,
Dialogue: 0,0:19:37.44,0:19:42.68,Default,,0,0,0,,你必须非常确定你所选择的假设是否正确\Nyou have to be absolutely certain that your assumption in regard to these are correct.
Dialogue: 0,0:19:42.68,0:19:45.82,Default,,0,0,0,,举例来说 如果你假设崩溃恢复模型\NSo, for example, if you're assuming a crash-recovery model
Dialogue: 0,0:19:45.82,0:19:49.42,Default,,0,0,0,,但实际上 你的系统中存在一些拜占庭节点\Nand actually, you have some Byzantine nodes in your system,
Dialogue: 0,0:19:49.42,0:19:52.30,Default,,0,0,0,,拜占庭节点就会毁掉你的算法\Nthe Byzantine nodes are just going to destroy your algorithm.
Dialogue: 0,0:19:52.30,0:19:55.90,Default,,0,0,0,,如果你认为节点可能存在拜占庭行为\NSo, if you think they're going to be Byzantine behavior,
Dialogue: 0,0:19:55.90,0:19:57.90,Default,,0,0,0,,你就需要在算法设计中考虑到相应的情况\Nthen you have to take account for it in the algorithm,
Dialogue: 0,0:19:57.90,0:20:01.52,Default,,0,0,0,,所设计的算法需要容忍拜占庭行为\Nand the algorithm has to be designed to tolerate Byzantine behavior.
Dialogue: 0,0:20:01.52,0:20:03.80,Default,,0,0,0,,直接假设系统满足较高的假设要求也没什么问题\NIt is perfectly fine if you're going to assume
Dialogue: 0,0:20:03.80,0:20:07.38,Default,,0,0,0,,你可以假设这是一个全可信系统 没有任何拜占庭节点\Nthis is a fully trusted system, it's not going to have any Byzantine nodes,
Dialogue: 0,0:20:07.38,0:20:10.14,Default,,0,0,0,,可以假设只存在崩溃停止节点和崩溃恢复节点\Nand just assume only crash-stop or crash-recovery.
Dialogue: 0,0:20:10.14,0:20:13.10,Default,,0,0,0,,这么假设也没问题 只是必须确定你所选择的假设是正确的\NThat's fine. You just have to be very sure that your assumption is correct.
Dialogue: 0,0:20:13.10,0:20:14.82,Default,,0,0,0,,时间假设也一样\NLikewise, with timing,
Dialogue: 0,0:20:16.48,0:20:20.68,Default,,0,0,0,,我前面提到 假设同步模型 但系统实际上仅满足部分同步模型\Nmaking synchrony assumptions, as I said, assuming a synchronous model
Dialogue: 0,0:20:20.68,0:20:24.54,Default,,0,0,0,,这种情况是非常危险的\Nwhen actually your system is partially synchronous is very dangerous.
Dialogue: 0,0:20:24.54,0:20:27.10,Default,,0,0,0,,如果你假设的是同步模型\NIt's very likely that if you assume a synchronous model,
Dialogue: 0,0:20:27.10,0:20:31.84,Default,,0,0,0,,哪怕系统只有10秒钟的时间处于部分同步状态\Nand it goes partially synchronous even just for like 10 seconds somewhere,
Dialogue: 0,0:20:32.26,0:20:35.38,Default,,0,0,0,,你设计的分布式算法都有可能无法工作\Nall of the guarantees of your distributed algorithm are off.
Dialogue: 0,0:20:35.38,0:20:38.30,Default,,0,0,0,,你必须非常确定你所选择的假设是否正确\NSo, you have to be very sure that your assumptions
Dialogue: 0,0:20:38.30,0:20:43.50,Default,,0,0,0,,要正确选择时间模型、节点行为模型、以及网络模型\Nin terms of the synchrony model, the node behavior, and the network are correct.
