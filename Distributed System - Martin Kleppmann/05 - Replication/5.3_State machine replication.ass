[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 5.3_State machine replication.mp4
Video File: 5.3_State machine replication.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 129
Active Line: 148
Video Position: 17246

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.82,0:00:03.76,Default,,0,0,0,,我们已经讨论了复制\NSo, we've been talking about replication.
Dialogue: 0,0:00:03.76,0:00:07.64,Default,,0,0,0,,如果你还记得的话 我们在上一节课讨论了广播协议\NAnd if you remember, in the last lecture, we talked about broadcast protocols.
Dialogue: 0,0:00:07.64,0:00:09.98,Default,,0,0,0,,广播协议的核心是\NAnd the whole point of a broadcast protocol is 
Dialogue: 0,0:00:09.98,0:00:13.58,Default,,0,0,0,,让所有的节点都按照某种顺序接收一组消息\Nfor all of the nodes to receive some set of messages in some order.
Dialogue: 0,0:00:13.58,0:00:18.92,Default,,0,0,0,,复制的核心是让所有的副本都可以处理相同的更新请求\NAnd the point of replication is for all of the replicas to process some updates.
Dialogue: 0,0:00:18.92,0:00:20.42,Default,,0,0,0,,你可能会问\NSo, you might be wondering 
Dialogue: 0,0:00:20.42,0:00:24.82,Default,,0,0,0,,我们能不能使用广播协议来实现复制\Nhmm, shouldn't we be able to use a broadcast protocol to do replication.
Dialogue: 0,0:00:24.82,0:00:25.82,Default,,0,0,0,,你的想法是对的\NAnd you would be right. 
Dialogue: 0,0:00:25.82,0:00:29.66,Default,,0,0,0,,事实上 我们确实可以使用广播协议实现复制 我们现在来看具体方法\NIndeed, we can use broadcast protocols, and we're going to look at that now.
Dialogue: 0,0:00:29.66,0:00:32.98,Default,,0,0,0,,首先 我们从FIFO全序关系广播出发\NSo, first of all, let's start with FIFO total order broadcast,
Dialogue: 0,0:00:32.98,0:00:37.26,Default,,0,0,0,,这是我们考虑的最强大的广播协议\Nthe strongest of the broadcast protocols which we considered.
Dialogue: 0,0:00:37.26,0:00:41.48,Default,,0,0,0,,如果你还记得的话 全序关系广播的核心是\NAnd if you remember, the point of total order broadcast is that 
Dialogue: 0,0:00:41.48,0:00:45.68,Default,,0,0,0,,所有节点都将按照相同的顺序传递相同的消息集合\Nall of the nodes will deliver the same set of messages in the same order,
Dialogue: 0,0:00:45.68,0:00:47.86,Default,,0,0,0,,而这正是我们想要的复制\Nwhich is exactly what we want for replication.
Dialogue: 0,0:00:47.86,0:00:51.30,Default,,0,0,0,,这种方法叫做状态机复制\NAnd this approach is called state machine replication.
Dialogue: 0,0:00:51.30,0:00:52.96,Default,,0,0,0,,算法非常简单\NSo, the algorithm is simple.
Dialogue: 0,0:00:52.96,0:00:57.12,Default,,0,0,0,,当一个副本想要更新自己的状态时\NWhenever a replica wants to make some update to its state,
Dialogue: 0,0:00:57.12,0:01:03.16,Default,,0,0,0,,它使用FIFO全序关系广播向其他所有副本广播更新操作\Nit uses FIFO total order broadcast to broadcast that update to all of the replicas.
Dialogue: 0,0:01:03.16,0:01:07.08,Default,,0,0,0,,当一个副本收到其中一个更新操作时\NAnd whenever a replica delivers one of these updates, 
Dialogue: 0,0:01:07.08,0:01:11.22,Default,,0,0,0,,它处理此更新操作 将更新操作应用在自己的状态上\Nit processes that update, applies it to its own state.
Dialogue: 0,0:01:11.22,0:01:17.66,Default,,0,0,0,,此副本将从广播中收到的更新操作看作是更新函数 用此函数更新自己的状态\NSo, it updates its own state as a function of this update that it received over the broadcast.
Dialogue: 0,0:01:17.66,0:01:22.52,Default,,0,0,0,,这一方法之所以可行的一个关键点是\NAnd the key thing that makes this work is that 
Dialogue: 0,0:01:22.52,0:01:26.50,Default,,0,0,0,,执行更新操作的逻辑是确定性的\Nthe logic for applying an update is deterministic.
Dialogue: 0,0:01:26.50,0:01:31.40,Default,,0,0,0,,因此 你可以把每个副本看成是一个状态机\NAnd so, you can think of each replica as a state machine.
Dialogue: 0,0:01:31.40,0:01:35.84,Default,,0,0,0,,副本的状态就是副本存储的所有数据\NThe state of the replica is all of the data that it has stored.
Dialogue: 0,0:01:35.84,0:01:39.66,Default,,0,0,0,,每个副本的都以固定的启动状态启动\NAnd every replica starts off in a fixed starting state,
Dialogue: 0,0:01:39.66,0:01:42.94,Default,,0,0,0,,启动状态一般是一个不包含任何数据的空数据库\Nwhich is usually an empty database containing no data.
Dialogue: 0,0:01:42.94,0:01:47.34,Default,,0,0,0,,随后 副本进行确定性状态更新\NAnd then, the deterministic state update means that 
Dialogue: 0,0:01:47.34,0:01:52.26,Default,,0,0,0,,也就是说 当两个副本处于相同状态 而我们又给它相同的输入时\Nwhenever two replicas are in the same state, and we give them the same input 
Dialogue: 0,0:01:52.26,0:01:55.44,Default,,0,0,0,,两个副本将会转移到相同的下一个状态\Nthen they will transition to the same next state.
Dialogue: 0,0:01:55.44,0:01:59.56,Default,,0,0,0,,因为FIFO全序关系广播可以保证\NAnd because FIFO total order broadcast ensures that 
Dialogue: 0,0:01:59.56,0:02:05.20,Default,,0,0,0,,每个副本都按照相同的顺序传递相同的更新操作\Neach of the replicas delivers the same updates in the same order,
Dialogue: 0,0:02:05.52,0:02:11.12,Default,,0,0,0,,如果我们以这些传递的更新操作作为状态机的输入\Nif we take these delivered updates to be the input to the state machine,
Dialogue: 0,0:02:11.12,0:02:12.50,Default,,0,0,0,,则对于每一个副本\Nthen on each replica, 
Dialogue: 0,0:02:12.50,0:02:17.26,Default,,0,0,0,,其状态机都会按照相同的状态转移顺序进行状态转换\Nthe state machine is going to go through the same sequence of state transitions,
Dialogue: 0,0:02:17.76,0:02:19.98,Default,,0,0,0,,按照相同消息顺序处理完毕后\Nand they're both going to end up in the same state 
Dialogue: 0,0:02:19.98,0:02:22.58,Default,,0,0,0,,每一个副本都将在相同的状态下终止\Nafter they've processed the same sequence of messages.
Dialogue: 0,0:02:22.58,0:02:26.44,Default,,0,0,0,,这正是我们想要的状态机复制\NSo, this is exactly what we want of state machine replication.
Dialogue: 0,0:02:26.44,0:02:30.80,Default,,0,0,0,,这是一种非常好的复制方法\NAnd it's a very good way of performing replication,
Dialogue: 0,0:02:30.80,0:02:33.94,Default,,0,0,0,,因为只要我们有全序关系广播\Njust because if we have this total order broadcast,
Dialogue: 0,0:02:33.94,0:02:36.66,Default,,0,0,0,,复制算法本身就会变得非常简单\Nthen the replication algorithm itself is really simple.
Dialogue: 0,0:02:36.66,0:02:41.60,Default,,0,0,0,,每当出现执行一次更新操作 我们就通过全序关系广播来广播此更新操作\NIt's just whenever we have an update, we broadcast it via total order broadcast.
Dialogue: 0,0:02:41.60,0:02:46.46,Default,,0,0,0,,每当传递了一次更新操作 我们就依此操作完成更新\NAnd whenever we deliver an update, we update the state accordingly.
Dialogue: 0,0:02:46.46,0:02:49.08,Default,,0,0,0,,实际上 这个思想被广泛应用于\NAnd this idea is actually very widely used 
Dialogue: 0,0:02:49.08,0:02:52.02,Default,,0,0,0,,多种不同的复制系统中\Nin a whole range of different replicated systems.
Dialogue: 0,0:02:52.02,0:02:56.26,Default,,0,0,0,,举例来说 有些分布式数据库\NSo, there are some distributed databases, for example, 
Dialogue: 0,0:02:56.26,0:03:00.68,Default,,0,0,0,,使用此方法来复制事务\Nwhich use this approach for replicating transactions, 
Dialogue: 0,0:03:00.68,0:03:06.16,Default,,0,0,0,,这些数据库的状态更新逻辑可以变得特别复杂\Nso, this logic here of the updating the state, as long as it's deterministic,
Dialogue: 0,0:03:06.16,0:03:08.72,Default,,0,0,0,,只要求状态更新逻辑是确定性的\Nit can be any arbitrarily complex logic.
Dialogue: 0,0:03:08.72,0:03:14.20,Default,,0,0,0,,你可以将包含任意业务逻辑在内的整个事务都打包在一起\NSo, you can package a whole transaction including arbitrary business logic into this,
Dialogue: 0,0:03:14.20,0:03:17.58,Default,,0,0,0,,并保证所有事务\Nand make sure that the inputs to the transactions 
Dialogue: 0,0:03:17.58,0:03:21.68,Default,,0,0,0,,都通过全序关系广播传递给所有的副本\Nget delivered to all of the replicas through total order broadcast,
Dialogue: 0,0:03:21.68,0:03:25.70,Default,,0,0,0,,这样一来 你就可以在每个副本上独立执行事务\Nand then, you can independently execute this transaction on each of the replicas,
Dialogue: 0,0:03:25.70,0:03:27.86,Default,,0,0,0,,它们都将在相同的状态下终止\Nand they will end up in the same state.
Dialogue: 0,0:03:28.36,0:03:30.28,Default,,0,0,0,,这一原则非常有效\NVery nice. Very nice principle.
Dialogue: 0,0:03:30.28,0:03:35.04,Default,,0,0,0,,区块链、分布式账本、智能合约等所有这些领域\NVery similar principle underlies blockchains, and distributed ledgers, 
Dialogue: 0,0:03:35.04,0:03:37.78,Default,,0,0,0,,都使用了类似的原则\Nand smart contracts, and all of this area.
Dialogue: 0,0:03:37.78,0:03:40.64,Default,,0,0,0,,你在区块链中得到的是一系列区块构成的链条\NWhat you have in a blockchain is a chain of blocks.
Dialogue: 0,0:03:40.64,0:03:43.62,Default,,0,0,0,,实际上 区块链条就是\NAnd this chain of blocks is actually exactly 
Dialogue: 0,0:03:43.62,0:03:48.04,Default,,0,0,0,,通过全序关系广播协议传递的一系列消息\Nthe sequence of messages delivered by a total order broadcast protocol.
Dialogue: 0,0:03:48.04,0:03:53.38,Default,,0,0,0,,系统应用一个共识机制来实现全序关系广播\NSo, there's a consensus mechanism around implementing this total order broadcast.
Dialogue: 0,0:03:53.38,0:04:00.04,Default,,0,0,0,,一旦有了全序关系广播 后面要做的只是按照特定的顺序\NBut once you've got it, it's just a sequence of transactions or updates or jobs 
Dialogue: 0,0:04:00.04,0:04:02.32,Default,,0,0,0,,执行一系列交易、更新或任务\Nthat need to be performed in a certain order.
Dialogue: 0,0:04:02.32,0:04:07.30,Default,,0,0,0,,每个副本将按照相同的顺序处理这些确定性的事务\NAnd each replica will process those deterministic transactions in the same order.
Dialogue: 0,0:04:07.30,0:04:09.30,Default,,0,0,0,,因此 它们都将在相同的状态下终止\NAnd therefore, they will end up in the same state.
Dialogue: 0,0:04:09.30,0:04:13.26,Default,,0,0,0,,区块链中的状态构成了一个账本\NAnd in this case, the state constitutes a ledger 
Dialogue: 0,0:04:13.26,0:04:16.78,Default,,0,0,0,,此账本告诉我们谁持有哪个货币\Nsaying who owns which coins, for example.
Dialogue: 0,0:04:16.78,0:04:20.02,Default,,0,0,0,,状态机复制的缺点\NNow, the downside of state machine replication 
Dialogue: 0,0:04:20.02,0:04:22.42,Default,,0,0,0,,就是全序关系广播的缺点\Nare the downsides of total order broadcast.
Dialogue: 0,0:04:22.42,0:04:26.36,Default,,0,0,0,,如果你还记得 我们在介绍全序关系广播时说过\NSo, if you remember when we were looking at total order broadcast, we said that 
Dialogue: 0,0:04:26.36,0:04:28.82,Default,,0,0,0,,当一个节点想广播一条消息时\Nwhen a node wants to broadcast a message,
Dialogue: 0,0:04:28.82,0:04:32.76,Default,,0,0,0,,它不能立刻将此条消息传递给自己\Nit cannot immediately deliver that message to itself.
Dialogue: 0,0:04:32.76,0:04:35.70,Default,,0,0,0,,它必须与其他节点协调好\NIt has to coordinate with the other nodes 
Dialogue: 0,0:04:36.04,0:04:40.88,Default,,0,0,0,,以决定各个副本传递消息的顺序\Nin order to decide the order in which the replicas are going to deliver the messages.
Dialogue: 0,0:04:40.88,0:04:43.24,Default,,0,0,0,,这一过程也被用在状态机复制中\NAnd the same applies here with state machine replication.
Dialogue: 0,0:04:43.24,0:04:46.44,Default,,0,0,0,,也就是说 副本不能立刻更新自己的状态\NSo, that means the replica cannot immediately update its own state.
Dialogue: 0,0:04:46.44,0:04:49.72,Default,,0,0,0,,它需要通过全序关系广播处理更新操作\NIt has to go through the total order broadcast process 
Dialogue: 0,0:04:49.72,0:04:56.24,Default,,0,0,0,,从而知道更新操作的执行顺序\Nin order to know the order in which these updates are going to get applied.
Dialogue: 0,0:04:56.24,0:04:59.34,Default,,0,0,0,,这也意味着我们需要使用全序关系广播协议\NAnd it does mean that we need a total order broadcast protocol.
Dialogue: 0,0:04:59.34,0:05:02.58,Default,,0,0,0,,我们将在下一节课学习如何实现全序关系广播\NWe will study that in the next lecture.
Dialogue: 0,0:05:02.58,0:05:10.14,Default,,0,0,0,,另一个全序关系广播原则应用在复制的例子是\NAnother example of how this principle of total order broadcast is used for replication is 
Dialogue: 0,0:05:10.14,0:05:12.94,Default,,0,0,0,,数据库的被动复制\Nin what is called passive replication for databases.
Dialogue: 0,0:05:12.94,0:05:15.38,Default,,0,0,0,,在这个例子中\NAnd so, what happens here is that 
Dialogue: 0,0:05:15.38,0:05:20.72,Default,,0,0,0,,你有一个主节点数据库和一个或多个从节点数据库\Nyou have got a leader database and one or more follower databases.
Dialogue: 0,0:05:20.72,0:05:23.86,Default,,0,0,0,,如果你还记得 我们在讲解全序关系广播时说过\NAnd if you remember what we said about total order broadcast,
Dialogue: 0,0:05:23.86,0:05:26.74,Default,,0,0,0,,有一种实现全序关系广播的方法是\None way that you can implement total order broadcast is 
Dialogue: 0,0:05:26.74,0:05:29.22,Default,,0,0,0,,指定一个节点作为主节点\Nby designating one node as the leader.
Dialogue: 0,0:05:29.22,0:05:32.48,Default,,0,0,0,,主节点将决定消息顺序\NAnd that leader is going to decide on an order of the messages,
Dialogue: 0,0:05:32.48,0:05:36.24,Default,,0,0,0,,随后 所有其他节点\Nand then, all of the other nodes are going to deliver the messages 
Dialogue: 0,0:05:36.24,0:05:39.02,Default,,0,0,0,,将按照主节点广播的顺序传递消息\Nin the order they were broadcast by the leader.
Dialogue: 0,0:05:39.02,0:05:42.32,Default,,0,0,0,,这也正是数据库复制中所发生的情况\NAnd this is exactly what happens in database replication.
Dialogue: 0,0:05:42.32,0:05:43.48,Default,,0,0,0,,在数据库复制中\NSo, in database replication, 
Dialogue: 0,0:05:43.48,0:05:48.44,Default,,0,0,0,,一个客户端向主节点请求执行某个事务\Nyou've got one client which requests the leader to execute some transaction.
Dialogue: 0,0:05:48.44,0:05:50.70,Default,,0,0,0,,可能另一个客户端\NAnd maybe another client 
Dialogue: 0,0:05:50.70,0:05:55.28,Default,,0,0,0,,也在同时请求主节点执行某个事务\Ncan currently request the leader to also execute some transaction.
Dialogue: 0,0:05:55.28,0:05:58.76,Default,,0,0,0,,主节点可能会并发执行这些事务\NAnd those transactions might execute concurrently on the leader.
Dialogue: 0,0:05:59.22,0:06:03.00,Default,,0,0,0,,我们一般要求 如果事务涉及修改数据库状态\NWe do have usually the requirement that only the leader can execute transactions 
Dialogue: 0,0:06:03.00,0:06:06.02,Default,,0,0,0,,则只有主节点才能执行此类事务\Nif those transactions are going to modify the database state.
Dialogue: 0,0:06:06.02,0:06:09.60,Default,,0,0,0,,可以在从节点上执行只读事务\NSo, any read-only transactions could execute on the followers,
Dialogue: 0,0:06:09.60,0:06:13.58,Default,,0,0,0,,但只有主节点可以执行读写事务\Nbut any read-write transactions have to execute on the leader.
Dialogue: 0,0:06:13.58,0:06:19.86,Default,,0,0,0,,虽然主节点会并发处理事务 但事务会按照全序关系提交\NNow, transactions may execute concurrently, but they will commit in some total order.
Dialogue: 0,0:06:19.86,0:06:22.68,Default,,0,0,0,,提交顺序在这里起到了非常重要的作用\NAnd this commit order is the crucial thing here,
Dialogue: 0,0:06:22.68,0:06:28.46,Default,,0,0,0,,因为当提交一个事务时 提交日志中会追加一条记录\Nbecause when a transaction commits, then a record is appended to the commit log,
Dialogue: 0,0:06:28.46,0:06:32.74,Default,,0,0,0,,此记录描述了事务修改了哪些数据\Nsaying what were data changes that were made by this transaction.
Dialogue: 0,0:06:32.74,0:06:38.28,Default,,0,0,0,,此提交记录会通过全序关系广播发送给所有从节点\NAnd this commit record is sent to all of the followers via total order broadcast.
Dialogue: 0,0:06:38.28,0:06:42.48,Default,,0,0,0,,随后 所有从节点也将应用提交的事务\NSo, then, all of the followers will apply the transaction commits,
Dialogue: 0,0:06:42.48,0:06:46.68,Default,,0,0,0,,按照提交顺序依次执行事务并修改数据\Nand the data changes from each transaction in the commit order.
Dialogue: 0,0:06:46.68,0:06:48.84,Default,,0,0,0,,这样一来 我们仍然沿用了相同的原则\NAnd so, again, we've got the same principle, 
Dialogue: 0,0:06:48.84,0:06:53.24,Default,,0,0,0,,所有主节点和所有从节点都按照相同的顺序执行提交的事务\Nall of the leader and all of the followers are applying the commits in the same order.
Dialogue: 0,0:06:53.24,0:06:55.94,Default,,0,0,0,,因此 它们会经历相同的状态转移顺序\NAnd so, they go through the same sequence of state transitions,
Dialogue: 0,0:06:55.94,0:07:01.94,Default,,0,0,0,,这里使用的原则与状态机复制的原则是相同的\Nagain, using the same principle as a state machine replication.
Dialogue: 0,0:07:01.94,0:07:05.46,Default,,0,0,0,,这就是全序关系广播的使用方法\NSo, that is using total order broadcast.
Dialogue: 0,0:07:05.46,0:07:10.24,Default,,0,0,0,,这显然是实现复制的一个好方法\NIt's clearly a good way of implementing replication.
Dialogue: 0,0:07:10.24,0:07:13.14,Default,,0,0,0,,我们还讨论过稍弱一些的广播类型\NWe also discussed weaker forms of broadcast.
Dialogue: 0,0:07:13.14,0:07:15.78,Default,,0,0,0,,我们讨论过因果关系广播、FIFO广播\NSo, we discussed causal broadcast, and FIFO broadcast, 
Dialogue: 0,0:07:15.78,0:07:18.66,Default,,0,0,0,,可靠广播、以及尽力广播\Nreliable broadcast, and best-effort broadcast.
Dialogue: 0,0:07:18.66,0:07:22.88,Default,,0,0,0,,我们能否使用这些广播类型实现复制呢？\NSo, can we use those as well for implementing replication?
Dialogue: 0,0:07:22.88,0:07:27.48,Default,,0,0,0,,答案是：可以实现 只是使用时要更小心一些\NAnd the answer is, yes, we can. It just requires a little bit more care.
Dialogue: 0,0:07:27.48,0:07:32.84,Default,,0,0,0,,这里我们需要用到交换律这一概念\NSo, one concept we need for this is commutativity.
Dialogue: 0,0:07:32.84,0:07:37.22,Default,,0,0,0,,我们称 如果可以按照任意顺序执行两个更新操作\NAnd so, we're going to say that two updates are commutative 
Dialogue: 0,0:07:37.22,0:07:39.48,Default,,0,0,0,,则称这两个更新操作满足交换律\Nif you can apply them in either order.
Dialogue: 0,0:07:39.48,0:07:44.28,Default,,0,0,0,,无论是先应用f再应用g、还是先应用g再应用f\NSo, either you apply first f, then g, or you apply first g, then f,
Dialogue: 0,0:07:44.28,0:07:50.18,Default,,0,0,0,,无论按照何种顺序执行这两个更新操作 最终的执行结果都是相同的\Nand the end result is the same, no matter in which order you apply these two updates.
Dialogue: 0,0:07:50.18,0:07:53.34,Default,,0,0,0,,很明显 并不是所有的更新操作都满足交换律\NNow, clearly, not all updates are commutative.
Dialogue: 0,0:07:53.34,0:07:56.86,Default,,0,0,0,,如果我们想让更新操作满足交换律\NWe have to specifically design the algorithm 
Dialogue: 0,0:07:56.86,0:08:00.04,Default,,0,0,0,,我们必须为更新操作设计专门的算法 使其满足交换律\Nfor updates to be commutative if we wanted to be commutative.
Dialogue: 0,0:08:00.04,0:08:05.98,Default,,0,0,0,,不过 确实有可能设计出满足交换律的更新操作\NBut it is possible to design updates in such a way that they are commutative.
Dialogue: 0,0:08:05.98,0:08:11.46,Default,,0,0,0,,如果我们能设计出满足交换律的更新操作 我们就可以使用因果关系广播\NAnd if we do that, then, for example, we can use causal broadcast.
Dialogue: 0,0:08:11.46,0:08:15.20,Default,,0,0,0,,当使用因果关系广播实现复制时\NSo, with causal broader broadcast, 
Dialogue: 0,0:08:15.20,0:08:19.16,Default,,0,0,0,,我们还要求更新过程是确定性的\Nwe also require that processing update is deterministic.
Dialogue: 0,0:08:19.16,0:08:24.26,Default,,0,0,0,,所有基于广播的复制模型都要求更新过程满足确定性\NThat is still a requirement of any of these broadcast-based replication models.
Dialogue: 0,0:08:25.12,0:08:31.50,Default,,0,0,0,,回忆一下 因果关系广播所能提供的顺序保证是\NBut then, remember that the order guaranteed provided by causal broadcast is 
Dialogue: 0,0:08:31.50,0:08:33.64,Default,,0,0,0,,如果一条消息在另一条消息之前发生\Nif one message happened before another, 
Dialogue: 0,0:08:33.64,0:08:37.04,Default,,0,0,0,,则这两条消息会按照此前发生顺序传递\Nthen those messages get delivered in their happens before order.
Dialogue: 0,0:08:37.04,0:08:40.46,Default,,0,0,0,,但两个并发消息可以按照任意顺序传递\NBut two concurrent messages might be delivered in either order.
Dialogue: 0,0:08:40.46,0:08:44.70,Default,,0,0,0,,因此 如果我们想要保证所有副本处于相同的终止状态\NAnd so, if we want to ensure that all of the replicas end up in the same state,
Dialogue: 0,0:08:44.70,0:08:49.40,Default,,0,0,0,,我们必须保证 对于任意两次并发更新操作\Nthen we must ensure that for any two updates that are concurrent,
Dialogue: 0,0:08:49.40,0:08:52.44,Default,,0,0,0,,其对应的状态更新函数必须满足交换律\Ntheir state update functions must commute.
Dialogue: 0,0:08:52.44,0:08:57.58,Default,,0,0,0,,如果满足这个条件 则意味着任意不满足交换律的状态更新操作\NAnd so, if we have that, then that means that any non-commutative state updates 
Dialogue: 0,0:08:57.58,0:09:01.66,Default,,0,0,0,,必须按照正确的顺序通过因果关系广播发送\Nwill be provided in the right order by causal broadcast,
Dialogue: 0,0:09:01.66,0:09:08.06,Default,,0,0,0,,任何可能会被因果关系广播重排序的更新操作必须满足交换律\Nand any updates that might be reordered by causal broadcast are commutative,
Dialogue: 0,0:09:08.06,0:09:12.66,Default,,0,0,0,,这样我们才能按照任意顺序执行这些更新操作 并得到相同的最终状态\Nand so, therefore, we can apply them in either order, and will end up in the same state.
Dialogue: 0,0:09:12.66,0:09:14.46,Default,,0,0,0,,我们可以进一步泛化对广播的要求\NNow, we can generalize this further,
Dialogue: 0,0:09:14.46,0:09:18.02,Default,,0,0,0,,可靠广播无法保证消息的传递顺序\Nand with reliable broadcasts, we have no ordering guarantees at all,
Dialogue: 0,0:09:18.02,0:09:23.62,Default,,0,0,0,,我们只能保证所有消息会恰好传递一次\Nwe just have the guarantee that every message is delivered exactly once.
Dialogue: 0,0:09:23.62,0:09:30.96,Default,,0,0,0,,这种情况下 我们必须要求所有的更新操作都满足交换律\NAnd so, in this case, we have to have all of the updates, they must commute,
Dialogue: 0,0:09:31.36,0:09:34.86,Default,,0,0,0,,因为广播协议无法提供任何顺序保证\Nbecause the broadcast protocol provides no ordering guarantees.
Dialogue: 0,0:09:34.86,0:09:36.10,Default,,0,0,0,,我们可以进一步弱化对广播的要求\NAnd we could go even weaker.
Dialogue: 0,0:09:36.10,0:09:38.42,Default,,0,0,0,,我们甚至可以使用尽力广播\NSo, we could even go to best-effort broadcast,
Dialogue: 0,0:09:38.42,0:09:41.54,Default,,0,0,0,,这种情况下 我们甚至无法保证\Nin which case, we're not even guaranteed 
Dialogue: 0,0:09:41.54,0:09:44.04,Default,,0,0,0,,一条特定的消息会被传递多少次\Nany particular number of deliveries for a certain message.
Dialogue: 0,0:09:44.04,0:09:47.10,Default,,0,0,0,,消息可能会丢失 也可能会被多次传递\NSo, a message might be lost, or it might be delivered multiple times.
Dialogue: 0,0:09:47.10,0:09:50.74,Default,,0,0,0,,这种情况下 状态更新函数必须能够容忍消息丢失\NSo, in this case, the state update function will have to tolerate message loss,
Dialogue: 0,0:09:50.74,0:09:52.06,Default,,0,0,0,,状态更新函数必须满足幂等性\Nand it will have to tolerate 
Dialogue: 0,0:09:52.06,0:09:55.40,Default,,0,0,0,,以容忍消息被多次传递\Nmessages being delivered multiple times through idempotence.
Dialogue: 0,0:09:55.40,0:09:59.60,Default,,0,0,0,,但你可以看到 所有不同的广播模型\NBut you can see that actually all these different models of broadcast,
Dialogue: 0,0:09:59.60,0:10:03.18,Default,,0,0,0,,都可以用于构建复制系统\Nwe can use in order to build replication systems.
Dialogue: 0,0:10:03.18,0:10:05.18,Default,,0,0,0,,这就是本节课的全部内容了\NSo, that's all for this lecture.
Dialogue: 0,0:10:05.18,0:10:08.52,Default,,0,0,0,,在下节课中 我们将会深入探讨一些细节\NIn the next lecture, we're going to drill into some more detail on
Dialogue: 0,0:10:08.52,0:10:12.86,Default,,0,0,0,,学习如何以一种可靠的方式实现全序关系广播\Nhow actually we implement this total order broadcast in a way that is reliable.
