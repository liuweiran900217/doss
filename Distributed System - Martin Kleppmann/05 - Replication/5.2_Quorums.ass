[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 5.2_Quorums.mp4
Video File: 5.2_Quorums.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 94
Active Line: 109
Video Position: 12138

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:02.24,0:00:06.32,Default,,0,0,0,,一般来说 我们使用复制的原因是希望系统变得更可靠\NThe reason we want replication is typically to make systems more reliable.
Dialogue: 0,0:00:06.32,0:00:09.60,Default,,0,0,0,,有各种各样的原因可能会使一个节点不可用\NSo, a node might be unavailable for all sorts of reasons.
Dialogue: 0,0:00:09.60,0:00:10.40,Default,,0,0,0,,节点可能会崩溃\NIt might crash.
Dialogue: 0,0:00:10.40,0:00:12.12,Default,,0,0,0,,节点可能会遇到硬件问题\NIt might have a hardware problem.
Dialogue: 0,0:00:12.12,0:00:15.14,Default,,0,0,0,,节点可能会因为例行维护而重启\NIt might be just rebooting due to routine maintenance.
Dialogue: 0,0:00:15.14,0:00:21.06,Default,,0,0,0,,我们假设一个节点在任何给定的时刻不可用的概率为p\NLet's assume just there's some probability p that a node is unavailable at any given time.
Dialogue: 0,0:00:21.06,0:00:25.10,Default,,0,0,0,,我们进一步假定 一个节点是否不可用\NAnd let's also assume that whether one node is unavailable
Dialogue: 0,0:00:25.10,0:00:27.92,Default,,0,0,0,,与另一个节点是否不可用 这两个事件是相互独立的\Nis independent from whether another node is unavailable.
Dialogue: 0,0:00:27.92,0:00:31.40,Default,,0,0,0,,也就是说 我们假设故障之间是不相关的\NSo, we're going to assume that faults are not correlated.
Dialogue: 0,0:00:31.40,0:00:32.78,Default,,0,0,0,,这个假设实际上不正确\NThis is not actually true.
Dialogue: 0,0:00:32.78,0:00:34.48,Default,,0,0,0,,有研究已经表明\NThere have been studies that have shown that
Dialogue: 0,0:00:34.48,0:00:37.52,Default,,0,0,0,,实际中 节点故障存在相关性\Nactually, faults do tend to be correlated in practice.
Dialogue: 0,0:00:37.52,0:00:40.54,Default,,0,0,0,,但这里我们只是为了做一些粗略的估计\NBut just for the purposes of some rough estimation,
Dialogue: 0,0:00:40.54,0:00:44.24,Default,,0,0,0,,我们现在假设故障之间是相互独立的\Nit's OK for now to assume that they are actually independent.
Dialogue: 0,0:00:44.24,0:00:49.48,Default,,0,0,0,,现在 p是一个节点出现故障的概率\NSo now, if p is the probability of any one node being faulty,
Dialogue: 0,0:00:49.48,0:00:53.82,Default,,0,0,0,,这意味着所有n个副本都出现故障的概率是p^n\Nthat means the probability of all n replicas being faulty is p^n.
Dialogue: 0,0:00:53.82,0:00:57.14,Default,,0,0,0,,我们也可以算出一个或多个节点出现故障的概率\NAnd we can work out what is the probability of one or more being faulty.
Dialogue: 0,0:00:57.14,0:00:58.78,Default,,0,0,0,,我们可以制作出这样一个表格\NAnd we can make a little table.
Dialogue: 0,0:00:58.78,0:01:00.42,Default,,0,0,0,,这个表格告诉我们\NAnd what this table shows here is
Dialogue: 0,0:01:00.42,0:01:04.72,Default,,0,0,0,,如果我们查看至少一个节点出现故障的这一列\Nif you look at the column for at least one node being faulty,
Dialogue: 0,0:01:05.54,0:01:07.94,Default,,0,0,0,,随着副本数量的增加\Nas you increase the number of replicas,
Dialogue: 0,0:01:07.94,0:01:13.32,Default,,0,0,0,,我们几乎可以肯定 在任意给定时刻 至少有一个节点会出现故障\Nit becomes almost certain that at least one of them is faulty at any given time.
Dialogue: 0,0:01:13.32,0:01:18.76,Default,,0,0,0,,从这个角度看 系统的可靠性会随着副本数量的增加而降低\NSo, in that sense, as you add replicas, the system becomes less reliable,
Dialogue: 0,0:01:18.76,0:01:25.14,Default,,0,0,0,,因为任意节点都有可能出现故障 如果你增加了太多的副本\Nbecause given anyone has a chance of failing, as you have lots of replicas,
Dialogue: 0,0:01:25.14,0:01:27.84,Default,,0,0,0,,则在任意时刻 总会有一个副本出现故障\Nthere'll always be one that has failed at any moment.
Dialogue: 0,0:01:27.84,0:01:31.86,Default,,0,0,0,,然而 如果我们考察所有副本全部出现故障的概率\NHowever, if we take the probability of all of them being faulty,
Dialogue: 0,0:01:31.86,0:01:36.70,Default,,0,0,0,,此概率会随着副本数量的增加而指数级降低\Nthis probability decreases exponentially as you increase the number of replicas.
Dialogue: 0,0:01:36.70,0:01:39.68,Default,,0,0,0,,即使你不考虑所有副本都出现故障的概率\NAnd even if you consider not the probability of all of them failing,
Dialogue: 0,0:01:39.68,0:01:43.74,Default,,0,0,0,,只考虑一半副本出现故障的概率\Nbut just the probability of half of the replicas failing,
Dialogue: 0,0:01:43.74,0:01:48.36,Default,,0,0,0,,此概率也会随着副本数量的增加而指数级降低\Nthis probability also decreases exponentially with the number of replicas.
Dialogue: 0,0:01:48.36,0:01:51.54,Default,,0,0,0,,这就是为什么我们可以实现容错的原因\NSo, this is why we can achieve fault tolerance,
Dialogue: 0,0:01:51.54,0:01:55.66,Default,,0,0,0,,因为我们可以允许一部分节点不可用\Nbecause it's OK if some of the nodes are unavailable,
Dialogue: 0,0:01:55.66,0:01:57.20,Default,,0,0,0,,我们可以允许一部分副本不可用\Nsome of the replicas are unavailable,
Dialogue: 0,0:01:57.20,0:02:02.04,Default,,0,0,0,,我们只需要保证当至少大多数副本可用时\Nwe just have to make sure that given at least most of the replicas are available,
Dialogue: 0,0:02:02.04,0:02:03.76,Default,,0,0,0,,系统仍然可以继续运作\Nthen the system continues working,
Dialogue: 0,0:02:03.76,0:02:07.64,Default,,0,0,0,,这样我们就可以获得非常高的可靠性了\Nand then we can actually achieve very high reliability.
Dialogue: 0,0:02:07.64,0:02:10.92,Default,,0,0,0,,我们来看看我们希望容错复制系统\NSo, let's look at one particular property that we might want
Dialogue: 0,0:02:10.92,0:02:13.68,Default,,0,0,0,,可以满足的一个特定性质\Nin a fault-tolerant replicated system.
Dialogue: 0,0:02:13.68,0:02:16.40,Default,,0,0,0,,这个性质叫写后读一致性\NAnd that is called read-after-write consistency.
Dialogue: 0,0:02:16.40,0:02:17.74,Default,,0,0,0,,写后读一致性的意思是\NSo, what happens here is that
Dialogue: 0,0:02:17.74,0:02:21.98,Default,,0,0,0,,客户端先写入某个数据 随后还能再次读取相同的数据\Na client first writes some data, and then it reads the same data back again.
Dialogue: 0,0:02:21.98,0:02:23.72,Default,,0,0,0,,你可能很自然的期望\NAnd you would naturally expect that
Dialogue: 0,0:02:23.72,0:02:27.64,Default,,0,0,0,,客户端随后读取到的数据和之前写入的数据是一样的\Nthat client to just to then see the data that it has just written.
Dialogue: 0,0:02:27.64,0:02:32.34,Default,,0,0,0,,这里 客户端想要设置键x的值为v_1\NSo, here, client wants to set the key x to the value v_1.
Dialogue: 0,0:02:32.34,0:02:35.74,Default,,0,0,0,,我们在此操作上附加一个时间戳t_1\NAnd we attach a timestamp of t_1 to that operation.
Dialogue: 0,0:02:35.74,0:02:40.02,Default,,0,0,0,,客户端将更新操作发送给两个副本数据库A和B\NIt sends that update to both replicas of the database A and B.
Dialogue: 0,0:02:40.02,0:02:45.62,Default,,0,0,0,,副本B收到并处理更新操作\NThe replica B receives that update and processes it
Dialogue: 0,0:02:45.62,0:02:51.64,Default,,0,0,0,,而副本A不可用 因此A没有处理更新操作\Nwhereas replica A is unavailable, and so the update is not processed by A.
Dialogue: 0,0:02:51.64,0:02:55.84,Default,,0,0,0,,随后 客户端希望再次读取x所关联的值\NThen, subsequently, the client goes and wants to read x again.
Dialogue: 0,0:02:55.84,0:02:58.56,Default,,0,0,0,,但因为某种原因 情况发生了逆转\NBut for some reason, now the things have flipped around.
Dialogue: 0,0:02:58.56,0:03:01.54,Default,,0,0,0,,现在 A可用 而B不可用\NAnd now, A is available, but B is not available.
Dialogue: 0,0:03:01.54,0:03:06.18,Default,,0,0,0,,因此 客户端从A处得到的响应\NAnd so, now, the response that the client gets back from A
Dialogue: 0,0:03:06.18,0:03:09.08,Default,,0,0,0,,与客户端之前写入的值v_1不相等\Ndoes not reflect that value v_1 that has been written.
Dialogue: 0,0:03:09.08,0:03:12.20,Default,,0,0,0,,客户端得到的响应是写入v_1之前\NSo, the response is going to be some earlier value v_0
Dialogue: 0,0:03:12.60,0:03:16.72,Default,,0,0,0,,副本稍早时持有的值v_0\Nthat the replicas had before this scenario here started.
Dialogue: 0,0:03:16.72,0:03:20.48,Default,,0,0,0,,这种情况违反了写后读一致性\NSo, in this case, we have violated read-after-write consistency,
Dialogue: 0,0:03:21.06,0:03:22.14,Default,,0,0,0,,这有些糟糕\Nwhich is kind of unfortunate,
Dialogue: 0,0:03:22.14,0:03:26.74,Default,,0,0,0,,因为如果你写入某个数据 结果数据丢失了 过了一会数据又出现了\Nbecause it's very confusing if you write some data, and then the data disappears,
Dialogue: 0,0:03:26.74,0:03:29.92,Default,,0,0,0,,这种现象会非常令人困惑\Nand then, sometime later, the data reappears again.
Dialogue: 0,0:03:29.92,0:03:34.70,Default,,0,0,0,,这种情况下 我们可以做到的是\NNow, what we could do here in this case is that
Dialogue: 0,0:03:34.70,0:03:37.60,Default,,0,0,0,,必须在两个副本中完成读操作和写操作\Nthe read and write have to go to both replicas.
Dialogue: 0,0:03:37.60,0:03:41.32,Default,,0,0,0,,这样我们就可以保证不会遇到上述交叉读写问题\NAnd so, that way we would ensure that we don't get this crossover problem
Dialogue: 0,0:03:41.32,0:03:45.62,Default,,0,0,0,,即只有一个副本更新了数据 而我们又从另一个副本读取数据\Nwhere only one of the replicas has seen the update and we read from the other one.
Dialogue: 0,0:03:45.62,0:03:48.98,Default,,0,0,0,,但现在 如果我们要求两个副本必须都完成读操作和写操作\NBut now, if we require a read or write to go to both replicas,
Dialogue: 0,0:03:48.98,0:03:50.90,Default,,0,0,0,,那么系统就无法满足容错性\Nthen the system is not fault-tolerant,
Dialogue: 0,0:03:50.90,0:03:54.54,Default,,0,0,0,,因为只要其中一个副本不可用\Nbecause if just one of the two replicas becomes unavailable,
Dialogue: 0,0:03:54.54,0:03:57.48,Default,,0,0,0,,我们就无法处理所有读操作和写操作了\Nthen we can't process reads or writes anymore.
Dialogue: 0,0:03:57.48,0:04:01.38,Default,,0,0,0,,我们可以利用quorum来解决这个问题\NSo, we can solve this problem using something called a quorum.
Dialogue: 0,0:04:01.38,0:04:06.00,Default,,0,0,0,,在这个例子中 我们的做法是使用一个3选2的quorum\NAnd what we do here is here I've got an example quorum of 2-out-of-3.
Dialogue: 0,0:04:06.00,0:04:12.64,Default,,0,0,0,,当我们想执行写操作时 客户端向所有3个副本发送写请求\NAnd so, when we want to make a write, the client sends its request to all 3 replicas.
Dialogue: 0,0:04:12.64,0:04:14.82,Default,,0,0,0,,我们假设这里有3个副本\NWe're going to assume here there are 3 replicas.
Dialogue: 0,0:04:14.82,0:04:20.68,Default,,0,0,0,,由于某种原因 请求只到达了3个副本中的2个副本\NAnd for some reason, the request reaches 2-out-of-3 of these 2 replicas.
Dialogue: 0,0:04:20.68,0:04:23.82,Default,,0,0,0,,请求到达了B和C 但是没有到达A\NSo, the request reaches B and C, but not A.
Dialogue: 0,0:04:23.82,0:04:26.98,Default,,0,0,0,,随后 B和C响应客户端说\NAnd then, B and C are going to respond to the client, saying
Dialogue: 0,0:04:26.98,0:04:31.84,Default,,0,0,0,,“好的 我收到你更新这一特定键x的请求了”\N“OK, yes, I got your request to update this particular key x.”
Dialogue: 0,0:04:31.84,0:04:37.52,Default,,0,0,0,,一旦收到了两个正面响应 客户端就开心了\NAnd once the client has collected two positive responses, then it's happy.
Dialogue: 0,0:04:37.52,0:04:41.98,Default,,0,0,0,,请求没有成功传输到A处也没问题\NSo, the fact that the request didn't get through to A is OK.
Dialogue: 0,0:04:41.98,0:04:46.92,Default,,0,0,0,,可能A不可用 但只要B和C响应了请求就没问题\NSo, maybe A is unavailable, as long as B and C still respond, that's still fine.
Dialogue: 0,0:04:46.92,0:04:52.44,Default,,0,0,0,,接下来 客户端要执行读操作 它再次向3个副本发送读请求\NNow, second, the client goes to read, and it sends its read again to all 3 replicas.
Dialogue: 0,0:04:52.44,0:04:55.34,Default,,0,0,0,,像之前一样 只有2个副本收到了请求\NAs before, only 2 of them get it.
Dialogue: 0,0:04:55.34,0:04:57.74,Default,,0,0,0,,此时 由于某种原因\NAnd so, in this case, for some reason,
Dialogue: 0,0:04:57.74,0:05:02.44,Default,,0,0,0,,发送给C的读请求未传输成功 但发送给A和B的读请求传输成功\Nthe read to C doesn't go through, but the reads to A and B do go through.
Dialogue: 0,0:05:02.44,0:05:06.82,Default,,0,0,0,,这种情况下 客户端将收到来自A和B的响应\NAnd so, in this case, now, the client will receive responses from A and B.
Dialogue: 0,0:05:06.82,0:05:11.54,Default,,0,0,0,,客户端将从B得到期望的正确响应 因为B看到了写请求\NIt will get the correct response that was expecting from B, because B has seen the write.
Dialogue: 0,0:05:11.54,0:05:15.84,Default,,0,0,0,,客户端将从A得到过期的响应 因为A没有看到写请求\NIt will get an outdated response from A, because A didn't get the write.
Dialogue: 0,0:05:15.84,0:05:21.50,Default,,0,0,0,,但客户端至少可以从一个响应中得到更新值\NBut at least one of the responses that the client got back has the updated value.
Dialogue: 0,0:05:21.50,0:05:24.98,Default,,0,0,0,,现在 客户端可以通过时间戳t_0和t_1\NAnd so, now, the client can use the timestamps t_0 and t_1
Dialogue: 0,0:05:24.98,0:05:27.14,Default,,0,0,0,,得知哪个值才是最近更新的\Nto figure out which is the more recent update.
Dialogue: 0,0:05:27.14,0:05:30.66,Default,,0,0,0,,这允许客户端知道\NAnd this now allows the client to know
Dialogue: 0,0:05:31.26,0:05:34.48,Default,,0,0,0,,给应用回复的正确数据应该是什么\Nwhat the correct response should be that it returns to the application.
Dialogue: 0,0:05:34.48,0:05:38.36,Default,,0,0,0,,应用心满意足 因为现在满足写后读一致性了\NAnd the application is happy, because it has read-after-write consistency.
Dialogue: 0,0:05:38.36,0:05:41.68,Default,,0,0,0,,我们到底要怎么做才能实现这个目标呢？\NSo, what do we have to do exactly to achieve this?
Dialogue: 0,0:05:41.68,0:05:43.54,Default,,0,0,0,,我们使用quorum\NWe use quorums.
Dialogue: 0,0:05:43.54,0:05:48.34,Default,,0,0,0,,当你想向一定数量的副本执行写操作时\NAnd whenever you want to make a write to some number of replicas,
Dialogue: 0,0:05:48.34,0:05:50.38,Default,,0,0,0,,仅当至少收到来自w个副本的确认时\Nthe write will be considered successful
Dialogue: 0,0:05:50.38,0:05:55.68,Default,,0,0,0,,你才认为写入操作成功执行完毕\Nas long as it has been acknowledged by at least w replicas.
Dialogue: 0,0:05:55.68,0:05:58.00,Default,,0,0,0,,这就是quorum写\NSo, this is our write quorum.
Dialogue: 0,0:05:58.00,0:06:04.56,Default,,0,0,0,,随后 当你想读数据时 你需要至少收到来自r个副本的确认\NAnd then, when you read, if you get a response back from at least r replicas,
Dialogue: 0,0:06:04.56,0:06:08.50,Default,,0,0,0,,现在 我们得到了算法的两个参数w和r\Nso now, we have w and r as our two parameters of this algorithm,
Dialogue: 0,0:06:08.50,0:06:10.32,Default,,0,0,0,,我们要求\Nand we require that
Dialogue: 0,0:06:10.32,0:06:15.34,Default,,0,0,0,,w和r的和要严格大于系统中的副本数量\Nthe sum of w and r is strictly greater than the number of replicas in the system.
Dialogue: 0,0:06:15.34,0:06:19.66,Default,,0,0,0,,在我们的例子中 w等于2、r等于2、n等于3\NSo, in our example, here w was 2, r was 2, and n was 3.
Dialogue: 0,0:06:19.66,0:06:21.94,Default,,0,0,0,,而2+2>3\NSo, 2+2>3.
Dialogue: 0,0:06:21.94,0:06:27.90,Default,,0,0,0,,因此 这种情况下 我们可以保证读到的值一定是之前写入的值\NAnd so, in this case, we can guarantee that the read will see the previously written value,
Dialogue: 0,0:06:27.90,0:06:32.46,Default,,0,0,0,,或者读到的值是其他客户端通过并发写入覆盖后的值\Nor maybe it was concurrently overwritten by another client,
Dialogue: 0,0:06:32.46,0:06:34.62,Default,,0,0,0,,但读到的一定是最新的值\Nbut it will see an up-to-date value,
Dialogue: 0,0:06:34.62,0:06:40.22,Default,,0,0,0,,如果r+w≤n\Nwhereas if this r+w≤n,
Dialogue: 0,0:06:40.22,0:06:44.60,Default,,0,0,0,,那我们有可能无法读到我们期望的值\Nit could happen that we don't get the value back that we were expecting.
Dialogue: 0,0:06:44.60,0:06:47.16,Default,,0,0,0,,这里的思想是\NSo, the idea here is that
Dialogue: 0,0:06:47.16,0:06:50.22,Default,,0,0,0,,写操作会在节点的某个子集下完成\Nthe write goes to some subset of nodes,
Dialogue: 0,0:06:50.22,0:06:52.58,Default,,0,0,0,,读操作会在节点的某个子集下完成\Nthe read goes to some subset of nodes,
Dialogue: 0,0:06:52.58,0:06:55.54,Default,,0,0,0,,我们希望两个子集有重叠\Nand we want those two subsets to overlap.
Dialogue: 0,0:06:55.54,0:06:59.86,Default,,0,0,0,,如果我们有r+w>n 满足quorum条件\NAnd we can guarantee that they will overlap in at least one replica
Dialogue: 0,0:06:59.86,0:07:05.44,Default,,0,0,0,,我们就可以保证两个子集中至少包含1个重叠副本\Nif we have this r+w>n, this quorum condition.
Dialogue: 0,0:07:06.32,0:07:08.70,Default,,0,0,0,,另一种理解方法是\NAnother way of putting this is that
Dialogue: 0,0:07:08.70,0:07:15.64,Default,,0,0,0,,我们有两个子集 这两个节点子集必须有非空交集\Nwe have these two subsets, and subsets of nodes have to have a non-empty intersection.
Dialogue: 0,0:07:15.64,0:07:18.08,Default,,0,0,0,,例如 如果我们有5个节点\NSo, for example, if we have 5 nodes,
Dialogue: 0,0:07:18.08,0:07:22.00,Default,,0,0,0,,我们要求写quorum为3、读quorum为3\Nwe could require a write quorum of 3 and a read quorum of 3,
Dialogue: 0,0:07:22.00,0:07:23.90,Default,,0,0,0,,这样就满足了quorum条件\Nthat would satisfy this condition.
Dialogue: 0,0:07:23.90,0:07:29.56,Default,,0,0,0,,这种情况下 两个节点子集总能保证\NAnd in this case, those two subsets of nodes are always guaranteed
Dialogue: 0,0:07:29.56,0:07:32.42,Default,,0,0,0,,至少包含1个公共节点\Nto have at least 1 element in common.
Dialogue: 0,0:07:32.42,0:07:35.38,Default,,0,0,0,,两个子集总包含非空交集\NSo, they will have a non-empty intersection.
Dialogue: 0,0:07:35.38,0:07:40.10,Default,,0,0,0,,构建quorum的常见方法叫多半quorum\NOne common way of constructing these quorums is what are called majority quorums,
Dialogue: 0,0:07:40.10,0:07:44.48,Default,,0,0,0,,我们一般假设存在奇数个节点\Nwhere we're going to assume that we have an odd number of nodes,
Dialogue: 0,0:07:44.48,0:07:48.58,Default,,0,0,0,,只要读quorum和写quorum\Nand as long as the read quorum and the write quorum
Dialogue: 0,0:07:48.58,0:07:53.16,Default,,0,0,0,,都严格大于节点数量的一半 就满足quorum条件了\Nare strictly more than half of the number of nodes, then it's fine.
Dialogue: 0,0:07:53.16,0:08:00.08,Default,,0,0,0,,即要求3选2、5选3、7选4 以此类推\NSo, that means we require 2-out-of-3, we require 3-out-of-5, 4-out-of-7, and so on.
Dialogue: 0,0:08:00.08,0:08:01.70,Default,,0,0,0,,这意味着\NAnd this means now that
Dialogue: 0,0:08:01.70,0:08:03.72,Default,,0,0,0,,在3选2情况下\Nin a 2-out-of-3 case,
Dialogue: 0,0:08:03.72,0:08:08.28,Default,,0,0,0,,只要其他两个节点可以响应 我们就能容忍1个节点不可用\Nwe can tolerate 1 node being unavailable as long as the other 2 respond.
Dialogue: 0,0:08:08.28,0:08:10.14,Default,,0,0,0,,在5选3情况下\NIn a 3-out-of-5 case,
Dialogue: 0,0:08:10.14,0:08:15.52,Default,,0,0,0,,只要剩余的3个节点可以响应 我们就能容忍2个节点不可用\Nwe can tolerate 2 replicas being unavailable as long as the 3 remaining ones respond,
Dialogue: 0,0:08:15.52,0:08:16.70,Default,,0,0,0,,以此类推\Nand so on.
Dialogue: 0,0:08:16.70,0:08:20.24,Default,,0,0,0,,这就是与quorum相关的全部内容了\NSo, this is all the quorums are about really.
Dialogue: 0,0:08:20.24,0:08:22.82,Default,,0,0,0,,我们讲完了quorum读和quorum写\NNow that we've done these quorum reads and writes,
Dialogue: 0,0:08:23.48,0:08:24.98,Default,,0,0,0,,我们还可以做的一件事是\None thing that we can do is
Dialogue: 0,0:08:24.98,0:08:30.70,Default,,0,0,0,,客户端可以帮助这些不同的副本再次回到同步状态\Nfor the client can help get those different replicas back in sync with each other again.
Dialogue: 0,0:08:30.70,0:08:36.16,Default,,0,0,0,,在这个例子中 客户端从A收到了过期值\NSo, in this case, here the client received an outdated value from A,
Dialogue: 0,0:08:36.16,0:08:38.76,Default,,0,0,0,,客户端从B收到了最新值\Nand it received the up-to-date value from B,
Dialogue: 0,0:08:38.76,0:08:40.98,Default,,0,0,0,,客户端没有收到C的响应\Nand it didn't receive anything at all from C.
Dialogue: 0,0:08:40.98,0:08:43.58,Default,,0,0,0,,客户端现在已经知道\NAnd so, the client already knows now that
Dialogue: 0,0:08:43.58,0:08:46.84,Default,,0,0,0,,A、B和C的状态是不一致的\NA and B and C are inconsistent with each other.
Dialogue: 0,0:08:46.84,0:08:50.38,Default,,0,0,0,,此时 客户端可以帮忙解决不一致的问题\NAnd so, the client can help clean the situation up
Dialogue: 0,0:08:50.38,0:08:53.56,Default,,0,0,0,,方法是把更新值发送回A和C\Nby actually sending the update back to A and C.
Dialogue: 0,0:08:53.56,0:08:54.84,Default,,0,0,0,,C可能不需要获得更新值\NSo, C might not need it,
Dialogue: 0,0:08:54.84,0:08:59.66,Default,,0,0,0,,因为C可能已经得到了更新值 只是没有响应问询\Nbecause it might be that C actually has the up-to-date value, but it just didn't respond.
Dialogue: 0,0:08:59.66,0:09:01.56,Default,,0,0,0,,再发送一次更新值也不会带来什么危害\NThere's no harm in sending it again.
Dialogue: 0,0:09:01.56,0:09:04.34,Default,,0,0,0,,我们确实希望能给A发送更新值\NAnd certainly, we want to send the update to A
Dialogue: 0,0:09:04.34,0:09:08.36,Default,,0,0,0,,使A和B都可以拥有更新值v_1\Nso that now A and B both have the updated value v_1.
Dialogue: 0,0:09:08.36,0:09:10.82,Default,,0,0,0,,请注意 我们这里使用的是原始操作的时间戳\NSo, notice that we use the original timestamp here,
Dialogue: 0,0:09:10.82,0:09:14.88,Default,,0,0,0,,因为这是数据检索操作 而不是一个新的集合操作\Nbecause this is effectively just a retrieve, this is not a new set operation.
Dialogue: 0,0:09:14.88,0:09:18.28,Default,,0,0,0,,因此 使用原始操作的时间戳才是正确的\NAnd therefore, it's correct to use the right timestamp,
Dialogue: 0,0:09:18.28,0:09:23.22,Default,,0,0,0,,客户端可以帮助副本传播正确的数据取值\Nand the client can thus help propagate the values between the replicas.
Dialogue: 0,0:09:23.22,0:09:25.74,Default,,0,0,0,,我们前面讨论的反熵\NSo, we have the anti-entropy that we discussed earlier
Dialogue: 0,0:09:25.74,0:09:28.66,Default,,0,0,0,,是一种让副本恢复到同步状态的机制\Nas one mechanism for the replicas to get back in sync.
Dialogue: 0,0:09:28.66,0:09:30.52,Default,,0,0,0,,这里介绍的读修复过程\NAnd this process here, read repair,
Dialogue: 0,0:09:30.52,0:09:34.98,Default,,0,0,0,,是另一种帮助副本恢复到同步状态的方法\Nis another way that helps the replicas get back in sync with each other.
