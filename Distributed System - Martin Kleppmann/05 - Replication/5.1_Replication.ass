[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 5.1_Replication.mp4
Video File: 5.1_Replication.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.312500
Scroll Position: 261
Active Line: 272
Video Position: 30760

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.28,0:00:03.98,Default,,0,0,0,,欢迎来到分布式系统的第5课\NWelcome to distributed systems lecture 5.
Dialogue: 0,0:00:03.98,0:00:06.44,Default,,0,0,0,,今天 我们将讨论复制\NToday, we will be talking about replication.
Dialogue: 0,0:00:06.44,0:00:08.52,Default,,0,0,0,,简单来说 复制的意思是\NSo, replication simply means
Dialogue: 0,0:00:08.52,0:00:12.92,Default,,0,0,0,,让分布式系统中的多个节点持有相同数据的拷贝\Nhaving a copy of the same data on multiple nodes in the distributed system.
Dialogue: 0,0:00:12.92,0:00:14.74,Default,,0,0,0,,复制的应用十分广泛\NReplication is very widely used.
Dialogue: 0,0:00:14.74,0:00:20.94,Default,,0,0,0,,举例来说 大多数分布式系统将复制作为正常启动的一部分\NSo, for example, many distributed databases use replication as part of their normal setup.
Dialogue: 0,0:00:21.54,0:00:23.18,Default,,0,0,0,,很多分布式文件系统\NMany distributed file systems
Dialogue: 0,0:00:23.18,0:00:26.30,Default,,0,0,0,,允许你在多个不同的节点上创建相同文件的拷贝\Nallow you to have a copy of some files on multiple different nodes.
Dialogue: 0,0:00:26.30,0:00:30.14,Default,,0,0,0,,很多缓存系统本质上就是一种复制\NMany caching systems are essentially forms of replication.
Dialogue: 0,0:00:30.14,0:00:35.98,Default,,0,0,0,,我们将讨论适用于所有这类系统的复制算法\NAnd we're going to be talking about algorithms that fit for all of those types of systems.
Dialogue: 0,0:00:35.98,0:00:41.24,Default,,0,0,0,,在分布式系统中 我们把所有持有拷贝数据的节点称为副本\NNow, in a distributed system, any node that has got a copy of the data is called a replica.
Dialogue: 0,0:00:41.24,0:00:46.42,Default,,0,0,0,,有很多原因导致系统需要复制\NAnd there are several reasons why you might want replication in a system.
Dialogue: 0,0:00:46.82,0:00:48.96,Default,,0,0,0,,其中一个重要的原因是\NThe most important one of which is that
Dialogue: 0,0:00:48.96,0:00:52.58,Default,,0,0,0,,如果有些副本由于某种原因无法访问\Nif some of the replicas are inaccessible for some reason,
Dialogue: 0,0:00:52.58,0:00:55.48,Default,,0,0,0,,你仍然可以访问其他副本 获取数据的另一份拷贝\Nyou've still got the other ones and the other copies of the data,
Dialogue: 0,0:00:55.48,0:00:58.72,Default,,0,0,0,,从而仍然可以响应用户的请求\Nyou can still use to serve user requests.
Dialogue: 0,0:00:58.72,0:01:01.80,Default,,0,0,0,,有很多不同的原因\NAnd so, there are quite a few different reasons
Dialogue: 0,0:01:01.80,0:01:06.26,Default,,0,0,0,,会导致副本有时不可访问\Nwhy a replica might be inaccessible from time to time.
Dialogue: 0,0:01:06.50,0:01:08.80,Default,,0,0,0,,可能是软件问题导致副本崩溃\NThere might be a software problem causing it to crash.
Dialogue: 0,0:01:08.80,0:01:12.46,Default,,0,0,0,,可能是硬件问题导致副本停止工作\NThere might be a hardware problem causing it to just stop working.
Dialogue: 0,0:01:13.20,0:01:16.70,Default,,0,0,0,,可能是网络问题 系统可能出现了网络分区\NThere might be a network problem, which means you might have a network partition,
Dialogue: 0,0:01:16.70,0:01:20.46,Default,,0,0,0,,你可能可以和一部分副本通信 但无法和另一部分副本通信\Nso, you might be able to communicate with some of the replicas but not with others,
Dialogue: 0,0:01:20.46,0:01:24.74,Default,,0,0,0,,尤其是如果副本分布在不同的位置时\Nespecially if the replicas are distributed across different locations,
Dialogue: 0,0:01:24.74,0:01:26.94,Default,,0,0,0,,你可能可以与本地副本通信\Nyou might be able to talk to your local replica,
Dialogue: 0,0:01:26.94,0:01:30.68,Default,,0,0,0,,但不能访问远程副本\Nbut not a replica that is somewhere remotely.
Dialogue: 0,0:01:30.68,0:01:33.88,Default,,0,0,0,,另一个需要复制的原因是\NAnd another reason why you might want replication is
Dialogue: 0,0:01:33.88,0:01:37.70,Default,,0,0,0,,你可能会故意使节点有时变得不可访问\Nyou might deliberately make nodes inaccessible from time to time.
Dialogue: 0,0:01:37.70,0:01:42.44,Default,,0,0,0,,例如 你可能决定重启节点 以安装软件更新\NFor example, you might choose to reboot a node in order to install software updates.
Dialogue: 0,0:01:42.44,0:01:44.50,Default,,0,0,0,,当此计算机在重启时\NAnd while that computer is rebooting,
Dialogue: 0,0:01:44.50,0:01:48.34,Default,,0,0,0,,节点便无法处理任何用户请求、无法处理任何消息\Nit can't be processing any user requests or any messages.
Dialogue: 0,0:01:48.34,0:01:53.10,Default,,0,0,0,,该节点在此期间是不可用的\NAnd so, during that time, that node is unavailable.
Dialogue: 0,0:01:53.10,0:01:57.80,Default,,0,0,0,,我们想要的是服务作为一个整体来看 例如数据库作为一个整体来看\NAnd really what we want is that a service as a whole, of a database, for example,
Dialogue: 0,0:01:57.80,0:02:01.28,Default,,0,0,0,,即使一些节点不可用 整体服务仍然可以运作\Nit continues working even if some of the nodes are unavailable.
Dialogue: 0,0:02:01.28,0:02:04.48,Default,,0,0,0,,复制就是一种\NAnd replication is one of the mechanisms we have
Dialogue: 0,0:02:04.48,0:02:08.00,Default,,0,0,0,,可以为我们提供容错能力的机制\Nwhich allows us to provide that sort of fault tolerance,
Dialogue: 0,0:02:08.00,0:02:11.42,Default,,0,0,0,,如果你需要对系统进行维护 那么复制也会非常有用\Nwhich is very useful, especially if you need to do maintenance of the system,
Dialogue: 0,0:02:11.42,0:02:14.80,Default,,0,0,0,,因为有了复制后 你就可以一次重启一个节点\Nbecause it means you can reboot one node at a time,
Dialogue: 0,0:02:14.80,0:02:17.42,Default,,0,0,0,,只要你不在同一时刻关闭所有节点\Nas long as you're not turning them all off at the same time,
Dialogue: 0,0:02:17.42,0:02:19.90,Default,,0,0,0,,只要你一次只重启一个节点\Nas long as you just reboot one at a time,
Dialogue: 0,0:02:20.52,0:02:25.22,Default,,0,0,0,,则剩余的节点在任何时刻仍然可以继续处理请求\Nthen the remaining nodes at any one time can continue processing requests.
Dialogue: 0,0:02:25.22,0:02:29.62,Default,,0,0,0,,高负载可能是你需要复制的另一个原因\NAnother reason why you might want replication is if there's very heavy load.
Dialogue: 0,0:02:29.62,0:02:30.38,Default,,0,0,0,,举例来说\NFor example,
Dialogue: 0,0:02:30.38,0:02:34.22,Default,,0,0,0,,来自世界各地的大量不同用户都希望访问相同的数据\Nlots and lots of different users around the world all want the same piece of data.
Dialogue: 0,0:02:34.22,0:02:37.12,Default,,0,0,0,,这远远超过了单一节点的处理能力\NThen, that might be too much for a single node to handle,
Dialogue: 0,0:02:37.12,0:02:40.20,Default,,0,0,0,,此时 让多个节点持有多个数据副本\Nand in which case, having copies of that data on multiple nodes
Dialogue: 0,0:02:40.20,0:02:43.68,Default,,0,0,0,,就可以允许我们处理来自更多用户的更多请求了\Nsimply lets you handle more requests from more users,
Dialogue: 0,0:02:43.68,0:02:47.08,Default,,0,0,0,,这种处理能力对于互联网规模的系统是非常重要的\Nwhich is important in Internet-scale systems.
Dialogue: 0,0:02:47.08,0:02:51.50,Default,,0,0,0,,如果拷贝的数据不会发生变化 那么很容易实现复制\NNow, replication is really easy if the data that you're copying doesn't change.
Dialogue: 0,0:02:51.50,0:02:52.76,Default,,0,0,0,,问题会变得非常简单\NThis is kind of obvious.
Dialogue: 0,0:02:52.76,0:02:56.32,Default,,0,0,0,,如果有些数据是静态的 你只需要拷贝好数据\NIf you've got some data that is static, you can just make a copy of it,
Dialogue: 0,0:02:56.32,0:02:59.92,Default,,0,0,0,,让所有节点持有一份拷贝 问题就解决了\Na one-time copy across all of your nodes, and jobs done.
Dialogue: 0,0:02:59.92,0:03:04.92,Default,,0,0,0,,我们在此课程主要考虑数据可变的情况\NSo, what we're all going to be focusing on in this lecture is data that changes
Dialogue: 0,0:03:04.92,0:03:06.58,Default,,0,0,0,,因为这才是最难的地方\Nbecause that's the bit that is hard.
Dialogue: 0,0:03:06.58,0:03:11.74,Default,,0,0,0,,数据可变才是最难的地方 处理时需要更加小心\NThe data changes are a bit that is hard, and that requires the most care.
Dialogue: 0,0:03:11.74,0:03:14.48,Default,,0,0,0,,你在学习操作系统时\NNow, one form of replication
Dialogue: 0,0:03:14.48,0:03:18.24,Default,,0,0,0,,可能遇到过一种复制形式 即RAID（磁盘阵列）\Nthat you might have come across in the context of operating systems is called RAID.
Dialogue: 0,0:03:18.24,0:03:22.18,Default,,0,0,0,,如果多个硬盘连接到了同一台计算机\NAnd so, this is if you have multiple hard disks attached to the same computer,
Dialogue: 0,0:03:22.18,0:03:27.54,Default,,0,0,0,,你可以使用RAID将数据冗余存储在多个硬盘上\Nyou can use RAID to redundantly store data on more than one hard disk.
Dialogue: 0,0:03:27.54,0:03:29.82,Default,,0,0,0,,例如 在RAID 1模式下\NSo, for example, in the case of RAID 1,
Dialogue: 0,0:03:29.82,0:03:34.00,Default,,0,0,0,,你实际会得到互为镜像的两个独立的硬盘\Nyou actually have two separate disks that are basically mirrors of each other.
Dialogue: 0,0:03:34.00,0:03:37.82,Default,,0,0,0,,写入一个硬盘中的文件也会写入到另一个硬盘中\NSo, any file that is written to one disk is also written to the other disk,
Dialogue: 0,0:03:37.82,0:03:41.74,Default,,0,0,0,,这意味着如果有一个硬盘出现硬件故障\Nwhich means that if one of those disks experiences a hardware failure,
Dialogue: 0,0:03:41.74,0:03:43.42,Default,,0,0,0,,你仍然可以从另一个硬盘得到数据\Nyou've still got the data on the other disk.
Dialogue: 0,0:03:43.42,0:03:46.04,Default,,0,0,0,,如果你不想丢失数据 这个技术是非常有用的\NExtremely useful if you don't like losing data.
Dialogue: 0,0:03:46.54,0:03:49.84,Default,,0,0,0,,我们在分布式系统中讨论的复制\NNow, the replication that we talk about in distributed systems
Dialogue: 0,0:03:49.84,0:03:51.64,Default,,0,0,0,,和RAID有些相似\Nis somewhat similar to that,
Dialogue: 0,0:03:51.64,0:03:54.44,Default,,0,0,0,,不过RAID使用的技术\Nexcept the techniques that are used for RAID
Dialogue: 0,0:03:54.44,0:03:56.92,Default,,0,0,0,,无法直接应用于分布式系统\Ndon't immediately apply in a distributed system,
Dialogue: 0,0:03:56.92,0:03:59.12,Default,,0,0,0,,因为RAID是为单计算机设计的\Nbecause RAID is designed for a single computer,
Dialogue: 0,0:03:59.12,0:04:02.94,Default,,0,0,0,,由单一控制器管理所有的数据\Nthere's a single controller that manages all of the data.
Dialogue: 0,0:04:02.94,0:04:06.36,Default,,0,0,0,,就像我们在前面的课程中看到的那样 在分布式系统中\NIn a distributed system, as we've seen in the previous lectures,
Dialogue: 0,0:04:06.36,0:04:08.78,Default,,0,0,0,,每个节点都是独立运行的\Nwe've got each node acting independently,
Dialogue: 0,0:04:08.78,0:04:11.60,Default,,0,0,0,,两个节点间的网络也是不可靠的\Nwe've got the unreliable network in between the two nodes,
Dialogue: 0,0:04:11.60,0:04:13.82,Default,,0,0,0,,节点可能分布在世界各地\Nthe nodes might be distributed around the world.
Dialogue: 0,0:04:13.82,0:04:15.90,Default,,0,0,0,,节点可能位于不同的位置\NSo, they might be not located in the same location,
Dialogue: 0,0:04:15.90,0:04:19.16,Default,,0,0,0,,它们可能分布在不同的大陆上 通过互联网进行通信\Nbut they might be on different continents communicating over the Internet.
Dialogue: 0,0:04:19.16,0:04:22.12,Default,,0,0,0,,我们必须处理分布式启动\NAnd so, we have to deal with all of the challenges that
Dialogue: 0,0:04:22.44,0:04:25.34,Default,,0,0,0,,所带来的全部挑战\Nthis sort of distributed setup brings.
Dialogue: 0,0:04:25.34,0:04:29.38,Default,,0,0,0,,我们从一个具体的例子开始\NSo, let's look at one example just to get us started
Dialogue: 0,0:04:29.38,0:04:36.60,Default,,0,0,0,,在这个例子中 我们有一个存储状态的数据库 而存储的状态发生了改变\Nof cases where we've got a database that is storing some state, and that state changes.
Dialogue: 0,0:04:36.60,0:04:40.48,Default,,0,0,0,,我们举一个社交网络的例子\NSo, here we have an example of a social network.
Dialogue: 0,0:04:40.48,0:04:44.64,Default,,0,0,0,,有些用户发布更新说“月亮其实不是奶酪做的！”\NAnd some user posts an update, saying “The moon is not actually made of cheese!”
Dialogue: 0,0:04:44.64,0:04:47.38,Default,,0,0,0,,你想为此更新点赞\NAnd you want to press the like button on that.
Dialogue: 0,0:04:47.38,0:04:51.80,Default,,0,0,0,,你按下“点赞”按钮这个事实需要被存储在某些地方\NOK, so, the fact that you have pressed that like button needs to be stored somewhere.
Dialogue: 0,0:04:51.80,0:04:53.02,Default,,0,0,0,,同时\NAnd also, the fact of
Dialogue: 0,0:04:53.02,0:04:56.50,Default,,0,0,0,,有多少人按下了点赞按钮这个事实也需要被存储在某些地方\Nhow many people have clicked that like button needs to be stored somewhere,
Dialogue: 0,0:04:56.50,0:04:58.74,Default,,0,0,0,,这里所说的某些地方一般指的是\NAnd that somewhere is typically a database
Dialogue: 0,0:04:59.18,0:05:03.32,Default,,0,0,0,,社交媒体提供商的服务器上运行的一个数据库\Nthat is running somewhere on the servers of the social media provider.
Dialogue: 0,0:05:03.32,0:05:08.10,Default,,0,0,0,,现在 我们只考虑点赞数可能发生的情况\NAnd what could happen now is I'm just going to consider the count of likes for now.
Dialogue: 0,0:05:08.50,0:05:12.74,Default,,0,0,0,,当你按下点赞按钮时\NSo, just as you press the like button,
Dialogue: 0,0:05:12.74,0:05:15.80,Default,,0,0,0,,客户端需要告诉存储在某个位置的计数器\Nthe client needs to tell this counter that is stored somewhere that
Dialogue: 0,0:05:15.80,0:05:17.62,Default,,0,0,0,,“你需要增加计数器的值了”\N“Oh, you need to increment the counter,”
Dialogue: 0,0:05:17.62,0:05:20.96,Default,,0,0,0,,因为又有一个人为这个更新点赞了\Nbecause one more person has liked this particular update now.
Dialogue: 0,0:05:20.96,0:05:24.66,Default,,0,0,0,,但很显然 网络可能发生的情况是\NBut networks being what they are, of course, it could happen that
Dialogue: 0,0:05:24.66,0:05:27.82,Default,,0,0,0,,请求或响应在网络中丢失了\Neither the request or the response is lost in the network.
Dialogue: 0,0:05:27.82,0:05:31.50,Default,,0,0,0,,我们在这个例子中考虑请求被成功传输\NAnd so, let's consider in this example that the request got through
Dialogue: 0,0:05:31.50,0:05:35.56,Default,,0,0,0,,但回复给客户端的确认消息“好的 我已经增加了计数器的值”\Nbut the acknowledgement back to the client that “OK, I incremented the counter,”
Dialogue: 0,0:05:35.56,0:05:37.78,Default,,0,0,0,,这条计数消息在网络中丢失了\Nthe acknowledgement got lost in a network.
Dialogue: 0,0:05:37.78,0:05:38.80,Default,,0,0,0,,因此 客户端说\NAnd so, the client says,
Dialogue: 0,0:05:38.80,0:05:42.52,Default,,0,0,0,,“似乎请求没有成功传输 让我来再试一次”\N“Well, it seems like the request didn't get through. Let's try it again.”
Dialogue: 0,0:05:42.52,0:05:45.12,Default,,0,0,0,,“让我再提交一次计数器增加请求”\N“Let's send the request to increment again.”
Dialogue: 0,0:05:45.60,0:05:47.96,Default,,0,0,0,,服务端再次收到请求\NThe server receives that request again.
Dialogue: 0,0:05:47.96,0:05:51.02,Default,,0,0,0,,最后 计数器的值被增加了两次\NAnd so, it ends up incrementing this counter twice.
Dialogue: 0,0:05:51.02,0:05:55.36,Default,,0,0,0,,虽然你只按了一次点赞按钮\NAnd so, we go from 12,300 to 12,302
Dialogue: 0,0:05:55.36,0:05:58.72,Default,,0,0,0,,但计数器的值从12,300变为了12,302\Neven though you actually only press that button once.
Dialogue: 0,0:05:58.72,0:06:05.68,Default,,0,0,0,,这看起来像是一个杜撰的例子 但这个例子在实际中确实会发生\NNow, this might seem like a bit of a hypothetical example, but it really does occur.
Dialogue: 0,0:06:05.68,0:06:11.00,Default,,0,0,0,,为避免此种情况的发生 我们首先可以尝试的方法是进行去重\NNow, the first thing we can do to try and prevent this kind of thing is to do deduplication,
Dialogue: 0,0:06:11.00,0:06:14.76,Default,,0,0,0,,我们在广播协议中已经见过去重的方法了\Nand we've seen that in the context of the broadcast protocols, for example.
Dialogue: 0,0:06:15.74,0:06:18.84,Default,,0,0,0,,然而 当我们面对的是数据库时\NHowever, with a database,
Dialogue: 0,0:06:18.84,0:06:23.38,Default,,0,0,0,,我们通常希望支持崩溃恢复类型的系统模型\Ngenerally, we want to support a crash-recovery type system model.
Dialogue: 0,0:06:23.94,0:06:28.48,Default,,0,0,0,,也就是说 当一个节点崩溃时 此节点不会永远离线 它会从故障中恢复\NThat means if a node crashes, it doesn't stay offline forever, it will come back,
Dialogue: 0,0:06:28.48,0:06:31.66,Default,,0,0,0,,这意味着 当节点在崩溃和重启状态时\Nwhich means that any data that needs to be not lost
Dialogue: 0,0:06:31.66,0:06:34.38,Default,,0,0,0,,如果我们不希望丢失数据\Nin the process of that crash and restart
Dialogue: 0,0:06:34.38,0:06:39.18,Default,,0,0,0,,数据就需要以某种持久存储的形式存储在稳定的存储设备中\Nneeds to be stored on disk in stable storage in some durable form.
Dialogue: 0,0:06:39.18,0:06:43.40,Default,,0,0,0,,如果你希望向数据库提交一个去重请求\NAnd if you want to deduplicate requests to a database
Dialogue: 0,0:06:43.40,0:06:47.64,Default,,0,0,0,,且希望即使节点出现崩溃和重启 节点仍然可以处理此请求\Nin a way that will work even across crashes and restarts,
Dialogue: 0,0:06:47.64,0:06:51.42,Default,,0,0,0,,这意味着所有请求也需要存储在数据库中\Nthat means that all of the requests actually need to be stored in the database as well.
Dialogue: 0,0:06:51.42,0:06:54.04,Default,,0,0,0,,这会导致我们要存储大量的数据\NThat can end up being quite a lot of data.
Dialogue: 0,0:06:55.04,0:06:58.50,Default,,0,0,0,,你可能会认为这是一个杜撰的例子\NNow, you might think that this sort of thing is just a hypothetical problem,
Dialogue: 0,0:06:58.50,0:07:00.00,Default,,0,0,0,,但实际中的确会发生类似的情况\Nbut it really does occur.
Dialogue: 0,0:07:00.00,0:07:06.52,Default,,0,0,0,,这里有一个例子 这是我前几年在推特上截的一张真实的截图\NThis is an example. This is a genuine screenshot that I made of Twitter a few years ago.
Dialogue: 0,0:07:06.52,0:07:11.54,Default,,0,0,0,,截图展示了一个关注了-20个人的用户账户\NAnd it shows a user account who is following -20 people.
Dialogue: 0,0:07:11.54,0:07:14.44,Default,,0,0,0,,这应该是不可能的\NSo, this should be impossible,
Dialogue: 0,0:07:14.44,0:07:19.00,Default,,0,0,0,,因为在现实世界中 你只能在社交平台关注正数个人\Nbecause of course you can only follow a positive number of people in real life.
Dialogue: 0,0:07:19.00,0:07:20.76,Default,,0,0,0,,不可能关注负数个人\NThere are no negative users.
Dialogue: 0,0:07:20.76,0:07:26.10,Default,,0,0,0,,我不知道在这个场景下到底是哪里出了问题\NAnd so, I don't know exactly what happened in this scenario here,
Dialogue: 0,0:07:26.10,0:07:30.00,Default,,0,0,0,,但我怀疑出问题的地方应该和我举的这个例子非常相似\Nbut I suspect that something happened was very similar to this example.
Dialogue: 0,0:07:30.00,0:07:33.32,Default,,0,0,0,,可能是此用户先关注了一些人\NSo, probably the user was following some number of people,
Dialogue: 0,0:07:33.32,0:07:35.30,Default,,0,0,0,,随后 他取消关注了这些人\Nthen they unfollowed those people.
Dialogue: 0,0:07:35.30,0:07:37.88,Default,,0,0,0,,在处理取消关注请求时\NIn the process of unfollowing those people,
Dialogue: 0,0:07:37.88,0:07:42.60,Default,,0,0,0,,需要降低用户关注人数计数器的值\Nsome counter of how many people this person is following had to get decremented.
Dialogue: 0,0:07:42.60,0:07:45.82,Default,,0,0,0,,但是 中间可能出现了一些网络错误\NAnd so, there was some network failure somewhere.
Dialogue: 0,0:07:45.82,0:07:53.94,Default,,0,0,0,,降低用户关注人数的请求被重复处理了\NAnd so, that decrementing of the follow count got repeated.
Dialogue: 0,0:07:53.94,0:07:58.42,Default,,0,0,0,,这导致降低的人数比关注的人数还要多\NAnd so, we end up decrementing more than there were actually followers.
Dialogue: 0,0:07:58.42,0:08:01.60,Default,,0,0,0,,这就是为什么计数器取值会变为负数的原因\NAnd so, that's why we end up with a negative counter here.
Dialogue: 0,0:08:01.60,0:08:05.38,Default,,0,0,0,,我认为推特在此期间可能已经修复了这个问题\NSo, OK, I think Twitter has probably fixed that bug in the meantime,
Dialogue: 0,0:08:05.38,0:08:09.94,Default,,0,0,0,,我们来看看系统应该如何解决此类问题\Nbut let's look at how we would deal with this kind of problem in our systems.
Dialogue: 0,0:08:09.94,0:08:16.04,Default,,0,0,0,,在重试场景下 一个非常有用的工具是\NAnd one tool that is very useful in the context of these kinds of retries is
Dialogue: 0,0:08:16.04,0:08:18.62,Default,,0,0,0,,让操作满足幂等性\Nto make the operation idempotent.
Dialogue: 0,0:08:18.62,0:08:21.90,Default,,0,0,0,,幂等是来自数学的一个概念\NSo, idempotence is a concept from math,
Dialogue: 0,0:08:21.90,0:08:26.62,Default,,0,0,0,,意思是如果你以某个参数调用一个函数时\Nwhich just means that if you apply a function once to some argument,
Dialogue: 0,0:08:26.62,0:08:30.22,Default,,0,0,0,,如果用相同的参数调用函数两次、三次、或者更多次时\Nit has the same effect as applying it twice, or applying it three times,
Dialogue: 0,0:08:30.22,0:08:32.44,Default,,0,0,0,,调用效果应该是一样的\Nor applying it any number of times.
Dialogue: 0,0:08:32.44,0:08:35.92,Default,,0,0,0,,一个非幂等函数的例子\NAnd so, an example of a function that is not idempotent is
Dialogue: 0,0:08:35.92,0:08:37.94,Default,,0,0,0,,就是我们前面看到过的计数器递增函数\Nto increment a counter like we have just seen,
Dialogue: 0,0:08:37.94,0:08:42.18,Default,,0,0,0,,因为调用一次计数器递增函数和调用两次计数器递增函数的结果是不一样的\Nbecause if you increment a counter once, that's not the same as incrementing it twice.
Dialogue: 0,0:08:42.18,0:08:45.88,Default,,0,0,0,,然而 在集合中添加一个元素的函数是幂等的\NHowever, adding an element to a set is idempotent,
Dialogue: 0,0:08:45.88,0:08:49.68,Default,,0,0,0,,因为如果你在集合中添加一个元素 随后你又在此集合中添加相同的元素\Nbecause if you add an element to a set, and then add the same element to the set again,
Dialogue: 0,0:08:49.68,0:08:52.52,Default,,0,0,0,,由于集合不会记录每个元素的添加次数\Nbecause the set doesn't count how many times an element is there,
Dialogue: 0,0:08:52.52,0:08:54.24,Default,,0,0,0,,集合只记录元素存在或者不存在\Nso, it's either there or not there,
Dialogue: 0,0:08:54.24,0:08:59.20,Default,,0,0,0,,因此 集合求并运算符满足幂等性\Nand so, therefore, doing the set union operator, that is idempotent.
Dialogue: 0,0:08:59.20,0:09:00.34,Default,,0,0,0,,这意味着\NAnd so, this means now
Dialogue: 0,0:09:00.34,0:09:06.60,Default,,0,0,0,,在推特的例子中 当我们想表示是否点赞 或者表示用户关注人数量时\Nif we represent these likes or the user follows in the case of Twitter
Dialogue: 0,0:09:06.60,0:09:11.78,Default,,0,0,0,,如果用集合而不是用计数器来表示 那我们就可以安全重试了\Nas a set rather than as a counter, then we can safely retry,
Dialogue: 0,0:09:11.78,0:09:14.50,Default,,0,0,0,,因为即使出现请求丢失或其他类似的情况\Nbecause even if the request gets lost or so,
Dialogue: 0,0:09:14.50,0:09:20.18,Default,,0,0,0,,我们仍然可以重复发送集合元素添加请求\Nwe can just send that request to add an element to a set, we can do that again,
Dialogue: 0,0:09:20.18,0:09:22.66,Default,,0,0,0,,向集合添加两次相同的元素不会带来任何问题\Nand applying it twice does no harm,
Dialogue: 0,0:09:22.66,0:09:26.46,Default,,0,0,0,,因为添加两次和添加一次的效果是一样的\Nbecause it just does the same as applying at once,
Dialogue: 0,0:09:26.46,0:09:31.18,Default,,0,0,0,,这意味着在此类分布式系统中\Nwhich leads to a choice of different semantics that you get
Dialogue: 0,0:09:31.18,0:09:34.40,Default,,0,0,0,,你可能会用到几种不同的语义\Nin these types of distributed systems.
Dialogue: 0,0:09:35.72,0:09:40.18,Default,,0,0,0,,这也是你后面可能会看到的几个术语 我这里也做个简单的介绍\NThey're just terms that you might see, and so, I want to mention them briefly,
Dialogue: 0,0:09:40.56,0:09:44.12,Default,,0,0,0,,它们分别是：最多一次、最少一次、恰好一次\Nwhich are at-most-once, at-least-once, and exactly-once.
Dialogue: 0,0:09:44.12,0:09:48.52,Default,,0,0,0,,最多一次的意思是 你只通过网络发送一次请求\NSo, at-most-ones just means you send a request of the network once,
Dialogue: 0,0:09:48.52,0:09:51.28,Default,,0,0,0,,请求可能会传输成功或传输失败 但你不会重试\Nit may or may not get there, but you're not going to retry.
Dialogue: 0,0:09:51.90,0:09:54.16,Default,,0,0,0,,请求可能会传输成功 也可能会传输失败\NSo, it might arrive, it might not arrive,
Dialogue: 0,0:09:54.16,0:09:57.52,Default,,0,0,0,,但你不会试图通过任何方式使请求变为可靠传输\Nbut you're not going to try and make this reliable in any way.
Dialogue: 0,0:09:57.52,0:10:01.58,Default,,0,0,0,,最少一次的意思是 你会一直重试 直到收到确认\NAt-least-once means you're going to retry until you get an acknowledgement,
Dialogue: 0,0:10:01.58,0:10:04.64,Default,,0,0,0,,这意味着请求可能会被多次发送\Nwhich means the request may arrive multiple times.
Dialogue: 0,0:10:04.64,0:10:07.40,Default,,0,0,0,,但我们真正想要的是恰好一次\NBut really what we typically want is exactly-once,
Dialogue: 0,0:10:07.40,0:10:11.34,Default,,0,0,0,,意思是操作恰好生效一次\Nwhich means the operation takes effect exactly once.
Dialogue: 0,0:10:12.40,0:10:17.42,Default,,0,0,0,,执行效果就好像操作恰好执行了一次\NSo, the effect is as if the operation were received exactly one time,
Dialogue: 0,0:10:17.94,0:10:22.74,Default,,0,0,0,,即使因为重试和消息丢失等原因\Neven though in practice, due to retries and due to message loss,
Dialogue: 0,0:10:22.74,0:10:26.04,Default,,0,0,0,,请求在实际中可能会被多次发送 但结果是恰好生效一次\Nit may actually be some different number of times.
Dialogue: 0,0:10:26.04,0:10:31.92,Default,,0,0,0,,如果重试等操作是幂等的\NAnd so, if we retry and also have an operation that is idempotent,
Dialogue: 0,0:10:31.92,0:10:34.38,Default,,0,0,0,,那么我们就可以满足恰好一次的语义\Nthen we can achieve exactly-one semantics.
Dialogue: 0,0:10:34.38,0:10:37.82,Default,,0,0,0,,这意味着即使多次执行了某个操作\NSo, that means even if the operation is applied multiple times,
Dialogue: 0,0:10:37.82,0:10:41.62,Default,,0,0,0,,执行效果就好像操作恰好执行了一次\Nthe effect is as if it had been applied exactly once.
Dialogue: 0,0:10:41.62,0:10:45.10,Default,,0,0,0,,当然了 我们也可以通过去重来实现恰好一次语义\NOr, of course, we can achieve exactly-once through deduplication as well
Dialogue: 0,0:10:45.50,0:10:50.00,Default,,0,0,0,,前提是我们愿意以某种形式存储所有已经发生的请求\Nas long as we're willing to store the requests that have already happened in some form.
Dialogue: 0,0:10:51.46,0:10:59.60,Default,,0,0,0,,我们来看另一个问题 这个问题强调了幂等性的局限性\NSo, let's look at another problem, which highlights the limitations of idempotence.
Dialogue: 0,0:10:59.60,0:11:02.58,Default,,0,0,0,,这次我们有了两个不同的客户端\NAnd that is we've got two different clients this time.
Dialogue: 0,0:11:02.58,0:11:06.98,Default,,0,0,0,,客户端1想要点赞\NAnd client 1 wants to add a like
Dialogue: 0,0:11:06.98,0:11:11.76,Default,,0,0,0,,或者说将你的用户ID（userID）添加在“谁点赞此更新”的用户集合中\Nor add your userID to the set of users who have liked a particular update.
Dialogue: 0,0:11:11.76,0:11:16.50,Default,,0,0,0,,我们前面已经知道 这是一个幂等操作 函数f是幂等的\NAnd as we've seen, this is an idempotent operation. This function f is idempotent.
Dialogue: 0,0:11:16.50,0:11:20.14,Default,,0,0,0,,现在 客户端2读取数据库\NNow, client 2 reads from the database.
Dialogue: 0,0:11:20.14,0:11:25.48,Default,,0,0,0,,它读取了“谁点赞此更新”的用户集合 并决定取消点赞\NIt reads the current set of users who have liked it, and decides to unlike this.
Dialogue: 0,0:11:25.48,0:11:27.50,Default,,0,0,0,,这意味着\NAnd so, what this means is
Dialogue: 0,0:11:27.50,0:11:33.24,Default,,0,0,0,,我们要从“谁点赞此更新”的用户集合中移除一个特定的用户ID\Nto remove a particular userID from the set of users who have liked a particular update.
Dialogue: 0,0:11:33.24,0:11:38.30,Default,,0,0,0,,客户端2构造请求g 将其发送给服务器\NAnd client 2 makes this request g, and sends it to the server.
Dialogue: 0,0:11:38.30,0:11:40.04,Default,,0,0,0,,服务器确认了此请求\NAnd the server acknowledges it.
Dialogue: 0,0:11:40.04,0:11:45.42,Default,,0,0,0,,现在 客户端构造的第一个请求所对应的确认在网络中丢失了\NNow, the first request that client 1 made, the acknowledgement got lost in the network.
Dialogue: 0,0:11:45.42,0:11:48.30,Default,,0,0,0,,因此 客户端1重试此请求\NAnd so, client 1 is going to retry this request.
Dialogue: 0,0:11:48.30,0:11:51.22,Default,,0,0,0,,现在的效果是\NAnd so, what the effect is now is that
Dialogue: 0,0:11:51.22,0:11:57.26,Default,,0,0,0,,客户端1再次向服务器发送“为此更新点赞”的请求\Nclient 1 sends this request to add the like back to the server again.
Dialogue: 0,0:11:57.26,0:12:02.64,Default,,0,0,0,,服务器刚刚从用户ID集合中移除了这个用户的ID\NAnd the server though has actually just removed the like from the set of userIDs.
Dialogue: 0,0:12:02.64,0:12:06.04,Default,,0,0,0,,因此 服务器又把这个用户ID添加了回来\NAnd so, it's going to add it back in again.
Dialogue: 0,0:12:06.04,0:12:08.62,Default,,0,0,0,,在这个场景下 虽然函数f是幂等的\NAnd so, here, even though the function f is idempotent,
Dialogue: 0,0:12:08.62,0:12:13.56,Default,,0,0,0,,执行两次点赞操作和执行一次点赞操作的效果一样\Nso, applying the like twice has the same effect as applying it once,
Dialogue: 0,0:12:13.56,0:12:16.96,Default,,0,0,0,,但当添加了取消点赞的操作后\Nin the context of also having this unlike operation,
Dialogue: 0,0:12:16.96,0:12:19.50,Default,,0,0,0,,幂等性就不再适用了\Nactually, the idempotence doesn't quite work anymore,
Dialogue: 0,0:12:19.50,0:12:23.44,Default,,0,0,0,,因为如果我们先执行f、再执行g、再执行f\Nbecause if we apply first f, then g, then f,
Dialogue: 0,0:12:23.44,0:12:27.10,Default,,0,0,0,,其效果与先执行f、再执行g是不一样的\Nthen this is not the same as just applying first f, then g,
Dialogue: 0,0:12:27.42,0:12:32.14,Default,,0,0,0,,因为第二次执行f会把元素再添加回集合中\Nbecause the second application of f is going to add the element back into the set again.
Dialogue: 0,0:12:32.14,0:12:36.60,Default,,0,0,0,,这里 用户的意图是自己不应该点赞了这个更新\NAnd so, here the user intention was that this item should not be liked,
Dialogue: 0,0:12:36.60,0:12:40.74,Default,,0,0,0,,因为用户先点赞、随后又取消点赞\Nbecause the user first liked it, and then unliked it.
Dialogue: 0,0:12:40.74,0:12:46.22,Default,,0,0,0,,但这个增加的点赞重试过程仍然属于第一次请求\NAnd this retry of adding the like still causally belongs to this first request here.
Dialogue: 0,0:12:46.22,0:12:50.16,Default,,0,0,0,,这并不是一个独立的再次点赞请求\NSo, it's not a separate request to add it back in again.
Dialogue: 0,0:12:50.16,0:12:56.88,Default,,0,0,0,,用户实际想要的最终结果应该是自己没有点赞\NThe actual intention is that the end result is this update is not liked.
Dialogue: 0,0:12:56.88,0:13:02.20,Default,,0,0,0,,我们来看看应该用什么方法来解决此问题\NSo, let's have a look at an approach that we can use to solve this problem.
Dialogue: 0,0:13:02.20,0:13:07.24,Default,,0,0,0,,我将用复制中可能发生的另一个问题来进行说明\NAnd I will illustrate this with another problem that can happen with replication.
Dialogue: 0,0:13:07.24,0:13:10.08,Default,,0,0,0,,我们在这个问题中面临的情况是\NAnd so, in this case, here what we have is
Dialogue: 0,0:13:10.08,0:13:14.30,Default,,0,0,0,,一个客户端想向一个集合添加一个元素x\Na client that wants to add an element x to a set.
Dialogue: 0,0:13:14.30,0:13:16.16,Default,,0,0,0,,我们这里使用了更抽象的描述方法\NSo, I'm just going to treat it more abstractly.
Dialogue: 0,0:13:16.16,0:13:19.18,Default,,0,0,0,,我们先忘记推特状态更新和点赞的场景\NLet's forget about status updates and likes for now,
Dialogue: 0,0:13:19.18,0:13:21.32,Default,,0,0,0,,更抽象地说 我们有某个元素x\Nand just more abstractly, we have some element x
Dialogue: 0,0:13:21.32,0:13:26.42,Default,,0,0,0,,我们需要将此元素同时添加在副本A和副本B中\Nthat needs to be added to a set on both replica A and replica B.
Dialogue: 0,0:13:26.42,0:13:28.98,Default,,0,0,0,,首先 用户提交添加请求\NAnd first, the user adds it.
Dialogue: 0,0:13:28.98,0:13:32.44,Default,,0,0,0,,随后 用户希望再次移除此元素 因为人们总会改变自己的想法\NAnd then, the user wants to remove it again, because people can change their mind.
Dialogue: 0,0:13:32.44,0:13:33.36,Default,,0,0,0,,好的 没问题\NOK, fine.
Dialogue: 0,0:13:33.36,0:13:38.60,Default,,0,0,0,,首先 添加请求会被发往两个副本\NAnd so, first, we have an add request that goes to both replicas,
Dialogue: 0,0:13:38.60,0:13:40.26,Default,,0,0,0,,随后 我们有了一个移除请求\Nthen we have a remove request.
Dialogue: 0,0:13:40.26,0:13:41.44,Default,,0,0,0,,不幸的是\NNow, unfortunately,
Dialogue: 0,0:13:41.44,0:13:46.56,Default,,0,0,0,,客户端的移除请求在通过网络传输给副本B的过程中丢失了\Nthe remove request is lost in the network on its way from the client to replica B.
Dialogue: 0,0:13:46.56,0:13:49.60,Default,,0,0,0,,副本A同时收到了添加和移除请求\NSo, replica A receives both the add and the remove,
Dialogue: 0,0:13:49.60,0:13:53.84,Default,,0,0,0,,但副本B只收到了添加请求 它没有收到移除请求\Nbut replica B only receives the add and it doesn't receive the remove.
Dialogue: 0,0:13:53.84,0:13:55.56,Default,,0,0,0,,现在的结果是\NSo, the end result now is that
Dialogue: 0,0:13:55.56,0:14:00.42,Default,,0,0,0,,元素x在副本B的集合中 因为副本B未移除此元素\Nthe element x is in the set on replica B, because it hasn't been removed,
Dialogue: 0,0:14:00.42,0:14:05.66,Default,,0,0,0,,但x不在副本A的集合中 因为副本A移除了此元素\Nbut x is not in the set on replica A, because it has been removed.
Dialogue: 0,0:14:05.66,0:14:07.82,Default,,0,0,0,,现在 如果我们考虑一下就会发现\NNow, if you think about this,
Dialogue: 0,0:14:07.82,0:14:14.26,Default,,0,0,0,,这个例子中两个副本的状态和下面例子中两个副本的状态完全一致\Nthe state of the two replicas in this example here is exactly the same as in this example.
Dialogue: 0,0:14:14.26,0:14:19.48,Default,,0,0,0,,在第二个例子中 客户端想要把x添加到集合中\NSo, in the second example, the client wants to add x to the set.
Dialogue: 0,0:14:19.48,0:14:22.46,Default,,0,0,0,,添加请求成功传输到副本B\NThe addition goes through and reaches replica B,
Dialogue: 0,0:14:22.46,0:14:25.30,Default,,0,0,0,,但添加请求在传输到副本A的过程中丢失了\Nbut the addition is lost on its way to replica A.
Dialogue: 0,0:14:25.30,0:14:31.78,Default,,0,0,0,,我们再次得到了相同的状态 x在B中但x不在A中\NSo, again, we have the same state that x is present on B but absent on A.
Dialogue: 0,0:14:31.78,0:14:36.82,Default,,0,0,0,,因此 在这两个例子中 两个副本的最终状态是相同的\NAnd so, the final state of the two replicas is the same in these two examples.
Dialogue: 0,0:14:36.82,0:14:40.86,Default,,0,0,0,,但实际上 我们不希望两种情况相同 因为用户的意图不一样\NBut actually, we don't want it to be the same, because the user intention was different.
Dialogue: 0,0:14:40.86,0:14:45.82,Default,,0,0,0,,在第一个场景中 用户先添加后移除\NIn the case of the first scenario here, the user first added then removed.
Dialogue: 0,0:14:45.82,0:14:50.14,Default,,0,0,0,,用户想要的最终状态是x不在集合中\NSo, the user intention was that the final state should be that x is not in the set,
Dialogue: 0,0:14:50.14,0:14:55.08,Default,,0,0,0,,但在第二个场景中 用户只添加了元素 用户没有移除任何元素\Nwhereas in the second scenario, the user only added it, the user didn't remove anything.
Dialogue: 0,0:14:55.08,0:14:57.96,Default,,0,0,0,,因此 用户想要的最终状态是x在集合中\NSo, the user intention is that x is present in the set.
Dialogue: 0,0:14:57.96,0:15:00.48,Default,,0,0,0,,用户在两个场景下的意图是不一样的\NSo, the user intention is actually different in these two,
Dialogue: 0,0:15:00.48,0:15:04.42,Default,,0,0,0,,但从副本的视角看 这两个场景的输出结果看起来一样\Nbut from the point of view of the replicas, these two outcomes look the same.
Dialogue: 0,0:15:04.42,0:15:07.16,Default,,0,0,0,,因此 我们需要区分这两种输出结果\NAnd so, we have to distinguish these two outcomes.
Dialogue: 0,0:15:07.16,0:15:11.02,Default,,0,0,0,,实现这一目的的方法是在请求中增加时间戳\NAnd the way we can do that is by adding timestamps to things.
Dialogue: 0,0:15:11.02,0:15:15.12,Default,,0,0,0,,我们将重用之前学习过的逻辑时间戳\NSo, we're going to reuse what we've learned before about logical timestamps.
Dialogue: 0,0:15:15.12,0:15:18.20,Default,,0,0,0,,我们要让客户端\NAnd we're just going to have the client
Dialogue: 0,0:15:18.20,0:15:23.14,Default,,0,0,0,,在创建向两个副本发送的请求时 为它们生成一个时间戳\Ngenerate a logical timestamp when it makes the request to the two replicas.
Dialogue: 0,0:15:23.14,0:15:27.44,Default,,0,0,0,,客户端生成时间戳t_1\NAnd so, the client generates this timestamp t_1,
Dialogue: 0,0:15:27.44,0:15:33.64,Default,,0,0,0,,客户端将t_1附加在请求中 并将请求同时发送给A和B\Nand it attaches t_1 to the add request that is sent to both A and B.
Dialogue: 0,0:15:33.64,0:15:38.80,Default,,0,0,0,,现在 A和B同时存储了时间戳t_1\NAnd now, A and B both store this timestamp t_1.
Dialogue: 0,0:15:38.80,0:15:44.20,Default,,0,0,0,,这里我们让x关联“真”\NAnd I'm also going to associate here x with a value true.
Dialogue: 0,0:15:44.20,0:15:47.80,Default,,0,0,0,,这里“真”的意思是x在集合中\NAnd true here just means that x is present in the set.
Dialogue: 0,0:15:47.80,0:15:49.98,Default,,0,0,0,,我们后面会看到为什么要这样做\NAnd we will see in a moment why we need this.
Dialogue: 0,0:15:49.98,0:15:54.84,Default,,0,0,0,,接下来 客户端构造一个移除请求\NBecause what happens next is now that the client makes a remove request,
Dialogue: 0,0:15:54.84,0:15:56.54,Default,,0,0,0,,因为这是一个新的请求\Nand because this is a new request,
Dialogue: 0,0:15:56.54,0:16:01.38,Default,,0,0,0,,客户端生成一个新的逻辑时间戳t_2 将t_2附加在请求上\Nit makes a new logical timestamp t_2, attaches t_2 to the request,
Dialogue: 0,0:16:01.90,0:16:04.20,Default,,0,0,0,,将请求同时发送给A和B\Nthe request is sent to both A and B.
Dialogue: 0,0:16:04.20,0:16:08.54,Default,,0,0,0,,因为这是一个逻辑时间戳 且移除请求发生在添加请求之后\NNow, because this is a logical timestamp, and the remove happened after the add,
Dialogue: 0,0:16:08.54,0:16:13.36,Default,,0,0,0,,这意味着t_1小于t_2 也就是t_2大于t_1\Nthis means that t_1 will be less than t_2, t_2 will be greater than t_1.
Dialogue: 0,0:16:13.36,0:16:20.32,Default,,0,0,0,,这里 副本A收到了移除x的请求\NAnd so, here we have replica A receives the request to remove x.
Dialogue: 0,0:16:20.32,0:16:24.36,Default,,0,0,0,,此时 我们不将x从数据库中移除\NAnd so, instead of actually removing x from the database,
Dialogue: 0,0:16:24.36,0:16:26.72,Default,,0,0,0,,A仍然把x留在数据库中\NA leaves x in the database,
Dialogue: 0,0:16:26.72,0:16:30.54,Default,,0,0,0,,但A会让x关联“假”\Nand says actually we're just going to attach this value false here to x.
Dialogue: 0,0:16:30.54,0:16:37.40,Default,,0,0,0,,这里“假”的意思是 把元素x看成是不在集合中的元素\NAnd false means I'll treat the element x as if it were not present in the set,
Dialogue: 0,0:16:37.40,0:16:39.78,Default,,0,0,0,,因为用户要求我们移除此元素\Nbecause the user asked that we remove it.
Dialogue: 0,0:16:39.78,0:16:41.30,Default,,0,0,0,,但我们并不真的移除此元素\NBut we're not actually going to remove it,
Dialogue: 0,0:16:41.30,0:16:44.76,Default,,0,0,0,,否则 我们就不知道用户是从没添加过元素 还是添加又移除了元素\Nbecause otherwise, we wouldn't know whether the user added or removed it.
Dialogue: 0,0:16:44.76,0:16:49.08,Default,,0,0,0,,因此 我们在数据库中留下“假”这个标记\NSo, we're going to leave this marker in the database, marked as false,
Dialogue: 0,0:16:49.08,0:16:54.64,Default,,0,0,0,,表示x实际上不在集合中 在时间戳t_2时发生了移除操作\Nsaying x is not actually in the set, and the deletion happened with a timestamp of t_2.
Dialogue: 0,0:16:54.64,0:16:57.04,Default,,0,0,0,,这样 我们就能区分出\NSo, here now, we can distinguish
Dialogue: 0,0:16:57.04,0:17:05.32,Default,,0,0,0,,副本B存在x的原因是时间戳t_1下x被标记为“真”\Non B that x is present because it has a value of true with a timestamp of t_1.
Dialogue: 0,0:17:05.32,0:17:13.74,Default,,0,0,0,,副本A不存在x的原因是时间戳t_2下x被标记为“假”\NOn replica A, x is absent, because it has a value of false and a timestamp of t_2.
Dialogue: 0,0:17:13.74,0:17:17.46,Default,,0,0,0,,在这个协议构造中 我们实际上没有移除过任何元素\NSo, this construction where we don't actually delete something,
Dialogue: 0,0:17:17.46,0:17:19.42,Default,,0,0,0,,只是把某个元素标记为已移除\Nbut just mark something as deleted.
Dialogue: 0,0:17:19.42,0:17:20.94,Default,,0,0,0,,这被称为墓碑\NIt's called a tombstone.
Dialogue: 0,0:17:21.30,0:17:24.26,Default,,0,0,0,,涉及到删除操作的多种不同的分布式算法\NAnd this appears in various different distributed algorithms
Dialogue: 0,0:17:24.76,0:17:26.62,Default,,0,0,0,,都会使用墓碑\Nwhen we have to deal with deletion.
Dialogue: 0,0:17:26.62,0:17:30.08,Default,,0,0,0,,墓碑的意思是某个信息应该被删除\NSo, tombstone just means something was supposed to be deleted,
Dialogue: 0,0:17:30.08,0:17:33.02,Default,,0,0,0,,但因为一些内部原因 我们实际上仍然保留了此信息\Nbut for internal reasons we had to actually keep it.
Dialogue: 0,0:17:33.02,0:17:37.50,Default,,0,0,0,,也许墓碑可以在未来的某个时间点被垃圾回收\NAnd maybe tombstones can get garbage collected at some later point in time.
Dialogue: 0,0:17:37.50,0:17:38.82,Default,,0,0,0,,这是另一个独立的问题\NThat's a separate question.
Dialogue: 0,0:17:38.82,0:17:44.20,Default,,0,0,0,,现在 我们只需要保留应该删除的元素即可\NBut for now, we just need to keep remembering this item even though it has been deleted.
Dialogue: 0,0:17:44.20,0:17:47.12,Default,,0,0,0,,当然了 我们还是要附加上逻辑时间戳\NAnd of course, we attached this logical timestamp.
Dialogue: 0,0:17:47.12,0:17:50.38,Default,,0,0,0,,每当在数据库中写入某个对象时\NSo, every time some object in the database is written,
Dialogue: 0,0:17:50.38,0:17:54.22,Default,,0,0,0,,我们都要在最后一次操作上附加对应的时间戳\Nwe attach the timestamp of the last operation that wrote it.
Dialogue: 0,0:17:54.22,0:17:58.98,Default,,0,0,0,,这允许我们区分哪些值比较新、哪些值比较旧\NAnd this allows us to tell which values are newer and which are older.
Dialogue: 0,0:17:58.98,0:18:03.68,Default,,0,0,0,,此时A和B不在处于相同的状态\NSo, this means now that after this has happened, A and B are no longer in the same state,
Dialogue: 0,0:18:03.68,0:18:10.04,Default,,0,0,0,,因为A在时间戳t_2下收到删除x的请求\Nbecause A received the request to delete x with a timestamp of t_2,
Dialogue: 0,0:18:10.04,0:18:14.26,Default,,0,0,0,,而B没有收到请求 因为请求在网络传输中丢失了\Nwhereas B did not receive that request, because it got lost in the network.
Dialogue: 0,0:18:14.26,0:18:18.04,Default,,0,0,0,,因此 B中x仍然在集合里\NAnd so, according to B, x is still present in the set,
Dialogue: 0,0:18:18.04,0:18:21.10,Default,,0,0,0,,最后一次操作的时间戳为t_1\Nand it has a last modification timestamp of t_1.
Dialogue: 0,0:18:21.10,0:18:24.40,Default,,0,0,0,,现在 两个副本可以执行一个协议\NAnd now, the two replicas can run a protocol in which
Dialogue: 0,0:18:24.40,0:18:28.16,Default,,0,0,0,,通过一个协议对比两个元素的数据\Nthey compare what they have, they compare their data.
Dialogue: 0,0:18:28.16,0:18:31.06,Default,,0,0,0,,这个协议被称为反熵协议\NAnd this protocol is called an anti-entropy protocol,
Dialogue: 0,0:18:31.06,0:18:33.70,Default,,0,0,0,,我猜叫这个名字的原因是\Nbecause I guess it's sort of it's supposed to
Dialogue: 0,0:18:33.70,0:18:37.32,Default,,0,0,0,,此协议的目的是消除系统中的熵、混乱状态、以及不确定性\Nclear the entropy and the confusion and the uncertainty in the system,
Dialogue: 0,0:18:37.32,0:18:41.12,Default,,0,0,0,,使所有副本恢复到相同的状态\Nand bring all of the replicas back into the same state.
Dialogue: 0,0:18:41.12,0:18:46.16,Default,,0,0,0,,当A和B协调彼此的状态 执行反熵协议时\NAnd so, as A and B reconcile their state and perform this anti-entropy protocol,
Dialogue: 0,0:18:46.16,0:18:48.00,Default,,0,0,0,,它们会比较时间戳\Nthey will compare their timestamps.
Dialogue: 0,0:18:48.00,0:18:52.06,Default,,0,0,0,,因为每个数据项都附加了逻辑时间戳\NAnd since we have these logical timestamps attached to every data item,
Dialogue: 0,0:18:52.50,0:18:54.78,Default,,0,0,0,,它们可以意识到 t_1小于t_2\Nthey can realize that, oh, t_1 is less than t_2,
Dialogue: 0,0:18:54.78,0:19:00.44,Default,,0,0,0,,因此 B的值一定更旧一些 A的值一定更新一些\Nso, therefore, this value that B has must be older, the value that A has must be newer.
Dialogue: 0,0:19:00.44,0:19:06.86,Default,,0,0,0,,因此 B中的记录应该被A中的记录所替代\NAnd so, therefore, the record on B is going to get replaced with the one from A.
Dialogue: 0,0:19:06.86,0:19:11.50,Default,,0,0,0,,A中的记录更新一些 我们把更新的记录传给B\NSo, the one from A is the more recent one, so that gets propagated to B.
Dialogue: 0,0:19:11.50,0:19:14.26,Default,,0,0,0,,这里的时间戳可以帮助到我们\NAnd so, here the timestamps have helped us,
Dialogue: 0,0:19:14.26,0:19:20.46,Default,,0,0,0,,因为时间戳可以告诉我们哪些操作更新一些 告诉我们操作的相对顺序\Nbecause they tell us about the recency and the relative ordering of these updates.
Dialogue: 0,0:19:20.46,0:19:23.30,Default,,0,0,0,,时间戳在这里起到非常重要的作用\NSo, timestamps have been very useful.
Dialogue: 0,0:19:23.88,0:19:26.22,Default,,0,0,0,,一般来说 我们会为数据库中的\NSo, typically, we will probably have one timestamp
Dialogue: 0,0:19:26.22,0:19:29.16,Default,,0,0,0,,每一个键或每一个对象设置一个时间戳\Nfor every given key or every object in the database,
Dialogue: 0,0:19:29.16,0:19:34.44,Default,,0,0,0,,因为键和对象是我们协调数据的粒度\Nbecause that's the granularity at which we're going to do that reconciliation.
Dialogue: 0,0:19:34.44,0:19:38.50,Default,,0,0,0,,我们应该使用哪种逻辑时间戳呢？\NNow, what kind of logical timestamps do we use here?
Dialogue: 0,0:19:38.50,0:19:40.04,Default,,0,0,0,,在上一节课中\NSo, in our last lecture,
Dialogue: 0,0:19:40.04,0:19:45.36,Default,,0,0,0,,我们学习了Lamport时钟和向量时钟的差异\Nwe saw the distinction between Lamport clocks and vector clocks.
Dialogue: 0,0:19:45.36,0:19:50.30,Default,,0,0,0,,实际上 两种时钟都可在数据库中使用 两种时钟带来的行为稍有不同\NAnd in fact, we can use both in databases, and we get slightly different behavior.
Dialogue: 0,0:19:50.30,0:19:53.14,Default,,0,0,0,,具体使用哪个时钟由我们想要的行为决定\NSo, it really depends what behavior we want.
Dialogue: 0,0:19:53.14,0:19:56.74,Default,,0,0,0,,如果我们考虑两个客户端并发设置副本数据库的场景\NAnd this becomes apparent if we consider two clients
Dialogue: 0,0:19:56.74,0:20:01.36,Default,,0,0,0,,那我们可以很明显的决定应该使用哪种时钟\Nthat are making rights to this replicated database concurrently.
Dialogue: 0,0:20:01.36,0:20:02.88,Default,,0,0,0,,这里\NSo, here on client 1,
Dialogue: 0,0:20:02.88,0:20:08.40,Default,,0,0,0,,客户端1想更新某个键x所对应的值\Nclient 1 wants to update the value that is associated with some key x.
Dialogue: 0,0:20:08.40,0:20:14.30,Default,,0,0,0,,x是键 v_1是客户端1希望附加在x上的值\NSo, x is the key, v_1 is the value that client 1 wants to attach to x.
Dialogue: 0,0:20:14.30,0:20:18.46,Default,,0,0,0,,此操作是在逻辑时间戳t_1下完成的\NAnd this operation is going to have a logical timestamp of t_1.
Dialogue: 0,0:20:18.46,0:20:24.74,Default,,0,0,0,,与此同时 当客户端1更新x时 客户端2也想设置x所对应的值\NConcurrently, while this is happening, client 2 also wants to set the value of x.
Dialogue: 0,0:20:24.74,0:20:27.52,Default,,0,0,0,,客户端2想让x附加不同的值v_2\NIt wants to set it to a different value v_2.
Dialogue: 0,0:20:27.52,0:20:31.30,Default,,0,0,0,,客户端2也生成一个逻辑时间戳t_2\NSo, client 2 also generates a logical timestamp t_2,
Dialogue: 0,0:20:32.08,0:20:37.44,Default,,0,0,0,,客户端2通过网络发送此操作请求 并将t_2附加在操作请求上\Nsends an operation over the network, attaches t_2 to this operation.
Dialogue: 0,0:20:37.44,0:20:41.32,Default,,0,0,0,,发送的具体操作是：我想把键x的值设为v_2\NThe operation is I want to set the key x to the value v_2.
Dialogue: 0,0:20:41.32,0:20:47.22,Default,,0,0,0,,现在 注意到副本A先收到来自客户端2的请求\NNow, notice that replica A first receives the request from client 2,
Dialogue: 0,0:20:47.22,0:20:49.32,Default,,0,0,0,,再收到来自客户端1的请求\Nsecond receives the request from client 1,
Dialogue: 0,0:20:49.32,0:20:51.90,Default,,0,0,0,,而副本B以相反的顺序收到两个请求\Nwhereas replica B receives them in the opposite order.
Dialogue: 0,0:20:51.90,0:20:57.68,Default,,0,0,0,,副本B先收到来自客户端1的请求 再收到来自客户端2的请求\NReplica B first receives the request from client 1, then the request from client 2.
Dialogue: 0,0:20:57.68,0:21:01.62,Default,,0,0,0,,这意味着副本不能按照收到请求的顺序\NSo, this means the replicas can't just use the order in which they see the requests
Dialogue: 0,0:21:01.62,0:21:06.20,Default,,0,0,0,,来决定x关联的值最终应该为v_1还是v_2\Nin order to determine whether v_1 or v_2 is the final value for x,
Dialogue: 0,0:21:06.56,0:21:09.80,Default,,0,0,0,,因为如果它们直接按照收到请求的顺序操作\Nbecause if they did just use the order in which the requests arrive,
Dialogue: 0,0:21:09.80,0:21:13.98,Default,,0,0,0,,它们的最终状态就会不一样 两个副本的最终状态会不一致\Nthen they would end up in different states, they would end up inconsistent at the end.
Dialogue: 0,0:21:13.98,0:21:16.66,Default,,0,0,0,,在复制系统中 我们想要的是\NAnd so, what we want in a replicated system is that
Dialogue: 0,0:21:16.66,0:21:18.82,Default,,0,0,0,,所有副本最终应处于相同的状态\Nall of the replicas end up being in the same state,
Dialogue: 0,0:21:18.82,0:21:20.64,Default,,0,0,0,,否则 这就不是复制了\Notherwise, it's not a replication.
Dialogue: 0,0:21:20.64,0:21:22.72,Default,,0,0,0,,这也是为什么这里要使用时间戳的原因\NAnd that's why we need to use the timestamps here,
Dialogue: 0,0:21:22.72,0:21:28.14,Default,,0,0,0,,因为时间戳表达了两个操作的相对顺序\Nbecause the timestamps provide a relative ordering of these two operations.
Dialogue: 0,0:21:28.14,0:21:31.12,Default,,0,0,0,,现在 一种选择是我们使用Lamport时钟\NNow, one option is that we use Lamport clocks.
Dialogue: 0,0:21:31.12,0:21:36.20,Default,,0,0,0,,如果你还记得的话 Lamport时钟为我们提供了一个全序关系\NAnd if you remember, what we have with Lamport clocks is they give us a total ordering.
Dialogue: 0,0:21:36.20,0:21:40.12,Default,,0,0,0,,全序关系意味着 给定系统中存在的任意两个时间戳\NSo, total ordering means that for any two timestamps that exist in the system,
Dialogue: 0,0:21:40.12,0:21:41.22,Default,,0,0,0,,我们都可以进行比较\Nwe can always compare them,
Dialogue: 0,0:21:41.22,0:21:44.70,Default,,0,0,0,,我们总能知道哪个时间戳比另一个时间戳更小\Nand it will always be the case that one is less than the other.
Dialogue: 0,0:21:44.70,0:21:50.44,Default,,0,0,0,,因此 在这个场景下 举例来说 我们假定t_1小于t_2\NAnd so, in this case, for example, we can say that t_1 is less than t_2,
Dialogue: 0,0:21:50.44,0:21:52.44,Default,,0,0,0,,当然了 反过来也是可以的\Nbut it might just as well be the other way around,
Dialogue: 0,0:21:52.44,0:21:55.14,Default,,0,0,0,,因为在这个场景中 两个操作是并发的\Nbecause in this case, the two operations are concurrent.
Dialogue: 0,0:21:55.14,0:22:00.20,Default,,0,0,0,,因此Lamport时间戳给我们提供的顺序关系可能是任意的\NAnd so, the ordering that the Lamport timestamps provide us is arbitrary essentially.
Dialogue: 0,0:22:00.20,0:22:07.00,Default,,0,0,0,,这里我们可以做的是比较t_1和t_2\NAnd so, what we can do here, for example, is that we compare t_1 and t_2,
Dialogue: 0,0:22:07.00,0:22:12.86,Default,,0,0,0,,我们保留时间戳更大的值\Nand we just keep the value with the higher timestamp.
Dialogue: 0,0:22:12.86,0:22:16.46,Default,,0,0,0,,这是可行的 因为当覆盖值时\NAnd this will work, because then, as the value gets overwritten,
Dialogue: 0,0:22:16.46,0:22:20.66,Default,,0,0,0,,我们知道覆盖一定发生在前一个操作之后\Nwe know that the overwrite happens after a previous operation.
Dialogue: 0,0:22:20.66,0:22:22.80,Default,,0,0,0,,因此 我们总会用更大时间戳的值覆盖小时间戳的值\NAnd therefore, it will always have a greater timestamp.
Dialogue: 0,0:22:22.80,0:22:27.70,Default,,0,0,0,,用一个较大的时间戳覆盖一个较小的时间戳 这不会出什么问题\NSo, therefore, overwriting a smaller timestamp with a greater timestamp is a fine thing.
Dialogue: 0,0:22:27.70,0:22:28.88,Default,,0,0,0,,我们可以这么做\NYou can do that.
Dialogue: 0,0:22:28.88,0:22:31.42,Default,,0,0,0,,这一行为被称为最后写入方胜利\NAnd this behavior is called last writer wins,
Dialogue: 0,0:22:31.82,0:22:37.10,Default,,0,0,0,,因为我们假设最后写入方持有最大的时间戳\Nbecause we assume that the last writer is the one with the highest timestamp.
Dialogue: 0,0:22:37.10,0:22:39.14,Default,,0,0,0,,如果存在多个不同时间戳的并发更新\NAnd so, the highest timestamp wins
Dialogue: 0,0:22:39.14,0:22:43.04,Default,,0,0,0,,最大时间戳的更新将赢得胜利\Nif there are several concurrent updates with different timestamps.
Dialogue: 0,0:22:43.04,0:22:47.52,Default,,0,0,0,,然而 请注意 假设这里的t_2大于t_1\NNote, however, that this means that if, say, t_2 is greater than t_1,
Dialogue: 0,0:22:47.52,0:22:52.78,Default,,0,0,0,,这意味着我们将保留客户端2写入的v_2 我们会直接丢弃v_1\Nthis means we keep v_2, which was written by client 2, and we simply discard v_1.
Dialogue: 0,0:22:52.78,0:22:55.36,Default,,0,0,0,,v_1这个值直接被丢弃了\NSo, value v_1 is simply gone.
Dialogue: 0,0:22:55.36,0:22:58.64,Default,,0,0,0,,我们甚至不会把这个值存储下来\NSo, we're not even storing that value anywhere.
Dialogue: 0,0:22:58.64,0:23:00.86,Default,,0,0,0,,我们直接覆盖并忘记这个值\NIt simply gets overwritten and forgotten.
Dialogue: 0,0:23:00.86,0:23:03.38,Default,,0,0,0,,对于有些应用来说 这是可接受的\NAnd this might be OK depending on the application.
Dialogue: 0,0:23:03.38,0:23:07.42,Default,,0,0,0,,对于有些应用来说 如果存在太多的并发写操作\NThere might be applications in which actually if they're too concurrent writes,
Dialogue: 0,0:23:07.42,0:23:10.40,Default,,0,0,0,,可以简单的保留一个操作 舍弃其他的操作\Nit's fine to just keep one and throw away the others.
Dialogue: 0,0:23:10.40,0:23:14.76,Default,,0,0,0,,如果存在五个并发写操作 我们将保留一个操作 舍弃其他四个操作\NIf there are five concurrent writes, we're going to keep one and throw away four of them.
Dialogue: 0,0:23:14.76,0:23:17.38,Default,,0,0,0,,但还存在一些场景\NBut there might also be scenarios in which
Dialogue: 0,0:23:17.38,0:23:20.72,Default,,0,0,0,,如果存在多个并发写操作 我们需要保留所有的操作\Nactually if there are several concurrent writes, we want to keep all of them,
Dialogue: 0,0:23:20.72,0:23:23.88,Default,,0,0,0,,我们需要显式解决操作冲突的问题\Nand we want to explicitly resolve this situation.
Dialogue: 0,0:23:23.88,0:23:27.98,Default,,0,0,0,,如果我们想得到这样的行为 我们就要用向量时钟代替Lamport时钟\NAnd if we want that, well, we use a vector clock instead of a Lamport clock.
Dialogue: 0,0:23:27.98,0:23:33.26,Default,,0,0,0,,当我们使用向量时钟时 如果我们生成两个不同的时间戳t_1和t_2\NIf we use a vector clock, then if we generate two different timestamps t_1 and t_2,
Dialogue: 0,0:23:33.26,0:23:35.38,Default,,0,0,0,,两个时间戳对应的操作是并发的\Nand these two operations are concurrent,
Dialogue: 0,0:23:35.38,0:23:38.04,Default,,0,0,0,,则这两个向量时钟是不可比较的\Nthen the vector clocks will also be incomparable.
Dialogue: 0,0:23:38.04,0:23:41.96,Default,,0,0,0,,我们最终会发现t_1和t_2不可比较\NWe will end up with t_1 and t_2 being incomparable.
Dialogue: 0,0:23:41.96,0:23:46.44,Default,,0,0,0,,这使我们能够检测到这两个操作是并发的\NAnd this allows us to detect the fact that these two operations are concurrent.
Dialogue: 0,0:23:46.44,0:23:52.92,Default,,0,0,0,,在这种情况下 只有当一个向量时间戳严格小于另一个向量时间戳时\NAnd so, in this case, now, we will only overwrite one value with another value
Dialogue: 0,0:23:52.92,0:23:59.82,Default,,0,0,0,,我们才会用一个值覆盖另一个值\Nif their vector timestamps are the later ones strictly greater than the earlier one,
Dialogue: 0,0:23:59.82,0:24:04.22,Default,,0,0,0,,只有当满足我们前面定义的严格大于关系时 我们才会这么做\Nunder the strictly greater than relation that we've defined previously.
Dialogue: 0,0:24:05.24,0:24:09.46,Default,,0,0,0,,但如果我们得到了两个并发的更新操作 我们会保留这两个操作\NBut if we have two concurrent updates, then we will keep both of them.
Dialogue: 0,0:24:09.46,0:24:10.94,Default,,0,0,0,,在这种情况下\NAnd so, in this case, now,
Dialogue: 0,0:24:10.94,0:24:15.72,Default,,0,0,0,,键x不仅会关联单独的一个值 而是会关联多个值\Nthere's not a single value attached to the key x, but there could be multiple values,
Dialogue: 0,0:24:15.72,0:24:17.58,Default,,0,0,0,,这个例子中会关联v_1和v_2\Nin this case v_1 and v_2.
Dialogue: 0,0:24:17.58,0:24:22.06,Default,,0,0,0,,这种情况下 我们将两个值都返回给应用\NAnd so, in this case, we can give those two values back to the application,
Dialogue: 0,0:24:22.06,0:24:24.98,Default,,0,0,0,,应用会解决这一情况\Nand the application can then resolve this.
Dialogue: 0,0:24:24.98,0:24:26.70,Default,,0,0,0,,这种情况被称为冲突\NSo, this is called a conflict.
Dialogue: 0,0:24:27.16,0:24:32.28,Default,,0,0,0,,应用会通过显式逻辑解决冲突\NAnd the application can have explicit logic for conflict resolution
Dialogue: 0,0:24:32.28,0:24:34.90,Default,,0,0,0,,此种情况下 如果出现了两个并发的更新操作\Nso that if these two updates happen concurrently,
Dialogue: 0,0:24:34.90,0:24:37.90,Default,,0,0,0,,两个不同的客户端写入了两个不同的值\Nand we have two different values written by different clients,
Dialogue: 0,0:24:37.90,0:24:40.16,Default,,0,0,0,,我们应该避免丢弃数据\Nthen we can avoid throwing away data,
Dialogue: 0,0:24:40.16,0:24:45.00,Default,,0,0,0,,我们应该把并发写入的两个值合并成一个值\Nwe can combine the information from these two values that were written concurrently
Dialogue: 0,0:24:45.00,0:24:48.18,Default,,0,0,0,,将合并结果再写入数据库\Ninto a single value, write it back to the database again.
Dialogue: 0,0:24:48.18,0:24:51.68,Default,,0,0,0,,这会让所有人感到满意 不会丢失数据\NAnd that ensures then everyone is happy, and no data was lost.
Dialogue: 0,0:24:51.68,0:24:53.34,Default,,0,0,0,,我们可以进行选择\NSo, we have this choice here
Dialogue: 0,0:24:54.00,0:24:57.66,Default,,0,0,0,,或者使用提供全序关系的Lamport时间戳\Nusing either the totally ordered Lamport timestamps
Dialogue: 0,0:24:57.66,0:25:00.04,Default,,0,0,0,,或者使用提供偏序关系的向量时间戳\Nor the partially ordered vector timestamps,
Dialogue: 0,0:25:00.04,0:25:02.74,Default,,0,0,0,,具体使用哪种时间戳由我们想要的行为来决定\Ndepending on which kind of behavior we actually want.
Dialogue: 0,0:25:02.74,0:25:06.02,Default,,0,0,0,,不同数据库系统也会做出不同的选择\NAnd different database systems actually make different choices
Dialogue: 0,0:25:06.46,0:25:09.12,Default,,0,0,0,,它们会根据不同的情况使用不同的时间戳\Nwith regard to what sort of timestamps they want to use,
Dialogue: 0,0:25:09.44,0:25:14.08,Default,,0,0,0,,因为面对不同的应用 应该采用不同的方法\Nbecause for different applications, different methods are appropriate.
Dialogue: 0,0:25:14.08,0:25:19.40,Default,,0,0,0,,就这些内容了 接下来我们将学习复制中的容错\NSo far that, and next, we will look at fault tolerance in replication.
