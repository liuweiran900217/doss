[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 8.1_Collaboration software.mp4
Video File: 8.1_Collaboration software.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.875000
Scroll Position: 536
Active Line: 561
Video Position: 61026

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.28,0:00:05.14,Default,,0,0,0,,欢迎来到分布式系统的第8课 也是分布式系统的最后一节课\NWelcome to the eighth and final distributed systems lecture.
Dialogue: 0,0:00:05.14,0:00:06.80,Default,,0,0,0,,本节课中 我们将介绍一些\NThis lecture, we are going to look at
Dialogue: 0,0:00:06.80,0:00:11.04,Default,,0,0,0,,应用实例和实际软件\Nsome case studies of example applications, real-world software
Dialogue: 0,0:00:11.04,0:00:15.52,Default,,0,0,0,,这些实例和软件使用了我们在本课程中介绍的一些分布式系统的概念\Nthat uses the distributed systems concepts that we've seen in this course.
Dialogue: 0,0:00:15.52,0:00:20.16,Default,,0,0,0,,特别地 实际中还有一些有趣的并发问题需要解决\NAnd in particular, that has interesting problems to deal with around concurrency.
Dialogue: 0,0:00:20.16,0:00:23.64,Default,,0,0,0,,我想以协作软件作为开场\NSo, I'd like to start with collaboration software.
Dialogue: 0,0:00:23.64,0:00:27.80,Default,,0,0,0,,这是一个相当广泛的软件类别\NSo, this is a fairly broad category of software
Dialogue: 0,0:00:27.80,0:00:30.86,Default,,0,0,0,,大家可能在之前都用过这类软件\Nbut you've probably used things like this before.
Dialogue: 0,0:00:30.86,0:00:33.44,Default,,0,0,0,,我脑海中想到的一个协作软件例子是谷歌文档\NWhat I have in mind are things like Google Docs,
Dialogue: 0,0:00:33.44,0:00:37.12,Default,,0,0,0,,你可以和多个人一起同时编辑一个文档\Nwhere you can have several people editing a document at the same time,
Dialogue: 0,0:00:37.96,0:00:41.34,Default,,0,0,0,,还有就是我们上节课介绍的日历同步例子\Nor the calendar sync example that we saw in the last lecture
Dialogue: 0,0:00:41.34,0:00:44.54,Default,,0,0,0,,我可以在一个设备上更新某个事项\Nwhere I can update some events on one device
Dialogue: 0,0:00:44.54,0:00:47.44,Default,,0,0,0,,更新结果会被同步到其他设备上\Nand have those synchronized over to another device.
Dialogue: 0,0:00:47.44,0:00:50.12,Default,,0,0,0,,现在 很多应用\NAnd many other applications
Dialogue: 0,0:00:50.12,0:00:53.96,Default,,0,0,0,,都内置了类似的协作机制\Nthat have this kind of similar collaboration built in nowadays,
Dialogue: 0,0:00:53.96,0:00:58.38,Default,,0,0,0,,与同事一起协作不再需要来来回回发邮件了\Nbecause it's just so useful to be able to work on something with your colleagues
Dialogue: 0,0:00:58.70,0:01:01.70,Default,,0,0,0,,这种功能实在是太有用了\Nwithout having to email files back and forth, for example,
Dialogue: 0,0:01:01.70,0:01:06.06,Default,,0,0,0,,这些应用的共同点是同时有多个用户\NSo, what these applications have in common is that there are several users.
Dialogue: 0,0:01:06.06,0:01:11.98,Default,,0,0,0,,每个用户都通过某个设备访问文件、文档或数据库\NEach user using some device to access some shared file or document or database.
Dialogue: 0,0:01:11.98,0:01:16.48,Default,,0,0,0,,每个设备都持有正在处理数据的本地拷贝\NEach of these devices has its own local copy of the data that it's working on.
Dialogue: 0,0:01:16.48,0:01:22.24,Default,,0,0,0,,虽然可能是内存拷贝 但我们仍然把此种形式看成持有共享数据的副本\NThis might just be in-memory, but we can still call it a replica of this shared data.
Dialogue: 0,0:01:22.24,0:01:29.36,Default,,0,0,0,,每个用户都可以更新拷贝的文档副本\NAnd each user is able to update the replica of their own copy of this document,
Dialogue: 0,0:01:29.36,0:01:32.62,Default,,0,0,0,,可以通过浏览器、移动应用等多种方式更新文档\Nbe it in their web browser or in a mobile app or something like that.
Dialogue: 0,0:01:32.62,0:01:36.86,Default,,0,0,0,,用户可以在任意时间更新文档\NThe user can update this data anytime whenever they like,
Dialogue: 0,0:01:36.86,0:01:39.54,Default,,0,0,0,,甚至在断开互联网时也能更新文档\Neven if they're disconnected from the Internet ideally.
Dialogue: 0,0:01:39.54,0:01:43.46,Default,,0,0,0,,随后 当设备后续重新与互联网建立连接后\NAnd then, sometime later, when they have an Internet connection again,
Dialogue: 0,0:01:43.46,0:01:45.72,Default,,0,0,0,,更新结果会同步到服务器上\Nthen they will sync back with the server,
Dialogue: 0,0:01:45.72,0:01:49.92,Default,,0,0,0,,也会同步到任何持有文档拷贝的其他客户端上\Nand with any other clients that have a copy of this document.
Dialogue: 0,0:01:49.92,0:01:52.34,Default,,0,0,0,,这里面临的挑战是\NNow, the challenge in this is
Dialogue: 0,0:01:52.34,0:01:57.10,Default,,0,0,0,,可能有多个人并发更新相同的文档\Nwe can have several people concurrently updating the same document.
Dialogue: 0,0:01:57.10,0:02:00.06,Default,,0,0,0,,我们必须以某种方式协调并发更新\NAnd we have to somehow reconcile those concurrent updates
Dialogue: 0,0:02:00.06,0:02:04.06,Default,,0,0,0,,保证每个人最终都能得到一致的状态\Nand make sure that everyone ends up in a consistent state
Dialogue: 0,0:02:04.06,0:02:08.12,Default,,0,0,0,,使软件按照我们期望的方式继续运作\Nso that the software continues working as we might expect.
Dialogue: 0,0:02:08.12,0:02:11.08,Default,,0,0,0,,两类算法\NAnd there are two main families of algorithms
Dialogue: 0,0:02:11.08,0:02:14.24,Default,,0,0,0,,可以实现此类软件的功能\Nthat are used in order to implement this type of software.
Dialogue: 0,0:02:14.90,0:02:19.38,Default,,0,0,0,,一类算法叫无冲突复制数据类型 缩写为CRDT\NOne is Conflict-free Replicated Data Types, or CRDTs for short.
Dialogue: 0,0:02:19.38,0:02:22.90,Default,,0,0,0,,CRDT可以进一步分为两个子类：基于操作、基于状态\NAnd they come in two flavors further, operation-based and state-based,
Dialogue: 0,0:02:22.90,0:02:24.58,Default,,0,0,0,,我稍后会介绍这两个子类\Nas I will explain shortly.
Dialogue: 0,0:02:24.58,0:02:28.16,Default,,0,0,0,,另一类算法叫操作转换\NAnd a second family of algorithms is called Operational Transformation.
Dialogue: 0,0:02:28.16,0:02:30.86,Default,,0,0,0,,大家稍后也会看到一个具体的例子\NAnd you will see an example of that as well.
Dialogue: 0,0:02:30.86,0:02:34.06,Default,,0,0,0,,我们从上一节课的日历同步例子讲起\NSo, let's start with the example from the last lecture
Dialogue: 0,0:02:34.06,0:02:36.00,Default,,0,0,0,,我们在上一节课介绍了日历同步的例子\Nwhere I showed the calendar sync example.
Dialogue: 0,0:02:36.00,0:02:37.92,Default,,0,0,0,,我有手机和笔记本电脑\NSo, I had my phone and my laptop.
Dialogue: 0,0:02:37.92,0:02:42.96,Default,,0,0,0,,我的日历上有个事项：特定日期和特定时间的课程\NI had an event in my calendar saying a lecture on a certain date at a certain time.
Dialogue: 0,0:02:42.96,0:02:46.02,Default,,0,0,0,,这两个设备互相之间断开连接\NAnd these two devices were disconnected from each other,
Dialogue: 0,0:02:46.02,0:02:48.88,Default,,0,0,0,,因为我把手机设置成了飞行模式\Nbecause I put my phone into airplane mode.
Dialogue: 0,0:02:48.88,0:02:54.82,Default,,0,0,0,,现在 我在笔记本电脑上把事项标题从“Lecture”改成了“Lecture 1”\NNow, let's say that on the computer, I update the title from Lecture to Lecture 1.
Dialogue: 0,0:02:54.82,0:02:57.80,Default,,0,0,0,,在这两个设备断开连接时\NAnd while these two devices are disconnected,
Dialogue: 0,0:02:57.80,0:03:03.90,Default,,0,0,0,,我在手机上将课程时间并发更新为10:00\Nconcurrently I update the time of the lecture on my phone to be 10:00.
Dialogue: 0,0:03:03.90,0:03:06.88,Default,,0,0,0,,现在 我有了两个并发更新\NAnd so now, we have these two concurrent updates.
Dialogue: 0,0:03:06.88,0:03:11.48,Default,,0,0,0,,网络稍后得到恢复 两个设备想要同步状态\NAnd sometime later, the network is restored, and these two devices want to sync.
Dialogue: 0,0:03:11.48,0:03:13.46,Default,,0,0,0,,我们想要保证\NAnd we want to ensure that
Dialogue: 0,0:03:13.46,0:03:17.74,Default,,0,0,0,,两个设备最终都存储相同的信息 两个设备的信息能够收敛\Nat the end, we have the same information on both devices that these devices converge.
Dialogue: 0,0:03:17.74,0:03:20.98,Default,,0,0,0,,理想情况下 我不希望处理过程中丢失任何数据\NAnd ideally, we would also like to not lose any data in the process.
Dialogue: 0,0:03:20.98,0:03:25.46,Default,,0,0,0,,在这个例子中 我保留了标题“Lecture 1”的更新结果\NAnd so, in this example, we have kept the update of the title saying Lecture 1
Dialogue: 0,0:03:25.46,0:03:28.82,Default,,0,0,0,,我也保留了时间“10:00”的更新结果\Nand we have kept the update of the time to, say, 10:00 am.
Dialogue: 0,0:03:28.82,0:03:32.24,Default,,0,0,0,,这两个更新结果被合并到了单一的更新结果上\NAnd those two things have been merged together into a single update.
Dialogue: 0,0:03:32.24,0:03:35.26,Default,,0,0,0,,我们来看看能实现这一点的几种算法\NSo, let's look at some algorithms that can achieve this.
Dialogue: 0,0:03:35.26,0:03:38.76,Default,,0,0,0,,我前面提到过 无冲突复制数据类型 或CRDT\NConflict-free Replicated Data Types, or CRDTs,
Dialogue: 0,0:03:38.76,0:03:42.04,Default,,0,0,0,,是这个场景下可以使用的一类算法\Nare, as I said, one of the types of algorithms you can use here.
Dialogue: 0,0:03:42.04,0:03:46.54,Default,,0,0,0,,这里给出的例子被称为基于操作CRDT\NAnd this is an example of what is called an operation-based CRDT.
Dialogue: 0,0:03:46.54,0:03:49.50,Default,,0,0,0,,CRDT的数据模型是一个映射\NThe data model of this is a map.
Dialogue: 0,0:03:49.76,0:03:52.76,Default,,0,0,0,,这就像Java中的Map对象一样\NSo, it's just like a Map object that you might have in Java also.
Dialogue: 0,0:03:52.76,0:03:57.44,Default,,0,0,0,,你可以使用面向对象接口\NSo, you have this object-oriented interface that you're using
Dialogue: 0,0:03:57.44,0:03:59.10,Default,,0,0,0,,来表示你的数据\Nin order to represent your data.
Dialogue: 0,0:03:59.10,0:04:03.64,Default,,0,0,0,,我们在这种情况下使用的数据类型是键到值的映射\NAnd in this case, the data type that we have is a map from keys to values.
Dialogue: 0,0:04:03.64,0:04:05.98,Default,,0,0,0,,我们不再进一步拆解键和值本身了\NAnd so, keys and values are not further interpreted.
Dialogue: 0,0:04:05.98,0:04:09.56,Default,,0,0,0,,键和值可以是字符串 可以是数值 也可以是其他类型的数据\NThey could be strings or they could be numbers or whatever we like.
Dialogue: 0,0:04:09.56,0:04:13.58,Default,,0,0,0,,这里我们唯一要保证的一个性质是\NAnd the only property that we want to here ensure is that
Dialogue: 0,0:04:13.58,0:04:16.80,Default,,0,0,0,,一个键仅会唯一映射到一个值\Nfor a given key, there is exactly one value.
Dialogue: 0,0:04:16.80,0:04:18.80,Default,,0,0,0,,此时 我们可以\NAnd so, we can achieve this
Dialogue: 0,0:04:18.80,0:04:23.14,Default,,0,0,0,,使用前面几节课介绍的最后写入方胜利方法来合并数据\Nusing the last-writer-wins approach that we saw in a previous lecture.
Dialogue: 0,0:04:23.14,0:04:27.00,Default,,0,0,0,,具体做法如下所述\NAnd so, the way you might do this is as follows.
Dialogue: 0,0:04:27.00,0:04:29.20,Default,,0,0,0,,当初始化副本时\NSo, let's say, when a replica initializes,
Dialogue: 0,0:04:29.20,0:04:34.72,Default,,0,0,0,,节点将values变量初始化为空集合 values变量就是副本的初始化状态\Nit just sets up its own state to be this variable values, which is just an empty set.
Dialogue: 0,0:04:34.72,0:04:40.42,Default,,0,0,0,,集合values就是值集合 里面包含键到值的映射\NAnd this set here is going to contain mappings from keys to values.
Dialogue: 0,0:04:40.42,0:04:44.60,Default,,0,0,0,,每个键到值的映射还会与一个时间戳相关联\NAnd each mapping from a key to a value is also got an associated timestamp.
Dialogue: 0,0:04:45.10,0:04:48.40,Default,,0,0,0,,这里我们可以使用一个逻辑时间戳 如Lamport时间戳\NWe can use a logical timestamp here, like a Lamport timestamp.
Dialogue: 0,0:04:48.40,0:04:50.24,Default,,0,0,0,,这里的时间戳可以告诉我们\NAnd this will help us figure out
Dialogue: 0,0:04:50.54,0:04:53.86,Default,,0,0,0,,当出现多个并发更新时 哪个更新值是最新的 离现在最近\Nif there's several concurrent updates, which one is the more recent value.
Dialogue: 0,0:04:53.86,0:04:58.34,Default,,0,0,0,,当我们想读取给定键的值时\NOK, and so, when we want to read the value for a given key,
Dialogue: 0,0:04:58.34,0:05:01.74,Default,,0,0,0,,我们只需要查找值集合中的条目\Nwe just look for any entries in this set values.
Dialogue: 0,0:05:02.02,0:05:05.28,Default,,0,0,0,,集合中的条目就是时间戳、键和值所构成的三元组\NThe entries are these triples of timestamp, key and value.
Dialogue: 0,0:05:05.28,0:05:11.80,Default,,0,0,0,,我们找到给定键所对应的条目 此条目还会包含时间戳和值\NSo, we look for any entry here for the given key with any timestamp at any value,
Dialogue: 0,0:05:11.80,0:05:14.38,Default,,0,0,0,,如果能找到条目 则返回对应的值v\Nand if it exists, we return that value v,
Dialogue: 0,0:05:14.78,0:05:16.56,Default,,0,0,0,,如果找不到 我们直接返回null\Nand if it does not exist, we just return null,
Dialogue: 0,0:05:16.56,0:05:20.44,Default,,0,0,0,,表示没有在映射集合中找到给定的键\Nsaying there is no entry for that key in the map, OK?
Dialogue: 0,0:05:21.84,0:05:23.82,Default,,0,0,0,,此机制依赖的假设是\NThis here works on the assumption that
Dialogue: 0,0:05:23.82,0:05:27.80,Default,,0,0,0,,对于任意给定键 映射集合中最多只存在一个对应的条目\Nfor a given key, there is at most one element in this map,
Dialogue: 0,0:05:27.80,0:05:32.00,Default,,0,0,0,,算法的其余部分将保证这一不变性\Nwhich the rest of the algorithm does ensure that particular invariant.
Dialogue: 0,0:05:32.00,0:05:36.24,Default,,0,0,0,,现在 如果我们想更新映射 我们可以按照下述方法完成更新\NSo now, if we want to update the map, the way we can do that is as follows.
Dialogue: 0,0:05:36.24,0:05:40.42,Default,,0,0,0,,假设我们想把键k的值设置为v\NSo, let's say we want to set the key k to the value v.
Dialogue: 0,0:05:40.42,0:05:42.28,Default,,0,0,0,,首先 我们创建一个新的时间戳\NFirst of all, we make a new timestamp,
Dialogue: 0,0:05:42.28,0:05:46.02,Default,,0,0,0,,我们这里也可以使用Lamport时间戳\Nand we can use a Lamport timestamp, for example, for that.
Dialogue: 0,0:05:46.02,0:05:49.26,Default,,0,0,0,,我们要求此时间戳是全局唯一的\NWhat we do require is that this timestamp is globally unique.
Dialogue: 0,0:05:49.26,0:05:53.28,Default,,0,0,0,,任意两个节点都不会生成相同的时间戳\NSo, any two nodes generating timestamps will not generate an identical timestamp.
Dialogue: 0,0:05:53.28,0:05:56.96,Default,,0,0,0,,如果你还记得 Lamport时间戳实现这一要求的方法是\NAnd if you remember, the way we can do that with Lamport timestamps is
Dialogue: 0,0:05:56.96,0:06:01.32,Default,,0,0,0,,节点在生成时间戳时 让时间戳包含节点id\Nby including the node id of the node that generated a particular timestamp.
Dialogue: 0,0:06:01.32,0:06:03.28,Default,,0,0,0,,这就可以使生成的时间戳全局唯一\NAnd that will make it globally unique.
Dialogue: 0,0:06:03.28,0:06:06.62,Default,,0,0,0,,我们假设这里的t就是时间戳\NSo, we're assuming this is just t, the timestamp.
Dialogue: 0,0:06:06.62,0:06:12.22,Default,,0,0,0,,现在 我们把键、我们想设置的值\NAnd now, we're going to take the key and the value that we wanted to set,
Dialogue: 0,0:06:12.22,0:06:14.44,Default,,0,0,0,,以及我们刚刚生成的时间戳\Nand that timestamp that we just generated,
Dialogue: 0,0:06:14.44,0:06:18.96,Default,,0,0,0,,打包到一条消息中 并通过可靠广播发送这条消息\Npacked this all together into a message, and sent that by a reliable broadcast.
Dialogue: 0,0:06:18.96,0:06:22.26,Default,,0,0,0,,回忆一下 可靠广播的意思是\NSo, remember that reliable broadcast means
Dialogue: 0,0:06:23.02,0:06:26.16,Default,,0,0,0,,任意两个节点只要没有崩溃\Nas long as any two nodes are not crashed,
Dialogue: 0,0:06:26.16,0:06:29.02,Default,,0,0,0,,它们最终都会传递相同的消息集合\Nthen they will deliver eventually the same set of messages,
Dialogue: 0,0:06:29.02,0:06:31.30,Default,,0,0,0,,但我们不对消息的传递顺序\Nbut we're not making any guarantees about the order
Dialogue: 0,0:06:31.30,0:06:33.06,Default,,0,0,0,,提供任何保证\Nin which those messages get delivered.
Dialogue: 0,0:06:33.98,0:06:40.44,Default,,0,0,0,,特别地 此广播也会给发送此条消息的节点本身发送这条消息\NAnd in particular, this broadcast will also be delivered to the node that sent it itself.
Dialogue: 0,0:06:40.44,0:06:41.66,Default,,0,0,0,,这就涉及到下面这部分的处理过程\NAnd that's what happens here.
Dialogue: 0,0:06:41.66,0:06:46.42,Default,,0,0,0,,当我们通过可靠广播传递其中一条消息时\NSo, when we deliver one of these messages here via reliable broadcast,
Dialogue: 0,0:06:46.42,0:06:48.30,Default,,0,0,0,,我们首先判断\Nfirst of all, we figure out
Dialogue: 0,0:06:48.30,0:06:54.94,Default,,0,0,0,,在值集合中是否存在相同的键k\Nare there any existing values in our set of values for the same key k.
Dialogue: 0,0:06:54.94,0:06:56.78,Default,,0,0,0,,我们在值集合中尝试寻找\NSo, we find any entries in this
Dialogue: 0,0:06:56.78,0:07:02.42,Default,,0,0,0,,哪个条目的键等于更新消息中包含的键\Nwhere the key of the entry equals the key of the update that we're making.
Dialogue: 0,0:07:02.42,0:07:04.24,Default,,0,0,0,,我们将previous（上一个条目）设置为找到的条目\NAnd we set that to previous.
Dialogue: 0,0:07:04.24,0:07:10.26,Default,,0,0,0,,如果没有找到键k所对应的条目 previous就等于空集合\NAnd so now, this could be an empty set if there is no existing value for the key k,
Dialogue: 0,0:07:10.26,0:07:12.08,Default,,0,0,0,,这种情况下 我们继续往前\Nin which case, we go ahead.
Dialogue: 0,0:07:12.72,0:07:16.88,Default,,0,0,0,,我们查看上一个条目中的时间戳\NAlso, we look at the timestamp of any previous value.
Dialogue: 0,0:07:16.88,0:07:23.18,Default,,0,0,0,,如果键为k的上一个条目的时间戳为t’ \NSo, if there is a previous value for this particular k with a timestamp t’,
Dialogue: 0,0:07:23.18,0:07:28.14,Default,,0,0,0,,且如果此时间戳t’小于更新的时间戳t\Nand if that timestamp t’ is less than the timestamp t of the incoming update,
Dialogue: 0,0:07:28.14,0:07:29.92,Default,,0,0,0,,则我们覆盖键映射的值\Nthen we overwrite it.
Dialogue: 0,0:07:29.92,0:07:34.28,Default,,0,0,0,,如果不存在上一个条目\NSo, if this is the case that
Dialogue: 0,0:07:34.28,0:07:38.40,Default,,0,0,0,,或者上一个条目所关联的时间戳更小\Neither there is no previous value or the previous value has a lower timestamp,
Dialogue: 0,0:07:38.40,0:07:41.46,Default,,0,0,0,,则我们将上一个值从值集合中移除\Nthen we're going to remove the previous value from the set of values,
Dialogue: 0,0:07:41.46,0:07:43.66,Default,,0,0,0,,我们在值集合中增加一个新映射\Nand we're going to add the new mapping
Dialogue: 0,0:07:43.66,0:07:47.34,Default,,0,0,0,,新映射为k映射到v 关联的时间戳为t\Nfrom k to v with timestamp t to the set of values.
Dialogue: 0,0:07:48.00,0:07:55.54,Default,,0,0,0,,这可以保证给定一个键 值集合最多只存在一个对应的条目\NNow, this ensures that there is exact up-to-one entry in the set values for a given key.
Dialogue: 0,0:07:55.54,0:07:59.08,Default,,0,0,0,,因此 这里“找到所有满足条件条目”的意思是\NAnd so, therefore, this for all here actually just means
Dialogue: 0,0:07:59.08,0:08:04.50,Default,,0,0,0,,如果能找到 也只可能找到一个满足条件的条目\Nit's matching one particular item in the set if it exists.
Dialogue: 0,0:08:04.50,0:08:10.96,Default,,0,0,0,,这个算法足以满足强最终一致性\NAnd this is enough to ensure a strong eventual consistency.
Dialogue: 0,0:08:10.96,0:08:15.30,Default,,0,0,0,,正如我前面所说 这个算法的工作机制是广播这些消息\NSo, the way that this algorithm works, as I said, is by broadcasting just these messages.
Dialogue: 0,0:08:15.30,0:08:18.76,Default,,0,0,0,,这些消息描述了要更新的键是什么\NAnd the messages describe what the key is that's being updated,
Dialogue: 0,0:08:18.76,0:08:21.38,Default,,0,0,0,,以及与此键关联的新值是什么\Nand what is the new value being associated with that key.
Dialogue: 0,0:08:21.38,0:08:23.60,Default,,0,0,0,,在我们的日历更新例子中\NAnd so, in our calendar example,
Dialogue: 0,0:08:23.60,0:08:27.48,Default,,0,0,0,,键可能为字段名 即标题、名称或日期\Nthe keys might be the field name, so title or name or date,
Dialogue: 0,0:08:27.48,0:08:32.58,Default,,0,0,0,,值与特定的字段名相关联\Nand the value that were associated with that particular field.
Dialogue: 0,0:08:32.58,0:08:37.48,Default,,0,0,0,,回忆一下我们之前讨论的强一致性概念\NNow, remember what we talked about the concept of strong eventual consistency.
Dialogue: 0,0:08:37.48,0:08:42.94,Default,,0,0,0,,这正是我们在此类应用中希望满足的一致性模型\NThis is exactly the consistency model that we want to ensure in an application like this.
Dialogue: 0,0:08:42.94,0:08:46.36,Default,,0,0,0,,强一致性包含两个性质\NAnd strong eventual consistency consists of two properties.
Dialogue: 0,0:08:46.36,0:08:51.78,Default,,0,0,0,,第一个性质是 所有更新操作最终都会被传递到每个副本\NFirst of all, we want that every update is eventually delivered by every replica
Dialogue: 0,0:08:51.78,0:08:53.62,Default,,0,0,0,,只要副本没有崩溃 它就会收到更新操作\Nas long as that replica is not crashed.
Dialogue: 0,0:08:53.62,0:08:54.72,Default,,0,0,0,,第二个性质是\NAnd then, secondly,
Dialogue: 0,0:08:54.72,0:09:00.08,Default,,0,0,0,,处理相同更新操作的任意两个副本最终都会收敛到相同的状态\Nany two replicas that have processed the same updates must be in the same state.
Dialogue: 0,0:09:00.08,0:09:03.20,Default,,0,0,0,,在刚刚介绍的CRDT算法中\NNow, the way we achieve the eventual delivery
Dialogue: 0,0:09:03.20,0:09:06.10,Default,,0,0,0,,我们使用可靠广播\Nin this CRDT algorithm that I just showed you is
Dialogue: 0,0:09:06.10,0:09:07.40,Default,,0,0,0,,来保证消息最终都能被传递\Nby using reliable broadcasts.
Dialogue: 0,0:09:07.40,0:09:10.30,Default,,0,0,0,,这正是可靠广播所能保证的\NAnd this is exactly what reliable broadcast ensures.
Dialogue: 0,0:09:10.30,0:09:12.60,Default,,0,0,0,,可靠广播保证\NIt ensures that
Dialogue: 0,0:09:12.60,0:09:16.76,Default,,0,0,0,,任意两个未崩溃节点最终都可以传递相同的消息集合\Nany two non-crashed nodes will eventually deliver the same set of messages.
Dialogue: 0,0:09:17.62,0:09:21.70,Default,,0,0,0,,进一步 应用可靠广播传递的消息\NFurthermore, the process for updating a replica state
Dialogue: 0,0:09:21.70,0:09:25.12,Default,,0,0,0,,来更新副本状态的处理过程\Nwhen it delivers one of these messages by reliable broadcast,
Dialogue: 0,0:09:25.12,0:09:27.36,Default,,0,0,0,,这一处理过程满足交换律\Nthis process is commutative,
Dialogue: 0,0:09:27.36,0:09:34.14,Default,,0,0,0,,这意味着我们可以按照任意顺序应用这些不同的操作\Nand which means that we can apply these various operations here in any order,
Dialogue: 0,0:09:34.14,0:09:36.56,Default,,0,0,0,,且最终的输出都是相同的\Nand the final outcome will be the same.
Dialogue: 0,0:09:36.56,0:09:38.38,Default,,0,0,0,,可能需要思考一下 才理解更新过程满足交换律\NSo, this might require a little bit of thinking.
Dialogue: 0,0:09:38.38,0:09:40.26,Default,,0,0,0,,讲义中有一个练习\NAnd there's an exercise in the lecture notes
Dialogue: 0,0:09:40.26,0:09:43.16,Default,,0,0,0,,这个练习要求你证明 对于这个特定的算法\Nasking you to actually prove for this particular algorithm
Dialogue: 0,0:09:43.16,0:09:48.04,Default,,0,0,0,,应用操作更新副本的过程满足交换律\Nthat the process of applying an operation really is commutative.
Dialogue: 0,0:09:48.04,0:09:53.18,Default,,0,0,0,,这称为基于操作CRDT\NNow, this is called an operation-based CRDT.
Dialogue: 0,0:09:53.18,0:09:54.98,Default,,0,0,0,,这是一个基于操作CRDT的实例\NIt's an example of an operation-based CRDT,
Dialogue: 0,0:09:54.98,0:09:58.34,Default,,0,0,0,,因为我们广播的消息是操作\Nbecause the things that we're broadcasting are operations.
Dialogue: 0,0:09:58.34,0:10:01.66,Default,,0,0,0,,每条广播消息传递的都是一个操作\NSo, it's one operation at a time in each broadcast.
Dialogue: 0,0:10:01.66,0:10:05.46,Default,,0,0,0,,这要求广播是可靠的\NSo, this does require the broadcast to be reliable,
Dialogue: 0,0:10:05.46,0:10:08.62,Default,,0,0,0,,因为如果你丢失了一条消息\Nbecause otherwise if you're missing a message,
Dialogue: 0,0:10:08.62,0:10:12.52,Default,,0,0,0,,你的状态就永远无法与其他节点一致\Nthen you will never end up in a consistent state with the other nodes necessarily.
Dialogue: 0,0:10:13.76,0:10:17.32,Default,,0,0,0,,我们还可以使用另一种CRDT构造\NThere's an alternative construction for CRDTs that we can use,
Dialogue: 0,0:10:17.32,0:10:19.76,Default,,0,0,0,,称为基于状态构造\Nwhich is called a state-based construction.
Dialogue: 0,0:10:19.76,0:10:22.92,Default,,0,0,0,,这里的例子使用了完全一样的映射数据类型\NAnd here's an example of exactly the same map data type,
Dialogue: 0,0:10:22.92,0:10:27.20,Default,,0,0,0,,但实现方法是基于状态的 而不是基于操作的\Nbut implemented in a state-based way rather than in an operation-based way.
Dialogue: 0,0:10:27.20,0:10:29.80,Default,,0,0,0,,在基于状态CRDT中\NAnd so, with a state-based CRDT,
Dialogue: 0,0:10:29.80,0:10:33.06,Default,,0,0,0,,你总会使用到合并运算符或这里的合并函数\Nyou always have a merge operator or this merge function,
Dialogue: 0,0:10:33.06,0:10:37.04,Default,,0,0,0,,通常把合并函数写成类似于并集运算符的形式\Nwhich is usually written as like a set union operator,
Dialogue: 0,0:10:37.04,0:10:39.30,Default,,0,0,0,,但符号是方形的而不是圆形的\Nbut square rather than round.
Dialogue: 0,0:10:39.30,0:10:44.50,Default,,0,0,0,,这个合并运算符必须满足一些性质\NAnd this merge operator here must satisfy several properties
Dialogue: 0,0:10:44.50,0:10:46.90,Default,,0,0,0,,我将在下一页幻灯片阐述这些性质\Nthat I will explain on the next slide.
Dialogue: 0,0:10:47.42,0:10:50.88,Default,,0,0,0,,对于这一特定算法 我们按照下述方法来定义合并运算符\NAnd in this particular algorithm, we will define the merge operator like this.
Dialogue: 0,0:10:50.88,0:10:57.10,Default,,0,0,0,,合并运算符以两个值集合作为输入 这里的输入是s_1和s_2\NSo, the merge operator is going to take two sets of values, in this case, s_1 and s_2.
Dialogue: 0,0:10:57.10,0:10:59.48,Default,,0,0,0,,这些值集合中的条目\NThese are sets of values of exactly the same form
Dialogue: 0,0:10:59.48,0:11:01.56,Default,,0,0,0,,与基于操作CRDT中的集合条目完全一致\Nas we had in the operation-based version,
Dialogue: 0,0:11:01.56,0:11:05.70,Default,,0,0,0,,即由时间戳、键和值组成的三元组\Nthat is, the triples of timestamp, key, and value.
Dialogue: 0,0:11:05.70,0:11:09.18,Default,,0,0,0,,为了合并两个值集合\NAnd in order to merge these two sets of values,
Dialogue: 0,0:11:09.18,0:11:14.66,Default,,0,0,0,,我们将取出s_1和s_2的并集 取出两个集合中的所有三元组\Nwe're going to take the set union of s_1 and s_2, take all of the triples in there,
Dialogue: 0,0:11:14.66,0:11:16.90,Default,,0,0,0,,对于每一个键\Nand then for every given key,
Dialogue: 0,0:11:16.90,0:11:20.88,Default,,0,0,0,,我们只保留最大时间戳和对应的值\Nwe're going to keep only the value with the highest timestamp.
Dialogue: 0,0:11:20.88,0:11:24.32,Default,,0,0,0,,我们将丢弃该特定键的所有旧时间戳\NAnd we're going to throw away any older timestamps for that particular key.
Dialogue: 0,0:11:24.32,0:11:26.24,Default,,0,0,0,,这是通过这个逻辑来实现的\NAnd that's implemented by this logic here.
Dialogue: 0,0:11:26.24,0:11:29.66,Default,,0,0,0,,我们只保留满足下述条件的三元组：\NSo, for every given triple, we keep only those
Dialogue: 0,0:11:29.66,0:11:33.62,Default,,0,0,0,,给定留下的三元组 集合中不存在其他三元组\Nwhere there does not exist another triple in the same set
Dialogue: 0,0:11:33.62,0:11:36.44,Default,,0,0,0,,此三元组的键与留下三元组的键相同 且时间戳更大\Nthat has the same key but a higher timestamp.
Dialogue: 0,0:11:36.44,0:11:40.74,Default,,0,0,0,,合并运算符的效果是 对于任意给定键 我们只留下最大的时间戳\NAnd the effect of this is that we keep only the highest timestamp for every given key.
Dialogue: 0,0:11:40.74,0:11:43.72,Default,,0,0,0,,给定合并运算符\NOK, so, given this merge operator here,
Dialogue: 0,0:11:43.72,0:11:46.96,Default,,0,0,0,,算法的剩余部分看起来就很熟悉了\Nnow, the rest of the algorithm looks kind of familiar.
Dialogue: 0,0:11:46.96,0:11:51.26,Default,,0,0,0,,初始化过程完全一致 我们将values初始化为空集合\NSo, the initialization is exactly the same. We initialize values to be the empty set.
Dialogue: 0,0:11:51.26,0:11:54.50,Default,,0,0,0,,读取一个键的过程也与前面完全相同\NThe process of reading a key is exactly the same as previously,
Dialogue: 0,0:11:54.50,0:12:00.50,Default,,0,0,0,,给定一个键 我们在值集合中尝试寻找此键的三元组\Nso, that is, given a key, we try and find any triple with that key in the set values,
Dialogue: 0,0:12:00.50,0:12:04.20,Default,,0,0,0,,如果存在此键的三元组 则返回对应的值\Nand we return the value from that triple if it exists.
Dialogue: 0,0:12:04.20,0:12:07.88,Default,,0,0,0,,更新给定键对应值的处理过程不太一样\NNow, the process for updating the value for a given key, this is different.
Dialogue: 0,0:12:07.88,0:12:12.22,Default,,0,0,0,,这里和之前一样 我们生成一个新的时间戳\NAnd so, here, as before, we generate a new timestamp,
Dialogue: 0,0:12:12.22,0:12:14.48,Default,,0,0,0,,同样也可以使用Lamport时间戳\Ncan be a Lamport timestamp as before.
Dialogue: 0,0:12:14.48,0:12:18.56,Default,,0,0,0,,现在 我们不广播操作本身\NAnd now, rather than broadcasting this operation,
Dialogue: 0,0:12:18.56,0:12:21.48,Default,,0,0,0,,我们直接更新值集合\Nwe're just going to update the set of values directly.
Dialogue: 0,0:12:21.48,0:12:24.74,Default,,0,0,0,,我们更新值集合的方法是\NAnd so, we're going to update it in such a way that
Dialogue: 0,0:12:24.74,0:12:31.18,Default,,0,0,0,,给定值集合 我们移除所有包含相同键k的条目\Ngiven the set of values, we remove any existing entries with the same key k,
Dialogue: 0,0:12:31.86,0:12:34.54,Default,,0,0,0,,如果没有相同的键 则可能不需要移除任何条目\Nwhich may be none if there is no previous entry,
Dialogue: 0,0:12:34.54,0:12:38.10,Default,,0,0,0,,无论如何 不管键k的当前条目是什么 我们都直接移除此条目\Nbut whatever current entry with key k exists, we're going to remove it.
Dialogue: 0,0:12:38.10,0:12:40.00,Default,,0,0,0,,随后 我们生成一个新的三元组\NAnd then, we're going to add this new triple
Dialogue: 0,0:12:40.00,0:12:42.16,Default,,0,0,0,,此三元组包含了新的时间戳、新的键和新的值\Nwith the new timestamp, the new key, and the new value.
Dialogue: 0,0:12:42.16,0:12:44.34,Default,,0,0,0,,我们将新三元组添加至值集合\NWe're going to add that to a set of values.
Dialogue: 0,0:12:44.34,0:12:50.40,Default,,0,0,0,,现在 我们向其他所有副本广播整个值集合\NAnd now, we're going to broadcast this entire set of values to any other replicas.
Dialogue: 0,0:12:50.40,0:12:53.26,Default,,0,0,0,,我们不广播操作本身\NSo, rather than broadcasting the operation,
Dialogue: 0,0:12:53.26,0:12:58.36,Default,,0,0,0,,我们广播整个副本的状态 这里就是广播集合values\Nwe're broadcasting the entire state of the replica, which is here this value values.
Dialogue: 0,0:12:58.36,0:13:01.46,Default,,0,0,0,,这就是为什么此算法被称为基于状态CRDT的原因\NAnd this is why it's called a state-based CRDT,
Dialogue: 0,0:13:01.46,0:13:04.10,Default,,0,0,0,,因为我们现在广播的是值集合中的所有条目\Nbecause the thing we're broadcasting are these values.
Dialogue: 0,0:13:04.10,0:13:08.82,Default,,0,0,0,,现在 当节点传递值集合V时\NAnd now, when this set of values V here is delivered,
Dialogue: 0,0:13:08.82,0:13:15.04,Default,,0,0,0,,我们使用合并函数来合并收到的值集合与接收方的值集合\Nwe use the merge function in order to merge that with the recipient's set of values.
Dialogue: 0,0:13:15.04,0:13:18.70,Default,,0,0,0,,这意味着副本可以从网络中接收传来传去的值集合\NAnd so, this means you've got these sets of values flying around,
Dialogue: 0,0:13:18.70,0:13:20.86,Default,,0,0,0,,值集合也可能按照任意顺序传递\Nwhich may be delivered in arbitrary orders,
Dialogue: 0,0:13:22.20,0:13:28.54,Default,,0,0,0,,当每个副本收到这些值集合时\Nand the end result is just each replica when it receives one of these set of values,
Dialogue: 0,0:13:28.54,0:13:31.14,Default,,0,0,0,,它只是将其与自己的本地状态合并\Nit just merges it into its own local state.
Dialogue: 0,0:13:31.14,0:13:35.06,Default,,0,0,0,,无论值集合在网络中如何传来传去\NAnd as a result, it keeps just maintaining the state
Dialogue: 0,0:13:35.06,0:13:39.52,Default,,0,0,0,,副本只需要根据收到的值集合维护自己的存储状态\Nthat is the latest version of whatever has been flying around.
Dialogue: 0,0:13:39.52,0:13:41.70,Default,,0,0,0,,这里有一个有趣的地方值得注意\NSo, the interesting thing to note here is that
Dialogue: 0,0:13:41.70,0:13:47.14,Default,,0,0,0,,我前面讲到 这里不需要使用可靠广播 只需要使用尽力广播\NI said that we can broadcast by best-effort broadcast rather than by reliable broadcast.
Dialogue: 0,0:13:47.14,0:13:49.44,Default,,0,0,0,,这的确是一个差异点\NAnd this is indeed a distinction
Dialogue: 0,0:13:49.44,0:13:52.92,Default,,0,0,0,,这是基于状态方法和基于操作方法的一个差异点\Nbetween the state-based approach and the operation-based approach
Dialogue: 0,0:13:52.92,0:13:54.48,Default,,0,0,0,,我们后面会详细解释一下\Nas we will see in a moment.
Dialogue: 0,0:13:54.48,0:13:56.90,Default,,0,0,0,,我们先来看看合并运算符要满足的性质\NSo, first of all, about this merge operator.
Dialogue: 0,0:13:56.90,0:14:01.88,Default,,0,0,0,,为了使合并运算符可以正确运作 合并运算符必须满足一些条件\NSo, this merge operator, for it to work correctly, it must satisfy several conditions.
Dialogue: 0,0:14:01.88,0:14:05.32,Default,,0,0,0,,合并运算符必须满足交换律 使我们可以交换操作的顺序\NIt must be commutative, which means we can swap around the order,
Dialogue: 0,0:14:05.32,0:14:08.60,Default,,0,0,0,,合并运算符必须满足结合律 使我们可以交换括号的位置\Nmust be associative, which means you can swap around the brackets,
Dialogue: 0,0:14:08.60,0:14:12.58,Default,,0,0,0,,合并运算符必须满足幂等性 使它的行为和我们之前讲解的一致\Nand it must be idempotent, which is the behavior that as we saw before,
Dialogue: 0,0:14:12.58,0:14:16.56,Default,,0,0,0,,你可以将自己的状态合并给自己 运算结果不会发生任何改变\Nyou can merge a state with itself and that does not change anything.
Dialogue: 0,0:14:16.56,0:14:21.64,Default,,0,0,0,,如果我们能构造出一个满足这些条件的合并运算符\NAnd if we have a merge operator that satisfies these constructions,
Dialogue: 0,0:14:21.64,0:14:24.76,Default,,0,0,0,,我们就可以基于此合并运算符构造出基于状态CRDT\Nthen we can build a state-based CRDT out of it
Dialogue: 0,0:14:24.76,0:14:26.72,Default,,0,0,0,,方法很简单 就是广播所有状态\Nsimply by broadcasting the states
Dialogue: 0,0:14:26.72,0:14:30.60,Default,,0,0,0,,当从其他副本收到一个状态时 副本将收到的状态与本地状态合并\Nand merging them whenever we receive the state from another replica.
Dialogue: 0,0:14:30.60,0:14:35.08,Default,,0,0,0,,基于操作CRDT和基于状态CRDT之间有一个权衡点\NNow, there's a trade-off here between operation-based and state-based CRDTs.
Dialogue: 0,0:14:35.08,0:14:38.30,Default,,0,0,0,,在讲解基于操作CRDT时 我们已经看到\NSo, as we saw with the operation-based CRDTs,
Dialogue: 0,0:14:38.30,0:14:40.88,Default,,0,0,0,,基于操作CRDT广播的消息只包含单个操作\Nthe broadcast messages contain just a single operation.
Dialogue: 0,0:14:40.88,0:14:45.46,Default,,0,0,0,,包含单个操作的消息长度是非常小的\NSo, those messages containing just one operation are usually quite small.
Dialogue: 0,0:14:45.46,0:14:48.28,Default,,0,0,0,,从网络流量角度看 基于操作方法会更高效\NSo, they're quite efficient in terms of network traffic,
Dialogue: 0,0:14:49.08,0:14:52.38,Default,,0,0,0,,与基于状态方法相比较\Nbecause compared to the state-based approach
Dialogue: 0,0:14:52.38,0:14:55.36,Default,,0,0,0,,基于状态方法中 副本需要广播自己的整个状态\Nwhere a replica needs to broadcast its entire state,
Dialogue: 0,0:14:55.36,0:14:57.38,Default,,0,0,0,,自己的整个状态可能包含大量的数据\Nthat might be a much bigger amount of data.
Dialogue: 0,0:14:57.38,0:15:00.30,Default,,0,0,0,,想象一个包含大量键的键值映射\NImagine a key-value mapping that has lots of keys in it.
Dialogue: 0,0:15:00.30,0:15:01.52,Default,,0,0,0,,你需要在每一条消息中\NYou're going to be sending
Dialogue: 0,0:15:01.52,0:15:05.82,Default,,0,0,0,,发送所有键和所有关联的值\Nall of the keys and all of the values associated with them in every single message.
Dialogue: 0,0:15:05.82,0:15:08.84,Default,,0,0,0,,因此 基于操作方法的优点是\NSo, here, the advantage of the operation-based approach is that
Dialogue: 0,0:15:08.84,0:15:10.72,Default,,0,0,0,,此种方法的消息通常会更短\Nit has smaller messages typically.
Dialogue: 0,0:15:11.36,0:15:16.50,Default,,0,0,0,,基于状态方法拥有更长的消息 但此方法可以容忍消息丢失\NState-based approach has larger messages, but it can tolerate messages being lost.
Dialogue: 0,0:15:16.50,0:15:18.10,Default,,0,0,0,,这是一个很有趣的性质\NAnd this is quite interesting here.
Dialogue: 0,0:15:18.10,0:15:19.50,Default,,0,0,0,,基于状态方法也可以容忍重复消息\NIt can also tolerate duplication.
Dialogue: 0,0:15:19.50,0:15:22.66,Default,,0,0,0,,原因很简单 因为合并函数满足幂等性\NDuplication is easy, because we have idempotence in the merge function.
Dialogue: 0,0:15:22.66,0:15:26.22,Default,,0,0,0,,即使收到重复的消息 副本正常处理即可 无需额外操作\NTherefore, if you receive duplicates, you'll just do nothing.
Dialogue: 0,0:15:27.06,0:15:29.46,Default,,0,0,0,,基于状态方法甚至可以容忍消息丢失\NBut even with message loss, it can tolerate this,
Dialogue: 0,0:15:29.46,0:15:33.80,Default,,0,0,0,,因为整个状态都被编码在每条消息中\Nbecause the entire state is encoded in every single message.
Dialogue: 0,0:15:33.80,0:15:36.42,Default,,0,0,0,,如果你在某个地方错过了一条消息\NSo, if you miss a message somewhere along the way,
Dialogue: 0,0:15:36.42,0:15:38.78,Default,,0,0,0,,只要你能够收到后续的消息\Nas long as you receive some later messages,
Dialogue: 0,0:15:38.78,0:15:42.74,Default,,0,0,0,,后续消息总可以取代之前的消息\Nthat later message will supersede any previous messages anyway.
Dialogue: 0,0:15:42.74,0:15:48.74,Default,,0,0,0,,这实际上可以保证 即使你在中间错过了一些消息\NAnd this actually ensures then that you will get convergence of the replicas
Dialogue: 0,0:15:49.08,0:15:51.50,Default,,0,0,0,,副本状态仍然会收敛\Neven if you've missed some of the messages in the middle.
Dialogue: 0,0:15:51.50,0:15:55.18,Default,,0,0,0,,这是一个非常好的性质 因为基于状态CRDT\NAnd so, this is quite nice now, because with state-based CRDT,
Dialogue: 0,0:15:55.18,0:15:59.32,Default,,0,0,0,,不需要引入可靠广播协议带来的开销\Nyou don't need to involve the costs of a reliable broadcast protocol,
Dialogue: 0,0:15:59.32,0:16:03.10,Default,,0,0,0,,CRDT自己就可以处理网络不可靠的问题\Nbecause the CRDT itself can deal with unreliability.
Dialogue: 0,0:16:03.72,0:16:06.66,Default,,0,0,0,,当然了 如果所有消息都无法传输成功 副本状态也没办法收敛\NOf course, if no messages are ever delivered, then it won't converge.
Dialogue: 0,0:16:06.66,0:16:10.94,Default,,0,0,0,,但只要有些消息能够最终传输成功\NBut as long as eventually some of the messages get through,
Dialogue: 0,0:16:10.94,0:16:14.20,Default,,0,0,0,,你就可以得到收敛的副本\Nthen you can still get convergence properties.
Dialogue: 0,0:16:14.20,0:16:18.42,Default,,0,0,0,,基于状态CRDT的另一个优异性质是\NAnother nice thing about state-based CRDT is
Dialogue: 0,0:16:18.42,0:16:22.52,Default,,0,0,0,,我这里使用基于广播的复制协议实现基于状态CRDT\Nhere I wrote it based on a replication protocol based on broadcast,
Dialogue: 0,0:16:22.52,0:16:25.54,Default,,0,0,0,,你也可以用其他形式的复制协议来实现基于状态CRDT\Nbut you can actually use it in other forms of replication as well,
Dialogue: 0,0:16:25.54,0:16:27.64,Default,,0,0,0,,其他形式的复制协议可以不基于广播\Nwhere it's not actually a broadcast protocol,
Dialogue: 0,0:16:27.64,0:16:31.58,Default,,0,0,0,,如果你还记得第5课的内容 我记得是讲复制的那节课\Nbut if you remember back lecture 5, I think it was on replication,
Dialogue: 0,0:16:31.58,0:16:34.10,Default,,0,0,0,,我们有quorum复制思想\Nwe had these ideas of quorum replication,
Dialogue: 0,0:16:34.10,0:16:37.92,Default,,0,0,0,,客户端可以将更新发送给quorum副本\Nwhere a client sends an update to a quorum of replicas,
Dialogue: 0,0:16:37.92,0:16:42.04,Default,,0,0,0,,副本自身可能通过一个反熵协议\Nand then maybe the replicas have an anti-entropy protocol amongst themselves
Dialogue: 0,0:16:42.04,0:16:47.46,Default,,0,0,0,,来尝试解决它们所看到更新操作中包含的任何差异和冲突\Nin order to try and resolve any differences in the updates that they've seen.
Dialogue: 0,0:16:47.46,0:16:51.70,Default,,0,0,0,,基于状态CRDT在这种场景下也可以很好地运作\NAnd state-based CRDT work very well in this particular setting as well,
Dialogue: 0,0:16:51.70,0:16:56.78,Default,,0,0,0,,可以让副本通过某种反熵协议\Nwhere you've got these replicas that want to exchange their updates
Dialogue: 0,0:16:57.16,0:16:59.72,Default,,0,0,0,,来交换更新操作\Nthrough some kind of anti-entropy protocol.
Dialogue: 0,0:16:59.72,0:17:04.02,Default,,0,0,0,,这就是一个映射CRDT的例子\NOK, so, this has been an example of a map CRDT.
Dialogue: 0,0:17:04.02,0:17:06.60,Default,,0,0,0,,我们的数据类型是一个键值映射\NSo, our data type was a map from keys to values.
Dialogue: 0,0:17:06.60,0:17:10.64,Default,,0,0,0,,我们也可以针对其他数据类型和其他应用类型\NWe can construct this kind of concurrency control
Dialogue: 0,0:17:10.64,0:17:14.24,Default,,0,0,0,,构建类似的并发控制协议\Nfor other types of applications and other data types as well.
Dialogue: 0,0:17:14.24,0:17:20.26,Default,,0,0,0,,一个值得考虑的有趣例子是协作文本编辑器 例如谷歌文档\NAnd so, one interesting one to consider are collaborative text editors, like Google Docs.
Dialogue: 0,0:17:20.26,0:17:23.16,Default,,0,0,0,,我这里给大家实际演示一下\NSo, let me give you an actual demo of this.
Dialogue: 0,0:17:23.16,0:17:24.64,Default,,0,0,0,,我认为这个例子非常有意思\NI think this makes a bit more interesting.
Dialogue: 0,0:17:24.64,0:17:27.26,Default,,0,0,0,,我这里打开了两个谷歌文档窗口\NSo, I have here two windows of Google Docs.
Dialogue: 0,0:17:27.26,0:17:31.66,Default,,0,0,0,,你可以看到 如果我在上面的窗口键入信息 下面的窗口也会显示此信息\NAnd you can see, if I type in one of them, this appears in the other window.
Dialogue: 0,0:17:31.66,0:17:34.10,Default,,0,0,0,,我可以切换到下面的窗口 键入一个笑脸\NAnd I can go down here, and I can add a smiley,
Dialogue: 0,0:17:34.10,0:17:37.10,Default,,0,0,0,,上面的窗口也会显示键入的笑脸\Nand this will appear in the top window as well.
Dialogue: 0,0:17:38.00,0:17:41.80,Default,,0,0,0,,大家已经很熟悉这个功能了 相信大家之前用过类似的软件\NSo far, this is probably familiar. You've probably used this kind of software before.
Dialogue: 0,0:17:41.80,0:17:43.54,Default,,0,0,0,,现在 有趣的事情是\NNow, the interesting thing is
Dialogue: 0,0:17:43.54,0:17:49.14,Default,,0,0,0,,如果两个设备之间的网络通信断开一段时间 会发生什么\Nwhat happens if these devices get disconnected from each other for a little while.
Dialogue: 0,0:17:49.14,0:17:51.94,Default,,0,0,0,,我们来构造这样一个场景\NSo, let's set things up like this.
Dialogue: 0,0:17:51.94,0:17:53.96,Default,,0,0,0,,我在上面的窗口输入单词“Two”\NSo, I write the word Two here.
Dialogue: 0,0:17:53.96,0:17:57.14,Default,,0,0,0,,我现在切换到网络设置窗口\NAnd I'm going to go into now my network settings.
Dialogue: 0,0:17:57.14,0:18:01.38,Default,,0,0,0,,我修改网络配置 让其丢弃所有的网络数据包\NI'm going to fiddle with the network to drop all of the network packets.
Dialogue: 0,0:18:01.38,0:18:04.38,Default,,0,0,0,,现在 这两个应用仍然可以运作\NAnd so, now, these two apps will still work.
Dialogue: 0,0:18:04.38,0:18:06.88,Default,,0,0,0,,我可以在上面的窗口输入“One Two”\NAnd at the top, I can type One Two.
Dialogue: 0,0:18:06.88,0:18:09.44,Default,,0,0,0,,我可以在下面的窗口输入“Two Three”\NAnd at the bottom, I can type Two Three.
Dialogue: 0,0:18:09.44,0:18:13.40,Default,,0,0,0,,谷歌文档没有意识到我的网络已经断开\NAnd Google Docs hasn't realized yet that my network is disconnected.
Dialogue: 0,0:18:13.40,0:18:15.68,Default,,0,0,0,,它仍然让我在这里开心的打字\NSo, it's just happily letting me type here.
Dialogue: 0,0:18:15.68,0:18:19.48,Default,,0,0,0,,但你可以看到 文档的两个拷贝出现了分歧\NBut you can see that the two copies of the document have diverged.
Dialogue: 0,0:18:19.48,0:18:23.30,Default,,0,0,0,,文档的两个拷贝临时出现了彼此不一致的情况\NSo, they are ended up being temporarily inconsistent with each other.
Dialogue: 0,0:18:23.30,0:18:26.04,Default,,0,0,0,,当网络连接被修复后\NAnd as the network connection is repaired,
Dialogue: 0,0:18:26.04,0:18:29.66,Default,,0,0,0,,我们希望两个副本回到一致的状态\Nwe will want those to end up back in a consistent state.
Dialogue: 0,0:18:29.66,0:18:33.38,Default,,0,0,0,,我修复了网络 大家看可以观察到底发生了什么\NSo, let's say, I repair the network, and you can see exactly what has happened.
Dialogue: 0,0:18:33.38,0:18:36.44,Default,,0,0,0,,谷歌文档可以合并更新操作\NSo, Google Docs has been able to merge these updates.
Dialogue: 0,0:18:36.44,0:18:41.28,Default,,0,0,0,,增加的“One”传递到了下方窗口 下方窗口的文档中增加了“One”\NSo, the addition of One has gone down and been added to the lower document.
Dialogue: 0,0:18:41.28,0:18:44.58,Default,,0,0,0,,增加的“Three”也被添加进上方窗口的文档中\NAnd the addition of Three has been added to the top document.
Dialogue: 0,0:18:44.58,0:18:49.40,Default,,0,0,0,,我们最终自动得到“One Two Three”的合并结果\NSo, we ended up with One Two Three as the merged result automatically.
Dialogue: 0,0:18:49.40,0:18:53.86,Default,,0,0,0,,我们不需要解决任何冲突问题 不需要做任何额外处理\NWe didn't have to do any conflict resolution here or do anything particular.
Dialogue: 0,0:18:53.86,0:18:56.88,Default,,0,0,0,,谷歌文档自动识别出了我们想要的是什么\NGoogle Docs just figured out by itself what we wanted,
Dialogue: 0,0:18:56.88,0:19:00.24,Default,,0,0,0,,并自动帮我们合并了文档\Nand just gave us the merged document automatically.
Dialogue: 0,0:19:00.24,0:19:05.44,Default,,0,0,0,,我们来看看实现协作编辑的一些算法\NSo, let's look at some algorithms that can achieve this kind of collaborative editing.
Dialogue: 0,0:19:05.44,0:19:13.96,Default,,0,0,0,,先让我通过一个例子给大家展示一下\NAnd let me show you by an example the problem that arises
Dialogue: 0,0:19:13.96,0:19:18.42,Default,,0,0,0,,当我们尝试构建这类协作编辑软件时会遇到什么问题\Nwhen we try to build this kind of collaborative editing software.
Dialogue: 0,0:19:18.42,0:19:23.64,Default,,0,0,0,,假设我们有一个包含B和C这两个字符的文档\NSo, let's say we here have got a document consisting of two characters B and C.
Dialogue: 0,0:19:23.64,0:19:25.56,Default,,0,0,0,,我们允许用户\NAnd we're going to allow users
Dialogue: 0,0:19:25.56,0:19:28.56,Default,,0,0,0,,以插入和删除字符的方式编辑文档\Nto edit this document by inserting and deleting characters.
Dialogue: 0,0:19:28.56,0:19:30.24,Default,,0,0,0,,我们像谷歌文档一样\NAnd we're just going to deal with the document
Dialogue: 0,0:19:30.24,0:19:32.80,Default,,0,0,0,,一次仅在文档中增加或删除一个字符\None character at a time, just like Google Docs.
Dialogue: 0,0:19:32.80,0:19:37.76,Default,,0,0,0,,一般来说 每次按键都可以看成在文档中增加或删除一个字符\NEvery single keystroke adds or deletes one character in the document typically.
Dialogue: 0,0:19:37.76,0:19:40.32,Default,,0,0,0,,我们有用户A和用户B\NAnd so, we've got user A and B.
Dialogue: 0,0:19:40.32,0:19:42.78,Default,,0,0,0,,开始时 两个用户的文档处于相同的状态\NThey start off with this in the same state,
Dialogue: 0,0:19:42.78,0:19:47.34,Default,,0,0,0,,文档的索引0包含B、索引1包含C\Nwith a document containing B at index 0 and C at index 1.
Dialogue: 0,0:19:47.34,0:19:54.08,Default,,0,0,0,,现在 假设用户A想要在文档中的索引0插入字母A\NNow, let's say, user A wants to insert the letter A at index 0 in this document.
Dialogue: 0,0:19:54.08,0:19:56.00,Default,,0,0,0,,很明显 处理结果是\NAnd the result then, of course, is that
Dialogue: 0,0:19:56.00,0:19:59.58,Default,,0,0,0,,B变到了索引1 而C变到了索引2\NB ends up at index 1 and C index ends up at index 2.
Dialogue: 0,0:19:59.58,0:20:02.14,Default,,0,0,0,,所有字符的索引向后移动了一位\NSo, the indexes get moved along by 1.
Dialogue: 0,0:20:02.14,0:20:05.12,Default,,0,0,0,,当用户A执行这一操作的同时\NLet's say, concurrently, while this is happening,
Dialogue: 0,0:20:05.12,0:20:09.44,Default,,0,0,0,,假设用户B在并发处理文档 它向在文档末尾插入字母D\Nthe user B wants to insert the letter D at the end of the document.
Dialogue: 0,0:20:09.44,0:20:11.28,Default,,0,0,0,,这和我前面用谷歌文档\NSo, this is just like the example I just showed you
Dialogue: 0,0:20:11.28,0:20:13.18,Default,,0,0,0,,给大家演示的“One Two Three”的例子一样\Nwith Google Docs with the One Two Three,
Dialogue: 0,0:20:13.18,0:20:15.10,Default,,0,0,0,,只是这里是按照单个字母处理的\Nexcept with individual letters.
Dialogue: 0,0:20:15.10,0:20:20.08,Default,,0,0,0,,右侧这里 和我们期望的一样 字母D被插入到索引2\NAnd so here, letter D gets inserted at index 2 as we expect.
Dialogue: 0,0:20:20.08,0:20:22.66,Default,,0,0,0,,现在 我们尝试同步这两个文档\NNow, let's try and synchronize these two.
Dialogue: 0,0:20:22.66,0:20:25.22,Default,,0,0,0,,假设现在网络得到了修复\NSo, let's say, now the network is repaired.
Dialogue: 0,0:20:25.22,0:20:28.36,Default,,0,0,0,,两个节点互相之间又可以通信了\NThe two nodes can connect to each other again.
Dialogue: 0,0:20:28.36,0:20:33.60,Default,,0,0,0,,用户A将发送操作“在索引0插入A”\NAnd so, user A is going to send its operation, insert A at index 0,
Dialogue: 0,0:20:33.60,0:20:35.46,Default,,0,0,0,,用户A把这一操作通过网络发送给用户B\Nwe're going to send that over to user B.
Dialogue: 0,0:20:35.46,0:20:37.22,Default,,0,0,0,,用户B应用此操作\NAnd user B is going to apply that.
Dialogue: 0,0:20:37.22,0:20:41.62,Default,,0,0,0,,用户B将在索引0插入字母A\NSo, user B is going to insert the letter A at index 0.
Dialogue: 0,0:20:41.62,0:20:43.58,Default,,0,0,0,,用户A最终得到的文档是ABCD\NAnd we will end up with the document ABCD,
Dialogue: 0,0:20:43.58,0:20:45.92,Default,,0,0,0,,这就是我们在这个例子中期望得到的合并结果\Nwhich is exactly what we wanted in this case.
Dialogue: 0,0:20:45.92,0:20:47.82,Default,,0,0,0,,此合并结果是正确的\NSo, that has worked fine.
Dialogue: 0,0:20:47.82,0:20:50.64,Default,,0,0,0,,我们来看看 相反方向会发生什么\NLet's look at what happens if we go in the reverse direction.
Dialogue: 0,0:20:50.64,0:20:54.68,Default,,0,0,0,,在相反方向 用户B同样发送他的操作\NSo, in the reverse direction, we take again the operation that happened.
Dialogue: 0,0:20:54.68,0:20:58.36,Default,,0,0,0,,这个例子中 用户B的操作是“在索引2插入字母D”\NSo, in this case, it's insert the letter D at index 2.
Dialogue: 0,0:20:58.36,0:21:03.80,Default,,0,0,0,,用户B通过网络将其发送给用户A 用户A在索引2插入D\NWe send that over to user A. And user A insert D at index 2.
Dialogue: 0,0:21:03.80,0:21:06.98,Default,,0,0,0,,哦不 现在出现错误了\NAnd, oh no, things have gone wrong here,
Dialogue: 0,0:21:06.98,0:21:08.80,Default,,0,0,0,,仔细观察发生的情况\Nbecause if you look what has happened,
Dialogue: 0,0:21:08.80,0:21:14.90,Default,,0,0,0,,在左侧 用户A最终得到的文档是ABDC\Nhere we are on the left, user A we have ended up with the document ABDC,
Dialogue: 0,0:21:14.90,0:21:18.08,Default,,0,0,0,,而在右侧 用户B最终得到的文档是ABCD\Nwhereas on the right, we ended up with the document ABCD.
Dialogue: 0,0:21:18.08,0:21:22.32,Default,,0,0,0,,这两个用户的文档互相不一致了\NAnd the two users are now inconsistent with each other.
Dialogue: 0,0:21:22.32,0:21:24.14,Default,,0,0,0,,这不是我们想要的结果\NThis is not what we wanted.
Dialogue: 0,0:21:24.14,0:21:27.26,Default,,0,0,0,,两个文档之所以不一致\NAnd the reason why they have become inconsistent with each other is
Dialogue: 0,0:21:27.26,0:21:33.28,Default,,0,0,0,,问题出在用户B“在索引2插入D”这里\Nwell, the problem with this insertion of D at index 2 here,
Dialogue: 0,0:21:33.28,0:21:35.18,Default,,0,0,0,,这个操作的问题是\Nthe problem with this operation is
Dialogue: 0,0:21:35.18,0:21:39.46,Default,,0,0,0,,我们不能在左侧文档直接应用这一操作\Nwe can't just directly apply that operation here on the left-hand side,
Dialogue: 0,0:21:39.46,0:21:42.44,Default,,0,0,0,,因为索引2的含义变了\Nbecause index 2 no longer has the same meaning,
Dialogue: 0,0:21:42.44,0:21:45.74,Default,,0,0,0,,因为用户A同时在索引0执行了插入操作\Nbecause we can currently perform this insertion at index 0,
Dialogue: 0,0:21:45.74,0:21:51.10,Default,,0,0,0,,因此 应该在索引3插入D 而不是在索引2插入D\Nreally the insertion here of D should have happened at index 3, not at index 2.
Dialogue: 0,0:21:51.10,0:21:55.38,Default,,0,0,0,,我们需要以某种方式解决同时发生的并发编辑问题\NSo, we have to somehow deal with the fact that this concurrent editing has happened,
Dialogue: 0,0:21:55.38,0:21:58.22,Default,,0,0,0,,对索引位置进行适当的调整\Nand adjust the indexes accordingly.
Dialogue: 0,0:21:58.22,0:22:01.42,Default,,0,0,0,,这就是操作转换所完成的工作\NAnd this is exactly what operational transformation does.
Dialogue: 0,0:22:01.42,0:22:04.82,Default,,0,0,0,,操作转换是一类算法的总称\NSo, operational transformation is a family of algorithms
Dialogue: 0,0:22:04.82,0:22:07.80,Default,,0,0,0,,此类算法专门用于解决\Nthat deal with exactly this problem of
Dialogue: 0,0:22:07.80,0:22:10.36,Default,,0,0,0,,多人并发更新同一个文本文档的问题\Nseveral people concurrently updating a text document.
Dialogue: 0,0:22:10.36,0:22:13.78,Default,,0,0,0,,顾名思义 操作转换算法解决问题的方法是对操作进行转换\NAnd they deal with it by transforming the operations, as the name says.
Dialogue: 0,0:22:13.78,0:22:18.26,Default,,0,0,0,,我们仍然按照之前的方式记录文档的操作\NSo, we have the operations which are recorded as before,
Dialogue: 0,0:22:18.26,0:22:21.28,Default,,0,0,0,,每个操作是增加或删除一个字符\Njust like one character at a time insert or delete.
Dialogue: 0,0:22:21.28,0:22:25.92,Default,,0,0,0,,这里我们的操作是“在索引0插入A”和“在索引2插入D”\NAnd so, we have the insert of A at index 0, and the insert of D at index 2.
Dialogue: 0,0:22:25.92,0:22:33.10,Default,,0,0,0,,现在 假设用户B将操作“在索引2插入D”\NAnd now, when the operation, let's say, this insert D at index 2,
Dialogue: 0,0:22:33.10,0:22:36.58,Default,,0,0,0,,通过网络发送给用户A\Nwhen this gets sent over the network to user A,
Dialogue: 0,0:22:36.58,0:22:38.50,Default,,0,0,0,,用户A首先要检查\Nuser A is first going to check
Dialogue: 0,0:22:38.50,0:22:42.08,Default,,0,0,0,,哪些操作和这一操作是并发的\Nany operations that were concurrent with this particular operation.
Dialogue: 0,0:22:42.08,0:22:47.10,Default,,0,0,0,,这里 用户A知道自己的操作“在索引0插入A”是并发出现的\NAnd here, it knows that its own insertion of A at index 0 was concurrent.
Dialogue: 0,0:22:47.10,0:22:50.40,Default,,0,0,0,,因此 用户A要调用这里的转换函数T\NAnd so, it now calls this transformation function T.
Dialogue: 0,0:22:50.40,0:22:52.18,Default,,0,0,0,,这里的T是转换函数\NThis T here is the transformation function.
Dialogue: 0,0:22:52.18,0:22:54.00,Default,,0,0,0,,T的输入是两个操作\NIt takes two operations.
Dialogue: 0,0:22:54.54,0:22:59.00,Default,,0,0,0,,第一个操作是刚刚从网络中收到的操作\NThe first operation is the operation just received from the network.
Dialogue: 0,0:22:59.00,0:23:01.40,Default,,0,0,0,,第二个操作是与收到操作并发出现的操作\NAnd the other operation is its own operation
Dialogue: 0,0:23:01.40,0:23:04.52,Default,,0,0,0,,这里是用户A自己的操作\Nthat is concurrent with the received operation.
Dialogue: 0,0:23:04.52,0:23:09.30,Default,,0,0,0,,基于这两个操作 T返回收到操作的一个新版本\NAnd based on these two, it returns a new version of the received operation
Dialogue: 0,0:23:09.30,0:23:13.68,Default,,0,0,0,,新版本是根据并发操作转换后的操作\Nthat is transformed relative to this concurrent operation.
Dialogue: 0,0:23:13.68,0:23:17.70,Default,,0,0,0,,在这个例子中 这里的转换函数T\NAnd so, in this case, here the transformation function T
Dialogue: 0,0:23:17.70,0:23:21.24,Default,,0,0,0,,将“在索引2插入D”作为第一个参数\Nis going to take us first argument the insertion of D at index 2,
Dialogue: 0,0:23:21.24,0:23:25.70,Default,,0,0,0,,T将返回相同操作的一个转换版本\Nand it's going to return a transformed version of this same operation,
Dialogue: 0,0:23:26.42,0:23:30.64,Default,,0,0,0,,T意识到 我们并发出现了在索引0插入字符的操作\Nwhich is realizing that, OK, we've had this concurrent insertion at 0,
Dialogue: 0,0:23:30.64,0:23:35.32,Default,,0,0,0,,这意味着我们要把插入D的索引加1\Nthis means we have to increase the index of the insertion of D by 1.
Dialogue: 0,0:23:35.32,0:23:39.08,Default,,0,0,0,,因此 转换函数T在这里的返回结果是\NAnd so, therefore, the result of this transformation function T here is that
Dialogue: 0,0:23:39.08,0:23:43.46,Default,,0,0,0,,我们现在要在索引3插入D 而不是在索引2插入D\Nwe now perform the insertion of D at index 3 rather than at index 2.
Dialogue: 0,0:23:43.46,0:23:48.10,Default,,0,0,0,,如果我们在索引3插入 我们得到的文档就是ABCD\NAnd if we perform the insertion at index 3, now we have the document ABCD,
Dialogue: 0,0:23:48.10,0:23:50.82,Default,,0,0,0,,这也是我们期望得到的结果\Nwhich is exactly what we wanted.
Dialogue: 0,0:23:50.82,0:23:58.38,Default,,0,0,0,,再看相反的方向 “在索引0插入A”的操作\NGoing in the opposite direction here, the insertion of A at index 0 also gets transformed
Dialogue: 0,0:23:58.38,0:24:03.76,Default,,0,0,0,,也需要根据用户B侧的并发操作来进行转换\Nwith regard to the operation that is concurrent on user B's side.
Dialogue: 0,0:24:03.76,0:24:06.26,Default,,0,0,0,,这里的转换需要反过来做\NSo, the transformation goes just the other way around,
Dialogue: 0,0:24:06.26,0:24:10.46,Default,,0,0,0,,因为用户B也检测到这两个操作存在并发关系\Nbecause they detect the same concurrency relationship between these two operations,
Dialogue: 0,0:24:10.46,0:24:12.90,Default,,0,0,0,,可以使用向量时钟等方法来检测到操作存在并发关系\Nprobably using vector clocks or something like that.
Dialogue: 0,0:24:12.90,0:24:19.92,Default,,0,0,0,,在这种情况下 合并运算符不会转换索引0的操作\NAnd in this case, here, this operation of index 0 does not get transformed,
Dialogue: 0,0:24:19.92,0:24:21.14,Default,,0,0,0,,因为在这种情况下\Nbecause in this case,
Dialogue: 0,0:24:21.14,0:24:25.48,Default,,0,0,0,,左侧的文档操作发生在右侧的文档操作之后\Nthe concurrent operation is further along in the document, it's further to the right.
Dialogue: 0,0:24:25.48,0:24:26.46,Default,,0,0,0,,因此\NAnd so, therefore,
Dialogue: 0,0:24:26.46,0:24:30.46,Default,,0,0,0,,文档中较早发生的操作不会影响到较晚操作的索引\Nit doesn't affect the index of this operation that happens earlier in the document.
Dialogue: 0,0:24:30.46,0:24:32.54,Default,,0,0,0,,因此 这里转换函数仍然返回“在索引0插入A”\NAnd therefore, this transformation function here
Dialogue: 0,0:24:32.54,0:24:36.48,Default,,0,0,0,,没有对操作进行修改\Nreturns the unmodified insertion of A at index 0.
Dialogue: 0,0:24:36.48,0:24:38.96,Default,,0,0,0,,应用“在索引0插入A”的操作后\NAnd here, insertion A at index 0 is applied,
Dialogue: 0,0:24:38.96,0:24:42.84,Default,,0,0,0,,我们最终得到的文档也是我们期望的ABCD\Nand we end up with the document ABCD as we expected.
Dialogue: 0,0:24:42.84,0:24:47.00,Default,,0,0,0,,我不打算为大家讲解完整的操作转换算法\NSo, I'm not going to run you through the full operational transformation algorithm,
Dialogue: 0,0:24:47.00,0:24:52.72,Default,,0,0,0,,此算法涉及相当精细、极易弄混的细节\Nbecause the details are actually quite fiddly, and it gets quite messy,
Dialogue: 0,0:24:52.72,0:24:54.66,Default,,0,0,0,,我们没有时间详细讲解这些细节点\Nand we don't really have time to talk about that.
Dialogue: 0,0:24:54.66,0:24:59.04,Default,,0,0,0,,但这就是算法的基本工作原理\NBut this is the basic idea of how the algorithm works.
Dialogue: 0,0:24:59.04,0:25:03.92,Default,,0,0,0,,操作转换算法的一个缺点是\NNow, one downside of operational transformation algorithms is that
Dialogue: 0,0:25:03.92,0:25:08.90,Default,,0,0,0,,操作转换算法一般都要求\Ngenerally, they require total order broadcast as the mechanism
Dialogue: 0,0:25:08.90,0:25:11.24,Default,,0,0,0,,用户通过全序关系广播机制通信\Nfor communication between the users.
Dialogue: 0,0:25:11.24,0:25:16.12,Default,,0,0,0,,即使某个用户可以立即在自己的本地拷贝上应用更新操作\NSo, even though a user can immediately apply updates to their own local copy,
Dialogue: 0,0:25:16.12,0:25:22.20,Default,,0,0,0,,网络广播按照相同的顺序为所有用户传递更新操作\Nit relies on the network broadcast delivering the updates or the operations
Dialogue: 0,0:25:22.20,0:25:24.32,Default,,0,0,0,,仍然是操作转换算法的基础要求\Nto all of the users in the same order.
Dialogue: 0,0:25:24.32,0:25:29.48,Default,,0,0,0,,这意味着我们必须引入全序关系广播所需的全部开销\NAnd so, this means we do have all of the costs of total order broadcast associated with
Dialogue: 0,0:25:29.48,0:25:31.56,Default,,0,0,0,,才能让操作转换算法正常工作\Nmaking operational transformation work.
Dialogue: 0,0:25:32.56,0:25:35.56,Default,,0,0,0,,还有一个替代方法：使用CRDT\NThere's an alternative, which is to use a CRDT.
Dialogue: 0,0:25:35.56,0:25:39.96,Default,,0,0,0,,CRDT的一个性质就是不依赖全序关系广播\NAnd so, CRDTs have the property that they don't require total order broadcast.
Dialogue: 0,0:25:40.32,0:25:43.78,Default,,0,0,0,,这个场景下应用的CRDT需要因果关系广播\NIn this case, this particular CRDT will require causal broadcast.
Dialogue: 0,0:25:43.78,0:25:46.14,Default,,0,0,0,,我马上就会给大家讲解具体的算法\NI'll show you the algorithm in a moment.
Dialogue: 0,0:25:46.14,0:25:48.52,Default,,0,0,0,,先来讲讲算法的工作原理\NFirst, the concept of how it works.
Dialogue: 0,0:25:48.52,0:25:53.22,Default,,0,0,0,,操作转换要解决的真正问题是\NSo, the real problem that operational transformation had to solve is the fact that
Dialogue: 0,0:25:53.22,0:25:57.76,Default,,0,0,0,,如果存在并发插入或删除操作 则索引的含义可能就会发生变化\Nthe indexes don't have the same meaning if there are concurrent insertions or deletions.
Dialogue: 0,0:25:57.76,0:26:02.06,Default,,0,0,0,,在我们的例子中 索引2突然就必须得移动到索引3\NIn our case, like the index 2 suddenly has to move along to index 3.
Dialogue: 0,0:26:02.06,0:26:06.10,Default,,0,0,0,,因此 为了实现操作转换 我们必须追踪所有的操作\NAnd so, we have to keep track of everything in order to perform that transformation.
Dialogue: 0,0:26:06.10,0:26:10.24,Default,,0,0,0,,替代方案是 我们可以直接从一开始就不使用索引\NAs an alternative, we could simply not use indexes in the first place.
Dialogue: 0,0:26:10.24,0:26:13.36,Default,,0,0,0,,我们不使用索引来表示\NAnd instead of using indexes to refer to the places
Dialogue: 0,0:26:13.36,0:26:15.88,Default,,0,0,0,,字符插入或删除的位置\Nwhere we're inserting or deleting characters,
Dialogue: 0,0:26:15.88,0:26:17.84,Default,,0,0,0,,我们可以使用其他的构造\Nwe could use some other construction.
Dialogue: 0,0:26:17.84,0:26:23.16,Default,,0,0,0,,我们要给文档中的每个字符设置一个唯一标识符\NSo, let's say we're just going to give each character in the document a unique identifier.
Dialogue: 0,0:26:23.16,0:26:28.18,Default,,0,0,0,,在我们的例子中 唯一标识符是一个实数\NAnd in my case, this unique identifier is going to consist of a rational number,
Dialogue: 0,0:26:28.18,0:26:30.76,Default,,0,0,0,,唯一标识符是某个小数\Nso, some kind of fractional number.
Dialogue: 0,0:26:30.76,0:26:38.34,Default,,0,0,0,,此算法还要考虑插入特定字符节点的节点id\NAnd it's also going to consider the node id of the node that inserted a particular character.
Dialogue: 0,0:26:38.34,0:26:41.28,Default,,0,0,0,,我们可以把整个文档\NAnd we can think of the entire document
Dialogue: 0,0:26:41.28,0:26:44.92,Default,,0,0,0,,看成是由0到1之间的行号组成的\Nas consisting of the number line between 0 and 1.
Dialogue: 0,0:26:44.92,0:26:46.94,Default,,0,0,0,,0表示文档的起始位置\NSo, 0 is the start of the document.
Dialogue: 0,0:26:46.94,0:26:51.74,Default,,0,0,0,,在我们的例子中 文档的起始位置用这样一个小转折符号（├）表示\NAnd here the start of the document is indicated with this little turn-style symbol here.
Dialogue: 0,0:26:51.74,0:26:56.80,Default,,0,0,0,,1表示文档的结束位置 用这样一个小转折符号（┤）表示\NAnd 1 is the end of the document, which is indicated by this little symbol here.
Dialogue: 0,0:26:56.80,0:27:00.36,Default,,0,0,0,,开始和结束这两个符号实际上不属于文档的一部分\NSo, these two start and end symbols are not actually part of the document.
Dialogue: 0,0:27:00.36,0:27:03.20,Default,,0,0,0,,它们只是用于标记起始和结束位置的占位符\NThey're just the placeholders to mark the beginning and the end.
Dialogue: 0,0:27:03.20,0:27:06.28,Default,,0,0,0,,我们要取这两个符号之间的所有字符\NAnd in between, we're just going to take all of the characters,
Dialogue: 0,0:27:06.28,0:27:10.08,Default,,0,0,0,,根据字符关联的小数对字符按照升序排列\Nand sort them in increasing order by the number that's associated with them.
Dialogue: 0,0:27:10.08,0:27:12.04,Default,,0,0,0,,我们将这些小数称为位置数\NWe're going to call this a position number.
Dialogue: 0,0:27:12.04,0:27:15.44,Default,,0,0,0,,随后 当我们按照顺序放置位置数对应的字符时\NAnd then, when we put the numbers in that order,
Dialogue: 0,0:27:15.44,0:27:18.72,Default,,0,0,0,,文档中的字符位置就是我们期望的字符摆放顺序\Nwe will just get the document in the order that we expect.
Dialogue: 0,0:27:18.72,0:27:23.64,Default,,0,0,0,,这里 假设B的位置数为0.5\NOK, and so, here, let's say that B has got a value of 0.5.
Dialogue: 0,0:27:23.64,0:27:25.00,Default,,0,0,0,,得到这个位置数的方法是\NThe way we got that is,
Dialogue: 0,0:27:25.00,0:27:29.38,Default,,0,0,0,,我们想在文档中插入第一个字符B\Nwell, we wanted to insert B as the first character in the document,
Dialogue: 0,0:27:29.38,0:27:34.24,Default,,0,0,0,,我们取0和1的平均数 让B的位置数等于0.5\Nso, we just picked halfway between 0 and 1 and said, OK, B is going to have 0.5.
Dialogue: 0,0:27:34.24,0:27:37.74,Default,,0,0,0,,随后 我们想在0.5和1.0之间插入C\NThen, we wanted to insert C between 0.5 and 1.0.
Dialogue: 0,0:27:37.74,0:27:41.54,Default,,0,0,0,,我们取两个端点的平均数 得到的就是0.75\NSo, we gave it a position number of halfway between, 0.75.
Dialogue: 0,0:27:41.54,0:27:46.96,Default,,0,0,0,,现在 假设用户A想要在B的前面插入字符A\NAnd so, let's say now that user A wants to insert the character A before the B.
Dialogue: 0,0:27:46.96,0:27:53.24,Default,,0,0,0,,用户A要计算0和0.5的平均数 得到的就是0.25\NSo, it's now going to pick a number halfway between 0 and 0.5. So, it's going to be 0.25.
Dialogue: 0,0:27:53.24,0:27:56.80,Default,,0,0,0,,右侧的用户B也在并发操作\NAnd concurrently, the user B on the right-hand side,
Dialogue: 0,0:27:56.80,0:28:02.26,Default,,0,0,0,,用户B想在0.75和1.0之间插入字母D\Nit wants to insert the letter D here between 0.75 and 1.0.
Dialogue: 0,0:28:02.26,0:28:06.60,Default,,0,0,0,,用户B计算两个端点的平均数 得到0.875\NSo, it's going to pick halfway between, which is 0.875.
Dialogue: 0,0:28:06.60,0:28:12.32,Default,,0,0,0,,你可以对区间不断细分 使位置数越来越小\NNow, you can keep subdividing these intervals to be smaller and smaller.
Dialogue: 0,0:28:12.32,0:28:15.86,Default,,0,0,0,,如果你用普通的浮点数来表示位置数 则浮点数的精度终将会被耗尽\NIf you use regular floating-point numbers, then you will eventually run out of precision,
Dialogue: 0,0:28:15.86,0:28:17.94,Default,,0,0,0,,最终的结果就是所有字符的位置数都相等\Nand you will just end up with all of the numbers being equal,
Dialogue: 0,0:28:17.94,0:28:19.06,Default,,0,0,0,,因此不能用浮点数\Nso, that won't work.
Dialogue: 0,0:28:19.06,0:28:22.98,Default,,0,0,0,,你必须使用支持任意精度的数字表示方法来表示位置数\NSo, you do have to use arbitrary-precision arithmetic in order to make this work.
Dialogue: 0,0:28:22.98,0:28:26.16,Default,,0,0,0,,假设你有一个合适的数字库\NBut assuming that you have a suitable number library
Dialogue: 0,0:28:26.16,0:28:28.44,Default,,0,0,0,,此数字库可以表示任意精度的数字\Nthat performs arbitrary-precision arithmetic,
Dialogue: 0,0:28:28.44,0:28:30.50,Default,,0,0,0,,这样你就可以不断细分区间了\Nthen you can take these operations,
Dialogue: 0,0:28:30.50,0:28:33.86,Default,,0,0,0,,同时 你可以通过网络直接发送任意精度的位置数\Nand you can just send them over the network in a straightforward manner.
Dialogue: 0,0:28:33.86,0:28:41.44,Default,,0,0,0,,你可以直接在右侧应用“在0.875位置上插入D”的操作\NSo, this insertion here of D at position 0.875, you can apply here on the right-hand side,
Dialogue: 0,0:28:41.44,0:28:46.44,Default,,0,0,0,,0.875将出现在正确的位置上 可以在这个期望的位置上插入正确的字符\Nand 0.875 will slot in just in the right place just where you expect it to happen.
Dialogue: 0,0:28:46.44,0:28:48.00,Default,,0,0,0,,反过来也是类似的\NAnd likewise, in the opposite direction,
Dialogue: 0,0:28:48.00,0:28:52.70,Default,,0,0,0,,“在0.25位置上插入A”后 A也会被插入到正确的位置\Nthe insertion of A at 0.25, it will just slot into the right place.
Dialogue: 0,0:28:52.70,0:28:57.34,Default,,0,0,0,,这实际上是实现相同性质的一种非常简单的方法\NSo, this is actually a very simple way of achieving the same property,
Dialogue: 0,0:28:57.34,0:29:01.56,Default,,0,0,0,,且不涉及操作转换中的所有复杂处理过程\Nbut without all of this complexity of operational transformation.
Dialogue: 0,0:29:01.56,0:29:03.58,Default,,0,0,0,,下面是具体的算法描述\NAnd here's the algorithm that does this.
Dialogue: 0,0:29:03.58,0:29:08.72,Default,,0,0,0,,这个算法要占两页幻灯片 这是算法描述的第一页幻灯片\NSo, this comes on two pages. This is the first page of this algorithm.
Dialogue: 0,0:29:09.58,0:29:12.66,Default,,0,0,0,,首先 我想定义一个函数（ELEMENTAT）\NFirst of all, I want to define a function
Dialogue: 0,0:29:12.66,0:29:14.58,Default,,0,0,0,,其功能是：给定一个列表（chars）和一个索引（index）\Nthat given an index into the list,
Dialogue: 0,0:29:14.58,0:29:19.60,Default,,0,0,0,,根据位置数的顺序找到一个适当的元素\Nit will find the appropriate element based on the ordering of these position ids.
Dialogue: 0,0:29:19.60,0:29:21.68,Default,,0,0,0,,这就是此函数的功能\NAnd that's done with this function here.
Dialogue: 0,0:29:21.68,0:29:23.72,Default,,0,0,0,,此函数的具体处理过程如下\NSo, the way this works is that,
Dialogue: 0,0:29:23.72,0:29:28.74,Default,,0,0,0,,首先 我们想在字符集合（chars）中找到最小的元素（min）\Nfirst of all, we want to find the minimum element in the set of characters.
Dialogue: 0,0:29:28.74,0:29:30.78,Default,,0,0,0,,我们要找到最小的元素\NAnd so, we're going to find the minimum element
Dialogue: 0,0:29:30.78,0:29:36.24,Default,,0,0,0,,此元组的位置标识符为p、节点id为n、值为v\Nthat has some position identifier p, node id n, and value v.
Dialogue: 0,0:29:36.24,0:29:37.90,Default,,0,0,0,,我们要找到最小的元素\NAnd we're going to find the smallest one,
Dialogue: 0,0:29:37.90,0:29:40.50,Default,,0,0,0,,最小元素指的是\Nwhich is the element such that
Dialogue: 0,0:29:40.50,0:29:45.48,Default,,0,0,0,,字符集合中无法找到另一个\Nthere does not exist another element in this set of characters
Dialogue: 0,0:29:45.48,0:29:48.96,Default,,0,0,0,,位置标识符p’小于p的元素\Nwith a position identifier p’ that is less than p.
Dialogue: 0,0:29:48.96,0:29:51.70,Default,,0,0,0,,另外 我们也不希望字符集合中\NAlternatively, we also don't want
Dialogue: 0,0:29:51.70,0:29:56.90,Default,,0,0,0,,存在一个位置标识符与p相等 且对应节点id更小的元素\Nthere to be a position identifier with the same position number and a lower node id.
Dialogue: 0,0:29:56.90,0:29:59.14,Default,,0,0,0,,这么做的目的是\NSo, the purpose for this is that
Dialogue: 0,0:29:59.14,0:30:03.22,Default,,0,0,0,,字符集合中可能存在两个位置标识符相等的字符\Nyou could actually end up with two characters having the same position identifier.
Dialogue: 0,0:30:03.22,0:30:07.28,Default,,0,0,0,,如果两个不同的用户在相同的位置上并发插入一个字符\NIf two different users can currently insert a character at the same position,
Dialogue: 0,0:30:07.28,0:30:09.66,Default,,0,0,0,,它们就会计算出相同的位置数\Nand so, they will calculate the same position number,
Dialogue: 0,0:30:10.08,0:30:14.34,Default,,0,0,0,,因为位置数的计算方法就是计算两个端点的平均值\Nbecause you're just doing halfway between the two endpoints.
Dialogue: 0,0:30:14.34,0:30:18.84,Default,,0,0,0,,这种情况下 我们必须进一步比较出顺序关系\NAnd so, in this case, now we have to do a tiebreaker.
Dialogue: 0,0:30:18.84,0:30:23.68,Default,,0,0,0,,具体方法就是再比较插入特定字符的节点id的大小关系\NAnd the tiebreaker is going to be based on the node that inserted a particular character.
Dialogue: 0,0:30:23.68,0:30:26.60,Default,,0,0,0,,这样一来 我们就得到了所有字符的全序关系\NSo here, this gives us a total ordering of all of the characters
Dialogue: 0,0:30:26.60,0:30:29.00,Default,,0,0,0,,我们首先根据位置数排序\Nwhere we first sort by the position number,
Dialogue: 0,0:30:29.00,0:30:32.00,Default,,0,0,0,,对于任意拥有相同位置数的字符\Nand for any characters that have the same position number,
Dialogue: 0,0:30:32.00,0:30:34.40,Default,,0,0,0,,我们接下来比较节点id\Nwe secondarily sort by the node id.
Dialogue: 0,0:30:34.40,0:30:38.90,Default,,0,0,0,,这里的表达式就是查找所有字符的最小元素\NAnd this expression here finds the minimum of all of these characters.
Dialogue: 0,0:30:38.90,0:30:43.00,Default,,0,0,0,,如果我们查找的索引为0 则我们直接返回最小元素\NAnd if the index that we're looking for is 0, then we're just going to return that minimum.
Dialogue: 0,0:30:43.00,0:30:45.80,Default,,0,0,0,,否则 如果我们查找的索引值为1或者更大\NOtherwise, if we're looking for an index of 1 or greater,
Dialogue: 0,0:30:45.80,0:30:47.96,Default,,0,0,0,,我们将递归调用此函数\Nwe're going to call this function recursively.
Dialogue: 0,0:30:47.96,0:30:50.52,Default,,0,0,0,,我们将在集合中移除最小元素\NWe're going to remove the minimum element from the set.
Dialogue: 0,0:30:50.52,0:30:53.14,Default,,0,0,0,,此时 下一个最小元素就是比当前最小元素大一个位置的元素\NSo, now the next minimum is going to be the next one up.
Dialogue: 0,0:30:53.14,0:30:55.26,Default,,0,0,0,,我们同时减小查找的索引值\NAnd we're going to decrement the index.
Dialogue: 0,0:30:55.26,0:31:00.84,Default,,0,0,0,,随着函数的递归调用 索引值最终会等于0\NAnd so, then, recursively as you keep calling this, eventually index will be 0.
Dialogue: 0,0:31:00.84,0:31:05.56,Default,,0,0,0,,此函数最终会让索引值降低到0 并返回对应的最小元素\NAnd eventually, it will reach this first case here of returning minimum.
Dialogue: 0,0:31:05.56,0:31:09.84,Default,,0,0,0,,这是一个效率很低的算法 我这里只是想演示一下算法的功能\NNow, this is a very slow algorithm, but I just want to illustrate the functionality.
Dialogue: 0,0:31:09.84,0:31:14.06,Default,,0,0,0,,实际中 你可以用更高效的方法实现这一函数 但这不是重点\NIn reality, you could implement this in a more efficient way, but that's not the point here.
Dialogue: 0,0:31:14.06,0:31:16.68,Default,,0,0,0,,我们来看看初始化阶段\NSo, let's look at the initialization.
Dialogue: 0,0:31:16.68,0:31:21.26,Default,,0,0,0,,此时 我们用两个端点来初始化我们的字符列表\NSo, this time, we set up our list of characters to start off with the two endpoints,
Dialogue: 0,0:31:21.26,0:31:26.44,Default,,0,0,0,,让字符列表包含起始字符和结束字符\Nso, our kind of special marker characters for the beginning and the end
Dialogue: 0,0:31:26.44,0:31:30.76,Default,,0,0,0,,起始字符和结束字符对应的位置数分别为0和1\Nwith a position of 0 and the position of 1 respectively.
Dialogue: 0,0:31:30.76,0:31:35.10,Default,,0,0,0,,当我们想读取文档中特定索引index的字符时\NWhen we want to read the character at a particular index in the document,
Dialogue: 0,0:31:35.10,0:31:37.86,Default,,0,0,0,,我们要使用我们刚刚定义的ELEMENTAT函数\Nwe're going to use this ELEMENTAT function that we just defined.
Dialogue: 0,0:31:37.86,0:31:39.94,Default,,0,0,0,,我们用index+1调用此函数\NAnd we're going to use index+1.
Dialogue: 0,0:31:39.94,0:31:46.36,Default,,0,0,0,,这里+1的意思是跳过初始的占位符\NThe +1 just skips the initial character with the placeholder character.
Dialogue: 0,0:31:46.36,0:31:49.12,Default,,0,0,0,,这将保证\NAnd so, that make sure that
Dialogue: 0,0:31:49.12,0:31:52.80,Default,,0,0,0,,函数确实可以返回文档中特定位置的字符\Nwe actually return a particular index as seen by the document
Dialogue: 0,0:31:52.80,0:31:55.22,Default,,0,0,0,,且返回的字符不包括初始占位符\Nnot counting that initial placeholder character.
Dialogue: 0,0:31:55.22,0:31:57.18,Default,,0,0,0,,随后 我们返回得到的值\NAnd then, we return that value.
Dialogue: 0,0:31:57.18,0:32:01.74,Default,,0,0,0,,现在 如果我们想在某个索引index插入一个字符\NNow, if we want to insert a character at some index index,
Dialogue: 0,0:32:01.74,0:32:05.66,Default,,0,0,0,,某个特定节点id（nodeId）想插入一个字符\Nand this is executed by put some particular node id,
Dialogue: 0,0:32:05.66,0:32:08.00,Default,,0,0,0,,我们严格按照之前描述的方法处理\Nwe do exactly what I explained earlier.
Dialogue: 0,0:32:08.00,0:32:13.32,Default,,0,0,0,,我们找到特定索引index和index+1位置上的元素\NSo, we find the element at that particular index and the adjacent element at index+1.
Dialogue: 0,0:32:13.32,0:32:16.86,Default,,0,0,0,,这将告诉我们\NSo, this now gives us the position number
Dialogue: 0,0:32:16.86,0:32:19.92,Default,,0,0,0,,插入索引之前和之后元素的位置数\Njust before and just after the position where we want to insert.
Dialogue: 0,0:32:19.92,0:32:24.60,Default,,0,0,0,,接下来 我们计算两个端点的平均数 即计算(p_1+p_2)/2\NSo, then, we can calculate the halfway point as (p_1+p_2)/2.
Dialogue: 0,0:32:24.60,0:32:28.06,Default,,0,0,0,,这就是新字符的位置数\NAnd that's going to be the position number of the new character.
Dialogue: 0,0:32:28.06,0:32:30.24,Default,,0,0,0,,我们在消息中放置新字符的位置数和节点id\NWe're going to include the node id, as I said,
Dialogue: 0,0:32:30.24,0:32:35.30,Default,,0,0,0,,我前面讲过 节点id用于处理相同位置数的元素排序问题\Nin order to tie break any insertions that happen to have the same position number,
Dialogue: 0,0:32:35.30,0:32:38.08,Default,,0,0,0,,还要放置插入的字符v\Nand v is the character that's being inserted.
Dialogue: 0,0:32:38.08,0:32:41.84,Default,,0,0,0,,现在 我们通过因果关系广播来广播这条消息\NSo now, we're going to broadcast this message here by causal broadcast.
Dialogue: 0,0:32:41.84,0:32:43.28,Default,,0,0,0,,我稍后会解释\NI will explain in a moment
Dialogue: 0,0:32:43.28,0:32:47.24,Default,,0,0,0,,为什么这时需要使用因果关系广播 不能仅使用可靠广播\Nwhy it's causal broadcast this time and not just reliable broadcast.
Dialogue: 0,0:32:48.46,0:32:52.84,Default,,0,0,0,,现在 当因果关系广播传递了其中一条插入消息时\NSo now, when one of these insertion messages is delivered by causal broadcast,
Dialogue: 0,0:32:52.84,0:32:53.72,Default,,0,0,0,,处理过程很简单\Nwell, it's easy,
Dialogue: 0,0:32:53.72,0:32:56.34,Default,,0,0,0,,我们只需要\Nwe just add that particular element
Dialogue: 0,0:32:56.34,0:32:59.62,Default,,0,0,0,,添加这一包含特定位置数、特定节点id、特定字符的元素\Nwith the particular position number, particular node id, and particular character.
Dialogue: 0,0:32:59.62,0:33:01.94,Default,,0,0,0,,我们将收到的元素添加进字符集合中\NWe add that to the set of characters.
Dialogue: 0,0:33:01.94,0:33:04.20,Default,,0,0,0,,这就是插入字符时我们所需的所有处理过程\NAnd that's all we need to do for insertion.
Dialogue: 0,0:33:04.20,0:33:07.44,Default,,0,0,0,,如果我们想删除一个字符 处理过程也很简单\NIf we want to delete a character, that's also quite easy.
Dialogue: 0,0:33:07.44,0:33:10.24,Default,,0,0,0,,我们再次找到特定索引index的元素\NWe find the element at that particular index again.
Dialogue: 0,0:33:10.24,0:33:14.74,Default,,0,0,0,,我们同样要把起始占位符考虑进来 因此要查找索引index+1的元素\NAgain, we do +1 in order to account for the placeholder character at the beginning.
Dialogue: 0,0:33:15.22,0:33:21.22,Default,,0,0,0,,我们得到了这一特定索引index对应的位置id、节点id、以及当前字符\NWe get back the position id, the node id, and the character at that particular index.
Dialogue: 0,0:33:21.22,0:33:24.42,Default,,0,0,0,,现在 我们要通过因果关系广播来广播一条消息\NAnd now, we're going to broadcast by causal broadcast a message
Dialogue: 0,0:33:24.42,0:33:27.10,Default,,0,0,0,,消息包含位置标识符和节点id\Ncontaining the position identifier and the node id,
Dialogue: 0,0:33:27.10,0:33:30.34,Default,,0,0,0,,因为位置表示符和节点id\Nbecause taken together the position number and the node id
Dialogue: 0,0:33:30.34,0:33:33.80,Default,,0,0,0,,已经可以唯一标识文档中一个特定的字符了\Nare going to uniquely identify a particular character in the document.
Dialogue: 0,0:33:33.80,0:33:35.96,Default,,0,0,0,,在不传递索引index的条件下\NAnd so, that's uniquely going to tell everybody
Dialogue: 0,0:33:35.96,0:33:40.18,Default,,0,0,0,,我们可以通过这一消息告诉所有节点要删除的字符是什么\Nwhat is the character that we want to delete without referring to it by index.
Dialogue: 0,0:33:40.18,0:33:43.04,Default,,0,0,0,,这样一来 我们就不再需要操作转换了\NSo, we don't need the operational transformation.
Dialogue: 0,0:33:43.04,0:33:48.14,Default,,0,0,0,,现在 当我们通过因果关系广播传递了其中一条删除操作时\NAnd now, when we deliver one of these deletion operations here by causal broadcast,
Dialogue: 0,0:33:48.14,0:33:54.18,Default,,0,0,0,,我们只需要从字符集合中\Nwell, we are just going to remove from the set of characters any character
Dialogue: 0,0:33:54.18,0:34:00.08,Default,,0,0,0,,移除删除操作的消息中给出的特定位置数（p）、特定节点id（n）的元素\Nthat has exactly the position number p and the note id n in the deletion message.
Dialogue: 0,0:34:00.08,0:34:01.84,Default,,0,0,0,,删除过程就是更新集合\NAnd so, this is just going to update the set,
Dialogue: 0,0:34:01.84,0:34:05.32,Default,,0,0,0,,从集合中移除要删除的字符\Nand remove whatever that deleted character was from the set.
Dialogue: 0,0:34:05.32,0:34:06.58,Default,,0,0,0,,如果又收到相同的删除消息\NIf it's still there, of course,
Dialogue: 0,0:34:06.58,0:34:11.36,Default,,0,0,0,,有可能出现的情况是 多个用户在并发删除相同的字符\Nit could happen that several users concurrently deleted the same character,
Dialogue: 0,0:34:11.36,0:34:14.56,Default,,0,0,0,,即使出现这种情况 删除多次也等价于删除一次\Nin which case, deleting it several times is the same as deleting it once.
Dialogue: 0,0:34:14.56,0:34:17.26,Default,,0,0,0,,结果都是把这个字符删除了\NIt's just gone in that case.
Dialogue: 0,0:34:17.26,0:34:19.02,Default,,0,0,0,,这就够了\NAnd this is enough.
Dialogue: 0,0:34:19.02,0:34:25.30,Default,,0,0,0,,这是一个可以使文本文档满足强最终一致性的CRDT\NThis is a CRDT that ensures strong eventual consistency for a text document.
Dialogue: 0,0:34:25.74,0:34:30.52,Default,,0,0,0,,我们这里不使用可靠广播 而是使用因果关系广播\NThe reason I use causal broadcast here rather than reliable broadcast is
Dialogue: 0,0:34:30.52,0:34:32.12,Default,,0,0,0,,主要就是为了处理删除操作\Nbecause of the deletions.
Dialogue: 0,0:34:32.12,0:34:36.42,Default,,0,0,0,,我们这里必须保证的是 当我们删除一个字符时\NAnd so, here we have to be sure that when we're deleting a character,
Dialogue: 0,0:34:36.42,0:34:41.36,Default,,0,0,0,,此删除操作必须在插入字符的操作之后发生\Nthat deletion operation happens after the operation that inserted the character,
Dialogue: 0,0:34:41.36,0:34:45.28,Default,,0,0,0,,因为删除之前已经插入过的字符才是有意义的\Nbecause it only makes sense to delete a character that has been previously inserted.
Dialogue: 0,0:34:45.28,0:34:47.18,Default,,0,0,0,,因此 在这个特定的算法中\NAnd so, in this particular algorithm,
Dialogue: 0,0:34:47.18,0:34:50.84,Default,,0,0,0,,交换相同字符插入和删除的操作顺序是不安全的\Nit's not safe to reorder the insert and delete of the same character,
Dialogue: 0,0:34:50.84,0:34:53.66,Default,,0,0,0,,因为如果我们先删除后插入\Nbecause if we did the delete first and then the insert,
Dialogue: 0,0:34:54.24,0:34:56.70,Default,,0,0,0,,则删除操作不会删除任何记录\Nthere's no record of that delete having happened,
Dialogue: 0,0:34:56.70,0:34:59.92,Default,,0,0,0,,因此 删除操作最终将不会生效\Nand so, we would end up then with the delete not taking effect.
Dialogue: 0,0:34:59.92,0:35:01.34,Default,,0,0,0,,因此 交换操作顺序是不安全的\NAnd so, this would not be safe.
Dialogue: 0,0:35:01.34,0:35:03.96,Default,,0,0,0,,但在这种情况下 我们可以使用因果关系广播\NBut we can use causal broadcast in this case.
Dialogue: 0,0:35:03.96,0:35:06.06,Default,,0,0,0,,因为删除一个字符的操作\NAnd because the deletion of a character
Dialogue: 0,0:35:06.06,0:35:10.10,Default,,0,0,0,,一定在插入此字符的操作之后发生 两者存在因果关系\Nalways happens causally later than the insertion of that character,
Dialogue: 0,0:35:10.10,0:35:12.88,Default,,0,0,0,,插入操作一定在删除操作之前发生\Nthe insertion always must happen before the deletion,
Dialogue: 0,0:35:12.88,0:35:16.74,Default,,0,0,0,,因此 所有节点/副本\Nand so, therefore, all of the nodes, all of the replicas
Dialogue: 0,0:35:16.74,0:35:20.26,Default,,0,0,0,,都会在传递删除操作之前传递插入操作\Nwill deliver the insertion before they deliver that deletion.
Dialogue: 0,0:35:20.26,0:35:22.10,Default,,0,0,0,,这样就可以保证\NAnd therefore, the deletion then
Dialogue: 0,0:35:22.10,0:35:25.50,Default,,0,0,0,,删除操作总能生效 可以删除特定的字符\Nwill have the desired effect of actually deleting the character.
Dialogue: 0,0:35:25.50,0:35:30.72,Default,,0,0,0,,另一方面 对于不同字符的插入和删除操作\NAnd otherwise, for any insertions and deletions of different characters,
Dialogue: 0,0:35:30.72,0:35:32.40,Default,,0,0,0,,插入和删除满足交换律\Ninsertion and deletion just commute.
Dialogue: 0,0:35:32.40,0:35:36.44,Default,,0,0,0,,这很容易理解 插入操作就是集合求并运算符 满足交换律\NThat's easy. Insertion is just a set union operator, which commutes, and so on.
Dialogue: 0,0:35:36.44,0:35:41.56,Default,,0,0,0,,你可以确信不同字符的插入和删除操作满足交换律\NYou can convince yourself that these procedures here commute.
Dialogue: 0,0:35:41.56,0:35:46.26,Default,,0,0,0,,因此 这是一个CRDT 我们再次得到强最终一致性\NAnd as a result, it's a CRDT, and we get strong eventual consistency again.
Dialogue: 0,0:35:46.26,0:35:49.46,Default,,0,0,0,,如何让此算法变得高效是一个挑战问题\NSo, here, making this efficient can be the challenge,
Dialogue: 0,0:35:49.46,0:35:52.76,Default,,0,0,0,,因为在这个算法中\Nbecause in this case, now, we're carrying along
Dialogue: 0,0:35:52.76,0:35:57.50,Default,,0,0,0,,每个字符都关联了一个可能会非常大的任意位置数\Nthese potentially quite large arbitrary position numbers with every single character.
Dialogue: 0,0:35:57.50,0:36:01.22,Default,,0,0,0,,如何让算法变得高效\NSo, how you take this algorithm and actually make it really efficient
Dialogue: 0,0:36:01.22,0:36:03.98,Default,,0,0,0,,使得你可以在实际中基于此算法构建类似谷歌文档的应用\Nso that you can build something like Google Docs in practice,
Dialogue: 0,0:36:03.98,0:36:06.04,Default,,0,0,0,,是一个非常有趣的研究领域\Nthat's an interesting area of research.
Dialogue: 0,0:36:06.04,0:36:09.28,Default,,0,0,0,,实际上 这恰好是我的研究领域之一\NIn fact, it happens to be one of my areas of research,
Dialogue: 0,0:36:09.72,0:36:12.38,Default,,0,0,0,,但这已经超出了这门课的范围\Nbut this really goes beyond the scope of this particular course.
Dialogue: 0,0:36:12.38,0:36:16.90,Default,,0,0,0,,我只想让大家了解CRDT算法是如何工作的\NI just wanted to give you the flavor of how these CRDT algorithms work.
Dialogue: 0,0:36:16.90,0:36:19.72,Default,,0,0,0,,这就是我想介绍的\NSo, that's all I wanted to say about
Dialogue: 0,0:36:19.72,0:36:23.62,Default,,0,0,0,,有关协作软件、CRDT和操作转换的全部内容了\Ncollaboration software, CRDTs, and operational transformation.
