[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 8.2_Google's Spanner.mp4
Video File: 8.2_Google's Spanner.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 270
Active Line: 281
Video Position: 31400

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.24,0:00:04.70,Default,,0,0,0,,我们之前已经讨论过最终一致性系统\NSo, we've talked about these eventually consistent systems.
Dialogue: 0,0:00:04.70,0:00:08.70,Default,,0,0,0,,在本课程的最后一部分 我们切换回一致性要求非常强的系统\NFor the last section, let's switch back to very strongly consistent systems.
Dialogue: 0,0:00:08.70,0:00:09.92,Default,,0,0,0,,我想向大家介绍的是\NAnd what I'd like to tell you about
Dialogue: 0,0:00:09.92,0:00:14.56,Default,,0,0,0,,由谷歌开发的一个非常有趣的数据库系统 叫做Spanner\Nis a very interesting database system developed by Google, called Spanner.
Dialogue: 0,0:00:14.56,0:00:16.70,Default,,0,0,0,,这是一个规模非常大的数据库系统\NThis is a very large-scale database system.
Dialogue: 0,0:00:16.70,0:00:19.74,Default,,0,0,0,,是一个用来处理大规模数据的数据库系统\NIt's intended to be used with huge amounts of data,
Dialogue: 0,0:00:19.74,0:00:22.86,Default,,0,0,0,,上百万个节点分布在世界各地\Nwith millions of nodes spread all around the globe,
Dialogue: 0,0:00:22.86,0:00:27.94,Default,,0,0,0,,尽管系统规模巨大\Nand nevertheless, despite this huge scale,
Dialogue: 0,0:00:27.94,0:00:31.44,Default,,0,0,0,,此数据库仍然期望满足强一致性\Nwe want to achieve very strong consistency properties in this database.
Dialogue: 0,0:00:31.44,0:00:33.60,Default,,0,0,0,,特别地 此数据库期望满足经典的一致性模型\NIn particular, the classic that we've seen.
Dialogue: 0,0:00:33.60,0:00:37.70,Default,,0,0,0,,我们希望满足可串行事务隔离 这是我们能得到的最强隔离级别\NWe want serializable transaction isolation, the strongest isolation we can get.
Dialogue: 0,0:00:37.70,0:00:40.04,Default,,0,0,0,,我们希望读和写满足线性一致性\NWe want linearizability for reads and writes,
Dialogue: 0,0:00:40.04,0:00:44.46,Default,,0,0,0,,这意味着我们总能看到最新的写入值\Nthat means we're always going to see an up-to-date value from any value written.
Dialogue: 0,0:00:44.46,0:00:47.02,Default,,0,0,0,,进一步 我们希望系统支持分片\NMoreover, we need to support sharding,
Dialogue: 0,0:00:47.02,0:00:49.40,Default,,0,0,0,,这意味着如此大规模的数据\Nwhich means that this huge amount of data,
Dialogue: 0,0:00:49.40,0:00:52.00,Default,,0,0,0,,远远超过了单个节点的存储能力\Nwhich is far too much to store on a single node,
Dialogue: 0,0:00:52.00,0:00:58.34,Default,,0,0,0,,我们必须将数据切分成子集 每个节点存储数据子集的一个副本\Nwe have to split into subsets of data, each node has a replica of a subset of the data,
Dialogue: 0,0:00:59.18,0:01:03.64,Default,,0,0,0,,这样一来 你可以在所有不同的节点实现数据的分布式存储\Nso that now, you can distribute the data across all of these different nodes.
Dialogue: 0,0:01:03.64,0:01:04.70,Default,,0,0,0,,但这也意味着\NBut this now means that
Dialogue: 0,0:01:04.70,0:01:08.60,Default,,0,0,0,,有的事务可能需要在多个节点上读取和写入数据\Nyou might have a transaction that needs to read and write data on multiple nodes.
Dialogue: 0,0:01:08.60,0:01:13.10,Default,,0,0,0,,如果出现类似的分布式事务 我们需要原子提交\NAnd if this happens, distribute a transaction like this, we need atomic commit
Dialogue: 0,0:01:13.10,0:01:16.12,Default,,0,0,0,,使得此事务引发的任何数据修改\Nso that any changes made by a transaction
Dialogue: 0,0:01:16.12,0:01:20.04,Default,,0,0,0,,或者被其他所有节点提交 或者被其他所有节点中止\Nwill either be committed on all of the nodes or aborted on all of the nodes.
Dialogue: 0,0:01:20.04,0:01:22.14,Default,,0,0,0,,我们希望数据库满足上述所有经典性质\NSo, all of these classic properties we want.
Dialogue: 0,0:01:22.14,0:01:25.80,Default,,0,0,0,,Spanner使用了很多技术来满足这些性质\NAnd a lot of the techniques that Spanner uses to implement these properties
Dialogue: 0,0:01:25.80,0:01:28.64,Default,,0,0,0,,大部分技术与经典标准算法等价\Nare equally classic standard algorithms.
Dialogue: 0,0:01:28.64,0:01:35.04,Default,,0,0,0,,为了复制分片内的节点 Spanner使用了状态机复制\NSo, in order to replicate the nodes within a shard, it uses state machine replication.
Dialogue: 0,0:01:35.04,0:01:38.32,Default,,0,0,0,,Spanner使用的是Paxos共识算法 而不是Raft共识算法\NIt uses the Paxos consensus algorithm rather than Raft,
Dialogue: 0,0:01:38.32,0:01:42.16,Default,,0,0,0,,但这两个共识算法非常相似 原理也几乎完全一样\Nbut they are reasonably similar, and the principles are very much the same.
Dialogue: 0,0:01:42.16,0:01:45.26,Default,,0,0,0,,为了实现可串行事务隔离\NIn order to achieve serializable transaction isolation,
Dialogue: 0,0:01:45.26,0:01:47.24,Default,,0,0,0,,我们使用了经典的两阶段锁定\Nwe use the classic two-phase locking,
Dialogue: 0,0:01:47.24,0:01:53.06,Default,,0,0,0,,这意味着对于任何读操作 我们获得待读数据的共享锁\Nthat means for any reads, we take a shared lock on any data that we want to read,
Dialogue: 0,0:01:53.06,0:01:57.78,Default,,0,0,0,,对于任何写操作 我们需要获得待写数据的独占锁\Nand for any writes, we'd need to take an exclusive lock on any data that we write.
Dialogue: 0,0:01:57.78,0:02:01.94,Default,,0,0,0,,我们需要一直持有这些锁 直到事务提交完毕\NAnd we need to hold those locks until the transaction commits.
Dialogue: 0,0:02:03.00,0:02:09.06,Default,,0,0,0,,最后 为了实现跨多个分片的原子性 我们也使用了经典算法\NFinally, in order to achieve atomicity across multiple shards, we do the classic.
Dialogue: 0,0:02:09.06,0:02:12.68,Default,,0,0,0,,我们使用的就是前面课程中介绍的两阶段提交\NWe do two-phase commit exactly like we saw in the last lecture.
Dialogue: 0,0:02:12.68,0:02:16.64,Default,,0,0,0,,真正实现所有这些技术\NSo, so far, actually implementing all of these things well
Dialogue: 0,0:02:16.64,0:02:18.86,Default,,0,0,0,,也是一个重大的工程挑战\Nis still a significant engineering challenge,
Dialogue: 0,0:02:18.86,0:02:21.28,Default,,0,0,0,,但确实没有引入什么新的概念\Nbut there's nothing conceptually very new here.
Dialogue: 0,0:02:21.92,0:02:25.66,Default,,0,0,0,,Spanner有趣的地方在于\NWhere Spanner gets interesting is that
Dialogue: 0,0:02:25.66,0:02:29.66,Default,,0,0,0,,此系统支持不用锁的只读事务\Nit has support for read-only transactions that take no locks.
Dialogue: 0,0:02:29.66,0:02:34.18,Default,,0,0,0,,这是一个很特殊的功能 回忆一下两阶段锁定的含义\NNow, this is special, because if you remember what two-phase locking means,
Dialogue: 0,0:02:34.18,0:02:38.30,Default,,0,0,0,,两阶段锁定意味着 如果你想读取数据 你首先必须持有数据的共享锁\Nmeans if you want to read any data, you first have to take a shared lock on that data.
Dialogue: 0,0:02:38.30,0:02:43.00,Default,,0,0,0,,共享锁将阻止任意其他事务更新数据\NAnd a shared lock is going to prevent any other transactions from updating that data.
Dialogue: 0,0:02:43.00,0:02:47.22,Default,,0,0,0,,但在真实系统中 你经常会面对非常大的只读事务\NBut now, in real systems, you often get very large read-only transactions.
Dialogue: 0,0:02:47.22,0:02:52.14,Default,,0,0,0,,例如 数据库备份就是一个非常大的只读事务\NSo, for example, taking a database backup is a very large read-only transaction
Dialogue: 0,0:02:52.14,0:02:54.22,Default,,0,0,0,,此事务本质上需要读取整个数据\Nthat needs to read essentially the entire database.
Dialogue: 0,0:02:54.22,0:02:57.04,Default,,0,0,0,,备份本来就是要创建整个数据库的拷贝\NThat's what a backup is. It's a copy of the entire database.
Dialogue: 0,0:02:57.04,0:03:00.92,Default,,0,0,0,,因此 备份可能会花费非常长的时间\NAnd so, this backup might take a long time.
Dialogue: 0,0:03:00.92,0:03:05.18,Default,,0,0,0,,如果你在备份数据库的过程中\NAnd if you have to take a shared lock on the entire database for a long time
Dialogue: 0,0:03:05.18,0:03:06.84,Default,,0,0,0,,必须长时间持有整个数据库的共享锁\Nwhile you're doing a database backup,
Dialogue: 0,0:03:06.84,0:03:08.78,Default,,0,0,0,,用户可能就不太高兴了\Nthen users are not going to like that very much,
Dialogue: 0,0:03:08.78,0:03:09.52,Default,,0,0,0,,因为这意味着\Nbecause it means that
Dialogue: 0,0:03:09.52,0:03:13.40,Default,,0,0,0,,整个备份期间都不能向数据库写入任何数据\Nno writes can be made to the database for the entire duration of this backup.
Dialogue: 0,0:03:13.40,0:03:15.96,Default,,0,0,0,,这在实际中是行不通的\NSo, that would simply not fly in practice.
Dialogue: 0,0:03:15.96,0:03:17.44,Default,,0,0,0,,我们必须想办法\NWe have to have some way of
Dialogue: 0,0:03:17.44,0:03:21.10,Default,,0,0,0,,让只读事务不用锁\Ndoing read-only transaction that does not require any locks.
Dialogue: 0,0:03:21.10,0:03:23.28,Default,,0,0,0,,Spanner有趣的地方在于\NAnd the interesting thing about Spanner is
Dialogue: 0,0:03:23.28,0:03:26.64,Default,,0,0,0,,如何支持不用锁的只读事务\Nhow it enables those kinds of read-only transactions.
Dialogue: 0,0:03:26.64,0:03:28.94,Default,,0,0,0,,实现不用锁只读事务的方法是\NSo, the way this works is that
Dialogue: 0,0:03:28.94,0:03:33.76,Default,,0,0,0,,只读事务可以从一个被称为一致性快照的地方读取数据\Na read-only transaction can read from what is called a consistent snapshot.
Dialogue: 0,0:03:33.76,0:03:36.56,Default,,0,0,0,,一致性快照本质上是一种\NSo, a consistent snapshot is a way of
Dialogue: 0,0:03:36.56,0:03:39.90,Default,,0,0,0,,在某个时间点查看整个数据库的方法\Nessentially looking at the entire database at one point in time.
Dialogue: 0,0:03:39.90,0:03:43.64,Default,,0,0,0,,需要使用时间戳来实现一致性快照\NAnd the way it does this is using timestamps.
Dialogue: 0,0:03:43.64,0:03:50.26,Default,,0,0,0,,从一致性的角度看 关键点在于\NNow, the important thing for this consistent aspect is that
Dialogue: 0,0:03:50.26,0:03:52.40,Default,,0,0,0,,快照的一致性与因果关系是相同的\Nit means we're consistent with causality.
Dialogue: 0,0:03:52.40,0:03:54.24,Default,,0,0,0,,我这里的意思是\NAnd so, what I mean with this is
Dialogue: 0,0:03:54.24,0:03:59.44,Default,,0,0,0,,如果我们有两个事务T_1和T_2 如果T_1在T_2之前发生\Nif we have two transactions T_1 and T_2, and if T_1 happened before T_2,
Dialogue: 0,0:03:59.44,0:04:04.14,Default,,0,0,0,,那么如果我们的快照包含T_2的写操作\Nthen if we have a snapshot that contains the writes that were made by T_2,
Dialogue: 0,0:04:04.14,0:04:07.52,Default,,0,0,0,,则此快照也必须包含T_1的写操作\Nthen that snapshot must also reflect the writes by T_1, right?
Dialogue: 0,0:04:07.52,0:04:10.16,Default,,0,0,0,,这意味着我们的快照\NThat means that we don't end up with
Dialogue: 0,0:04:10.16,0:04:14.22,Default,,0,0,0,,不会丢失部分因果依赖关系\Nsome of the causal dependencies missing from the snapshot,
Dialogue: 0,0:04:14.22,0:04:20.40,Default,,0,0,0,,类似地 如果事务不包含T_1的写操作\Nlikewise, if the transaction does not contain the writes by T_1,
Dialogue: 0,0:04:20.40,0:04:22.88,Default,,0,0,0,,则此快照也不包含T_2的写操作\Nthen it will not contain the writes by T_2 either.
Dialogue: 0,0:04:22.88,0:04:25.14,Default,,0,0,0,,这是双向的保证\NSo, this goes both ways.
Dialogue: 0,0:04:25.14,0:04:30.40,Default,,0,0,0,,这就是我们所说的 快照与因果关系一致的意思\NNow, this is what we mean with a snapshot being consistent with causality.
Dialogue: 0,0:04:30.40,0:04:31.24,Default,,0,0,0,,这意味着\NIt just means that
Dialogue: 0,0:04:31.24,0:04:36.88,Default,,0,0,0,,我们不会得到不满足因果关系的数据库快照\Nwe don't have bits of the database snapshot that don't make sense causally.
Dialogue: 0,0:04:36.88,0:04:43.26,Default,,0,0,0,,如果快照包含了某个效果 则此快照也将包含产生此效果的原因\NSo, if the snapshot contains the effect, then it will also contain the cause of that effect.
Dialogue: 0,0:04:43.26,0:04:46.54,Default,,0,0,0,,即使只读事务在不用锁的条件下运行了很长一段时间\NAnd so, we want to ensure this consistent snapshot
Dialogue: 0,0:04:46.54,0:04:51.12,Default,,0,0,0,,我们也希望读操作满足一致性快照所提供的一致性保证\Neven if the read-only transaction runs for a long time and without taking any locks.
Dialogue: 0,0:04:51.12,0:04:53.86,Default,,0,0,0,,实现这一一致性模型的方法被称为\NAnd the way this is done is through approach called
Dialogue: 0,0:04:53.86,0:04:57.02,Default,,0,0,0,,多版本并发控制 缩写为MVCC\Nmulti-version concurrency control, or MVCC.
Dialogue: 0,0:04:57.02,0:04:59.62,Default,,0,0,0,,MVCC实际上是一个非常常用的技术\NNow, MVCC is actually a very common technique.
Dialogue: 0,0:04:59.62,0:05:04.76,Default,,0,0,0,,此技术被Postgres、MySQL等多个数据库系统所应用\NIt's used in lots of databases including Postgres, MySQL, for example.
Dialogue: 0,0:05:04.76,0:05:09.04,Default,,0,0,0,,此技术的工作原理是为每一个事务附加一个时间戳 也就是这里的t_w\NAnd the way it works is it attaches a timestamp to every transaction.
Dialogue: 0,0:05:09.04,0:05:13.74,Default,,0,0,0,,假设一个读写事务拥有时间戳t_w\NLet's say that a read-write transaction has a timestamp t_w.
Dialogue: 0,0:05:13.74,0:05:18.24,Default,,0,0,0,,此时间戳是在此事务提交时指定的\NAnd that timestamp is assigned at the time when that transaction commits.
Dialogue: 0,0:05:18.24,0:05:28.38,Default,,0,0,0,,随后 任意被事务T_w写入的数据\NAnd then, any data that is written by this transaction T_w,
Dialogue: 0,0:05:28.38,0:05:34.46,Default,,0,0,0,,也会关联此事务的提交时间戳\Nany data is associated, is tagged with the commit timestamp
Dialogue: 0,0:05:34.46,0:05:36.26,Default,,0,0,0,,即数据会用事务的提交时间戳打标\Nof the transaction that wrote it.
Dialogue: 0,0:05:36.26,0:05:42.92,Default,,0,0,0,,现在 如果一个对象将要被一个事务更新\NAnd now, if we have an object that is being updated by a transaction,
Dialogue: 0,0:05:42.92,0:05:50.52,Default,,0,0,0,,我们不会简单地在原地覆盖该对象\Nnow we won't simply overwrite that object in place,
Dialogue: 0,0:05:50.52,0:05:53.38,Default,,0,0,0,,我们构建此对象的一个新拷贝\Nbut we will make a new copy of that object,
Dialogue: 0,0:05:53.38,0:05:56.14,Default,,0,0,0,,这个新版本的对象打标的时间戳\Nand that new version of the object
Dialogue: 0,0:05:56.14,0:06:00.72,Default,,0,0,0,,等于更新此对象的事务提交时间戳t_w\Nwill be tagged with the timestamp t_w of the transaction that wrote that version.
Dialogue: 0,0:06:00.72,0:06:04.38,Default,,0,0,0,,我们会在原地保留旧版本的对象\NBut we will keep the old version of the object in place,
Dialogue: 0,0:06:04.38,0:06:08.40,Default,,0,0,0,,以防有一个只读事务需要读取旧版本\Nin case there's a read-only transaction that actually needs to read the old version.
Dialogue: 0,0:06:08.40,0:06:13.66,Default,,0,0,0,,现在 我们也为每个只读事务关联一个时间戳\NAnd now, we associate each read-only transaction also with a timestamp.
Dialogue: 0,0:06:13.66,0:06:14.94,Default,,0,0,0,,这个时间戳可以标识出\NAnd that timestamp identifies
Dialogue: 0,0:06:14.94,0:06:18.14,Default,,0,0,0,,在这一时间点观察数据库时\Nthe snapshot which is the point in time
Dialogue: 0,0:06:18.14,0:06:21.84,Default,,0,0,0,,应该查看哪个快照\Nat which that snapshot is observing the database.
Dialogue: 0,0:06:21.84,0:06:26.76,Default,,0,0,0,,现在 如果只读事务想要读取一个特定的对象\NAnd now, if the read-only transaction wants to read a particular object,
Dialogue: 0,0:06:26.76,0:06:31.16,Default,,0,0,0,,只读事务会查看各种不同版本的对象 每个版本都打标了一个时间戳\Nit looks at the different versions of that object, each version tagged with a timestamp.
Dialogue: 0,0:06:31.16,0:06:36.18,Default,,0,0,0,,只读事务忽略所有大于快照时间戳的对象版本\NIt ignores any versions that have a timestamp greater than the snapshot timestamp.
Dialogue: 0,0:06:36.84,0:06:37.26,Default,,0,0,0,,随后\NAnd then,
Dialogue: 0,0:06:37.26,0:06:41.96,Default,,0,0,0,,对于所有时间戳小于或等于快照时间戳的版本\Nof those versions that have a timestamp less than or equal to the snapshot timestamp,
Dialogue: 0,0:06:41.96,0:06:43.40,Default,,0,0,0,,只读事务选择最大的时间戳版本\Nit picks the highest.
Dialogue: 0,0:06:43.40,0:06:46.84,Default,,0,0,0,,这就是只读事务应该查看的对象版本\NAnd that is the version of the object that this transaction is going to see.
Dialogue: 0,0:06:46.84,0:06:47.32,Default,,0,0,0,,这样一来\NAnd so,
Dialogue: 0,0:06:47.32,0:06:52.22,Default,,0,0,0,,可以很容易让只读事务忽略所有并发写操作\Nthis now allows the read-only transaction to simply ignore any writes made concurrently.
Dialogue: 0,0:06:52.22,0:06:53.02,Default,,0,0,0,,因此\NSo,
Dialogue: 0,0:06:53.02,0:06:59.84,Default,,0,0,0,,只读事务可以在特定时间t_r查看整个数据库\Nthe read-only transaction is going to see the entire database as of this particular time t_r
Dialogue: 0,0:07:00.34,0:07:04.78,Default,,0,0,0,,并在不用锁的条件下忽略所有并发写操作\Nregardless of whatever writes happen otherwise and without taking any locks.
Dialogue: 0,0:07:04.78,0:07:08.20,Default,,0,0,0,,这个算法是可行的 这是一个非常标准的MVCC\NNow, this works. This is a very standard MVCC.
Dialogue: 0,0:07:08.84,0:07:11.20,Default,,0,0,0,,Spanner实现有趣的地方在于\NWhat is interesting about the way Spanner implements this
Dialogue: 0,0:07:11.20,0:07:14.28,Default,,0,0,0,,生成这些时间戳的方法\Nis the way these timestamps are generated.
Dialogue: 0,0:07:14.28,0:07:21.48,Default,,0,0,0,,为了保证快照满足因果一致性\NSo, in order to ensure that our snapshot is causally consistent,
Dialogue: 0,0:07:21.48,0:07:25.46,Default,,0,0,0,,我们的要求是 如果事务T_1在事务T_2之后发生\Nwhat we require is that if transaction T_1 happened before T_2,
Dialogue: 0,0:07:25.46,0:07:29.34,Default,,0,0,0,,则T_1的时间戳必须小于T_2的时间戳\Nthen the timestamp of T_1 has to be less than the timestamp of T_2,
Dialogue: 0,0:07:29.34,0:07:34.38,Default,,0,0,0,,因为这就是MVCC顺序性质所依赖的时间戳性质\Nbecause that's what this ordering property in MVCC is relying on.
Dialogue: 0,0:07:34.38,0:07:39.00,Default,,0,0,0,,回忆一下我们讨论物理时钟那节课的内容\NAnd recall from the lecture when we talked about physical clocks,
Dialogue: 0,0:07:39.00,0:07:41.98,Default,,0,0,0,,物理时钟无法保证这一时间戳要求\Nthat physical clocks do not actually guarantee this.
Dialogue: 0,0:07:41.98,0:07:44.70,Default,,0,0,0,,如果使用物理时钟 可能会出现的情况是\NSo, with physical clocks, you could end up in a situation
Dialogue: 0,0:07:44.70,0:07:49.98,Default,,0,0,0,,事务T_1在事务T_2之后发生\Nwhere transaction T_1 happened before transaction T_2,
Dialogue: 0,0:07:49.98,0:07:52.44,Default,,0,0,0,,但T_2的时间戳小于T_1的时间戳\Nbut T_2 had a lower timestamp than T_1.
Dialogue: 0,0:07:52.44,0:07:53.80,Default,,0,0,0,,我们不希望出现这种情况\NAnd we don't want this.
Dialogue: 0,0:07:53.80,0:07:57.16,Default,,0,0,0,,我们必须使用其他方法\NSo, we have to take some other measure
Dialogue: 0,0:07:57.16,0:08:00.76,Default,,0,0,0,,保证我们的时间戳与因果关系一致\Nto ensure that our timestamps are consistent with causality.
Dialogue: 0,0:08:00.76,0:08:03.42,Default,,0,0,0,,一个很明显的答案是 为什么不使用逻辑时钟呢\NThe obvious answer is, well, why don't we use logical clocks,
Dialogue: 0,0:08:03.42,0:08:07.68,Default,,0,0,0,,设计逻辑时钟的目的原本就是为了解决依赖关系问题的\Nbecause that's exactly what logical clocks were designed to do.
Dialogue: 0,0:08:07.68,0:08:08.70,Default,,0,0,0,,不幸的是\NUnfortunately,
Dialogue: 0,0:08:08.70,0:08:13.96,Default,,0,0,0,,在这种场景下 像Lamport时钟这样的逻辑时钟实际上也是不够的\Nlogical clocks like Lamport clocks are not actually sufficient in this case either.
Dialogue: 0,0:08:13.96,0:08:17.38,Default,,0,0,0,,我们用这下面这个例子来解释一下原因\NAnd the reason for this is by this particular example.
Dialogue: 0,0:08:17.38,0:08:21.42,Default,,0,0,0,,假设我们有两个副本A和B\NSo, let's say that here we have two replicas A and B.
Dialogue: 0,0:08:21.42,0:08:26.32,Default,,0,0,0,,用户在副本A上执行某个事务T_1\NAnd the user executes some transaction T_1 on replica A,
Dialogue: 0,0:08:26.32,0:08:29.56,Default,,0,0,0,,用户随后查看事务的执行结果\Nand then views the results of that transaction.
Dialogue: 0,0:08:29.56,0:08:34.34,Default,,0,0,0,,用户在屏幕上看到了T_1的执行结果 随后选择执行某个动作\NSo, the user has the results on the screen, then, the user chooses to perform some action,
Dialogue: 0,0:08:34.34,0:08:39.54,Default,,0,0,0,,此操作形成了在副本B上执行的事务T_2\Nand that action results in some transaction T_2 being executed on replica B.
Dialogue: 0,0:08:39.54,0:08:44.16,Default,,0,0,0,,这里很清楚 T_1是在T_2之前发生的\NSo here, very clearly, it's the case that T_1 happened before T_2,
Dialogue: 0,0:08:44.16,0:08:47.42,Default,,0,0,0,,因为中间还涉及用户的通信\Nbecause there's this user communication in the way,
Dialogue: 0,0:08:47.42,0:08:52.78,Default,,0,0,0,,通信过程保证用户的动作由T_1的结果决定\Nthe communication ensures that the action depends on the results from T_1.
Dialogue: 0,0:08:52.78,0:08:57.04,Default,,0,0,0,,从定义上看 我们希望T_1持有的时间戳比T_2小\NSo, definitely, in this case, we want T_1 to have a lower timestamp than T_2.
Dialogue: 0,0:08:57.04,0:09:02.98,Default,,0,0,0,,但如果我们这里使用Lamport时钟 回忆一下Lamport时钟的工作原理\NBut if we're using Lamport clocks, well, remember the way Lamport clocks work is
Dialogue: 0,0:09:02.98,0:09:08.40,Default,,0,0,0,,Lamport时钟要在网络中发送的每一条消息上附加一个时间戳\Nthey work by attaching a timestamp to every message that is sent over the network.
Dialogue: 0,0:09:08.40,0:09:12.86,Default,,0,0,0,,当你收到其中一条消息时 你需要把你自己的本地时间戳更新为\NAnd then, when you receive one of those messages, you bump up your own local clock
Dialogue: 0,0:09:12.86,0:09:17.68,Default,,0,0,0,,本地时间戳和收到时间戳的最大值\Nto the maximum of the local timestamp and the one you received.
Dialogue: 0,0:09:17.68,0:09:19.84,Default,,0,0,0,,但在这个例子中\NBut in this case, here in this example,
Dialogue: 0,0:09:19.84,0:09:22.88,Default,,0,0,0,,副本A和副本B之间没有任何通信\Nthere might not be any communication between replicas A and B.
Dialogue: 0,0:09:22.88,0:09:28.68,Default,,0,0,0,,当发生此例子的情况时 副本A可能永远无法给副本B发送任何消息\NSo, replica A may never send any message to replica B while this is happening,
Dialogue: 0,0:09:28.68,0:09:31.26,Default,,0,0,0,,因为通信是由用户发起的\Nbecause the communication is going by a user.
Dialogue: 0,0:09:31.26,0:09:36.50,Default,,0,0,0,,因此 我们无法把时间戳从A传播到B\NAnd so, there's nothing that can propagate our timestamps from A to B,
Dialogue: 0,0:09:36.50,0:09:39.36,Default,,0,0,0,,因为没有可用于传播时间戳的消息\Nbecause there's no message that can propagate the timestamps,
Dialogue: 0,0:09:39.36,0:09:43.38,Default,,0,0,0,,我们也无法要求用户主动输入时间戳 或者执行类似的操作\Nand we can't rely on the user to like type in timestamps or something like that here.
Dialogue: 0,0:09:43.38,0:09:47.80,Default,,0,0,0,,因此 副本B可能无法意识到\NSo, replica B may not actually realize that
Dialogue: 0,0:09:47.80,0:09:52.68,Default,,0,0,0,,它需要拥有一个大于时间戳T_1的时间戳T_2\Nit needs to have a timestamp for T_2 that is higher than the timestamp of T_1,
Dialogue: 0,0:09:52.68,0:09:56.02,Default,,0,0,0,,因为没有渠道可以传递\Nbecause there's nothing passing along these timestamps
Dialogue: 0,0:09:56.02,0:09:58.48,Default,,0,0,0,,Lamport时钟所需要传递的时间戳\Nthat we would need for Lamport clocks.
Dialogue: 0,0:09:58.48,0:10:02.20,Default,,0,0,0,,因此 Lamport时钟也不可行 我们该怎么办呢？\NSo, Lamport clocks don't work either. So, what can we do in this case?
Dialogue: 0,0:10:02.20,0:10:04.92,Default,,0,0,0,,我们仍然可以使用物理时钟\NWell, we can go back to physical clocks,
Dialogue: 0,0:10:04.92,0:10:09.50,Default,,0,0,0,,但我们必须对物理时钟进行一些调整\Nbut we have to adjust the physical clocks and do some extra measures
Dialogue: 0,0:10:09.50,0:10:15.64,Default,,0,0,0,,用一些额外措施保证时钟满足因果关系\Nin order to make sure that this causal ordering property here is satisfied.
Dialogue: 0,0:10:15.64,0:10:20.06,Default,,0,0,0,,Spanner实现这一点的方法是使用一个被称为TrueTime的系统\NAnd the way Spanner does this is using a system called TrueTime.
Dialogue: 0,0:10:20.06,0:10:24.62,Default,,0,0,0,,TrueTime是一个物理时钟系统\NSo, TrueTime is a system of physical clocks
Dialogue: 0,0:10:25.36,0:10:29.50,Default,,0,0,0,,此系统可以显式捕获时间戳的不确定性\Nthat explicitly captures uncertainty in the timestamps.
Dialogue: 0,0:10:29.50,0:10:32.46,Default,,0,0,0,,这是Spanner中一个非常有趣的部分\NSo, this is the really interesting bit about Spanner.
Dialogue: 0,0:10:32.46,0:10:38.54,Default,,0,0,0,,此系统的工作原理是 假设副本A想要提交事务T_1\NAnd the way this works is, say, replica A wants to commit transaction T_1.
Dialogue: 0,0:10:38.54,0:10:41.44,Default,,0,0,0,,在副本A想要提交此事务的时刻\NAt the time when it wants to commit that transaction,
Dialogue: 0,0:10:42.08,0:10:45.36,Default,,0,0,0,,副本A从TrueTime请求一个时间戳\Nthe replica requests a timestamp from TrueTime.
Dialogue: 0,0:10:45.36,0:10:50.02,Default,,0,0,0,,TrueTime不会简单返回单个时间戳 它会返回一个时间戳范围\NAnd TrueTime does not reply with simply a single timestamp, but it returns a range.
Dialogue: 0,0:10:50.02,0:10:54.68,Default,,0,0,0,,它返回两个时间戳：最早可能时间戳和最晚可能时间戳\NIt returns two timestamps, the earliest possible and the latest possible.
Dialogue: 0,0:10:54.68,0:10:57.40,Default,,0,0,0,,因为系统存在不确定性\NAnd so, because of the uncertainties we have,
Dialogue: 0,0:10:57.40,0:11:01.62,Default,,0,0,0,,我们无法在系统实现完美的时钟同步\Nthere's no perfect synchronization of clocks in the systems that we have,
Dialogue: 0,0:11:01.62,0:11:06.38,Default,,0,0,0,,我们永远无法肯定当前真实的物理时间戳是什么\Nwe can never be totally certain about what the current real physical timestamp is.
Dialogue: 0,0:11:06.38,0:11:11.76,Default,,0,0,0,,但我们可以追踪系统中的所有错误和所有不确定性\NBut we can track all of the errors in the system and all of the uncertainty in the system.
Dialogue: 0,0:11:11.76,0:11:14.60,Default,,0,0,0,,如果我们可以正确考虑到所有的不确定性\NAnd if we correctly account for the uncertainty,
Dialogue: 0,0:11:14.60,0:11:16.20,Default,,0,0,0,,我们就可以确定\Nthen we can be sure that
Dialogue: 0,0:11:16.20,0:11:18.36,Default,,0,0,0,,真实物理时钟有非常大的概率\Nthe real physical timestamp will be somewhere
Dialogue: 0,0:11:18.36,0:11:23.02,Default,,0,0,0,,位于最早可能时间戳和最晚可能时间戳之间\Nbetween this earliest possible and latest possible with very high probability.
Dialogue: 0,0:11:23.02,0:11:26.62,Default,,0,0,0,,这意味着我们必须追踪节点与时钟服务器之间的往返时间\NSo, this means we have to track like the round trip time to the clock server.
Dialogue: 0,0:11:26.62,0:11:28.70,Default,,0,0,0,,我们必须考虑时钟漂移量\NWe need to account for clock drift.
Dialogue: 0,0:11:28.70,0:11:31.74,Default,,0,0,0,,我们必须考虑所有可能导致错误的因素\NWe have to account for any sort of things that might cause error.
Dialogue: 0,0:11:31.74,0:11:34.22,Default,,0,0,0,,将所有这些潜在导致错误的因素加在一起\NAdd up all of those potential causes of error
Dialogue: 0,0:11:34.22,0:11:37.76,Default,,0,0,0,,把所有这些因素都纳入单一的不确定间隔\Nand factor this all into a single uncertainty interval
Dialogue: 0,0:11:37.76,0:11:39.88,Default,,0,0,0,,这样我们就知道\Nso that we know that
Dialogue: 0,0:11:39.88,0:11:41.96,Default,,0,0,0,,真实时间戳应该会位于\Nthe real timestamp lies somewhere in
Dialogue: 0,0:11:41.96,0:11:45.10,Default,,0,0,0,,最早可能时间戳和最晚可能时间戳之间\Nbetween this early as possible and the latest possible.
Dialogue: 0,0:11:45.10,0:11:47.90,Default,,0,0,0,,现在 Spanner要做的是\NAnd now, what Spanner is going to do is
Dialogue: 0,0:11:47.90,0:11:51.00,Default,,0,0,0,,让副本A从TrueTime得到最早和最晚可能时间戳\Nit gets this pair of earliest and latest from TrueTime.
Dialogue: 0,0:11:51.00,0:11:52.50,Default,,0,0,0,,接下来 副本A开始等待\NAnd now, it's going to wait.
Dialogue: 0,0:11:52.50,0:11:57.58,Default,,0,0,0,,等待的时间恰好等于最晚和最早可能时间戳的差值\NAnd the time it's going to wait is exactly the difference between the two timestamps.
Dialogue: 0,0:11:57.58,0:12:03.32,Default,,0,0,0,,用δ_1表示不确定时间间隔的间隔长度\NAnd so, this length of the uncertainty time interval, called that δ_1,
Dialogue: 0,0:12:03.32,0:12:06.04,Default,,0,0,0,,事务只需要等待δ_1这么长的时间\Nthe transaction simply going to wait for that time.
Dialogue: 0,0:12:06.04,0:12:08.20,Default,,0,0,0,,在等待时间段内 副本A不做任何事情\NIt's not going to do anything during that time.
Dialogue: 0,0:12:08.20,0:12:10.66,Default,,0,0,0,,副本A只是继续持有所有的锁\NIt's going to continue holding all of the locks.
Dialogue: 0,0:12:10.66,0:12:15.00,Default,,0,0,0,,当事务已经准备好提交时 副本A不提交此事务\NSo, the transaction is ready to commit, it just hasn't actually committed yet.
Dialogue: 0,0:12:15.00,0:12:17.18,Default,,0,0,0,,副本A等待δ_1的时间周期\NAnd it's going to wait for this period δ_1.
Dialogue: 0,0:12:17.18,0:12:18.66,Default,,0,0,0,,等待时间一旦超过δ_1\NAnd once that time has elapsed,
Dialogue: 0,0:12:18.66,0:12:22.86,Default,,0,0,0,,副本A就提交事务 释放所有的锁 继续往后执行\Nnow it commits, it releases all of the locks, and it moves on.
Dialogue: 0,0:12:22.86,0:12:26.74,Default,,0,0,0,,这里的额外等待操作是一个关键点\NSo, this extra wait is the key thing here.
Dialogue: 0,0:12:26.74,0:12:31.62,Default,,0,0,0,,现在 假设副本B想要执行事务T_2 它也做同样的事情\NNow, let's say that replica B wants to execute transaction T_2. It does the same thing.
Dialogue: 0,0:12:31.62,0:12:36.18,Default,,0,0,0,,当准备好提交事务时 副本B从TrueTime请求时钟\NWhen it's ready to commit, it requests timestamps from TrueTime.
Dialogue: 0,0:12:36.18,0:12:38.90,Default,,0,0,0,,副本B得到了最早可能时间戳和最晚可能时间戳\NSo, it gets back an early as possible and late as possible.
Dialogue: 0,0:12:38.90,0:12:42.72,Default,,0,0,0,,同样地 副本B等待不确定间隔时间δ_2\NAnd again, it waits out the uncertainty, in this case δ_2,
Dialogue: 0,0:12:42.72,0:12:45.66,Default,,0,0,0,,即等待两个时间戳的差值时间\Nthe difference between the two timestamps.
Dialogue: 0,0:12:45.66,0:12:49.36,Default,,0,0,0,,这样一来 我们就得到了真实时间依赖关系\NNow, in this case, here we have this real-time dependency
Dialogue: 0,0:12:49.36,0:12:53.96,Default,,0,0,0,,T_2的开始时间晚于T_1的结束时间\Nso that T_2 started after T_1 ended.
Dialogue: 0,0:12:53.96,0:12:59.56,Default,,0,0,0,,等待不确定间隔时间的目的是保证\NAnd the effect that this waiting has had is to ensure that
Dialogue: 0,0:12:59.56,0:13:04.60,Default,,0,0,0,,如果我们有两组时间戳 其对应的事务存在真实时间依赖关系\Nif we have these two timestamps where there's a real-time dependency,
Dialogue: 0,0:13:04.60,0:13:09.08,Default,,0,0,0,,则从TrueTime得到的两组时间戳 其不确定间隔不会重叠\Nthen their uncertainty intervals from TrueTime will not overlap.
Dialogue: 0,0:13:09.08,0:13:13.70,Default,,0,0,0,,因为不确定间隔不会重叠\NAnd because the uncertainty intervals do not overlap,
Dialogue: 0,0:13:13.70,0:13:17.74,Default,,0,0,0,,这就意味着 提交T_1的时间戳\Nthis means now that the commit timestamp for T_1
Dialogue: 0,0:13:17.74,0:13:22.60,Default,,0,0,0,,一定比提交T_2的时间戳小\Nwill definitely be a lower timestamp than the commit timestamp of T_2.
Dialogue: 0,0:13:22.60,0:13:27.58,Default,,0,0,0,,通过让不确定间隔不出现重叠\NBy having these uncertainty periods non-overlapping,
Dialogue: 0,0:13:28.28,0:13:30.92,Default,,0,0,0,,我们消除了\Nwe have got rid of the possibility of
Dialogue: 0,0:13:30.92,0:13:35.10,Default,,0,0,0,,时间戳可能乱序导致与因果关系不一致的可能\Nthe timestamps getting reordered and thus being inconsistent with causality.
Dialogue: 0,0:13:35.10,0:13:37.68,Default,,0,0,0,,这里的关键点是等待\NSo, the key here is this waiting.
Dialogue: 0,0:13:38.36,0:13:42.50,Default,,0,0,0,,当然 在真实系统中 我们希望等待时间要尽可能短\NAnd of course, in a real system, we want to wait for as short time as possible.
Dialogue: 0,0:13:42.50,0:13:44.34,Default,,0,0,0,,为此 我们要做两件事情\NSo, we now need to do two things.
Dialogue: 0,0:13:44.34,0:13:47.50,Default,,0,0,0,,第一 我们要准确量化不确定性\NFirstly, we need to precisely quantify the uncertainty
Dialogue: 0,0:13:47.50,0:13:49.50,Default,,0,0,0,,这样我们才能知道必须等待的时间\Nso that we know how long we have to wait.
Dialogue: 0,0:13:49.50,0:13:52.78,Default,,0,0,0,,第二 我们必须保证不确定性尽可能小\NAnd then, secondly, we have to keep the uncertainty as small as possible
Dialogue: 0,0:13:52.78,0:13:55.40,Default,,0,0,0,,这样才能让等待时间尽可能小\Nso that our waiting time is as short as possible.
Dialogue: 0,0:13:55.40,0:13:58.52,Default,,0,0,0,,TrueTime让不确定性尽可能小的方法是\NAnd the way that TrueTime does this is by
Dialogue: 0,0:13:58.52,0:14:03.44,Default,,0,0,0,,在每一个数据中心都放置了原子钟和GPS接收器\Nactually putting atomic clocks and GPS receivers in every data center.
Dialogue: 0,0:14:03.44,0:14:05.16,Default,,0,0,0,,这当然会引入一定的费用\NAnd these cost some money of course,
Dialogue: 0,0:14:05.16,0:14:08.36,Default,,0,0,0,,但谷歌认为它们负担得起\Nbut Google has figured out that they're actually affordable enough.
Dialogue: 0,0:14:08.36,0:14:12.98,Default,,0,0,0,,谷歌认为在每个数据中心放置GPS接收器和原子钟的费用是可接受的\NIt is alright. You can actually put GPS receivers and atomic clocks in every data center.
Dialogue: 0,0:14:12.98,0:14:18.34,Default,,0,0,0,,这就让每一个数据中心都有了一个可靠的时钟源\NAnd this gives each data center a reliable clock source.
Dialogue: 0,0:14:18.34,0:14:19.62,Default,,0,0,0,,现在\NAnd now,
Dialogue: 0,0:14:19.62,0:14:25.38,Default,,0,0,0,,数据中心剩下的每个节点不直接与可靠时钟连接\Nevery other node in the data center that is not directly connected to these reliable clocks,
Dialogue: 0,0:14:25.38,0:14:28.38,Default,,0,0,0,,每个普通节点只有一个普通的石英钟\Nevery normal node just has the usual quartz clock.
Dialogue: 0,0:14:28.38,0:14:32.78,Default,,0,0,0,,每个普通节点将周期性地执行时钟同步\NAnd it is going to periodically synchronize its local quartz clock
Dialogue: 0,0:14:32.78,0:14:37.04,Default,,0,0,0,,本地石英钟会与附加原子钟或GPS接收器的时间服务器周期性同步时钟\Nwith the time server that has the atomic clock or the GPS receiver attached.
Dialogue: 0,0:14:37.04,0:14:41.34,Default,,0,0,0,,TrueTime实际上每30秒执行一次时钟同步\NAnd TrueTime actually performs this clock synchronization every 30 seconds.
Dialogue: 0,0:14:41.34,0:14:44.02,Default,,0,0,0,,就好像数据中心的每个节点\NAnd so, every 30 seconds, there's going to be like a ping
Dialogue: 0,0:14:44.02,0:14:48.58,Default,,0,0,0,,每30秒就会ping一次本地时间服务器一样\Nfrom each node in the data center to its local time server.
Dialogue: 0,0:14:48.58,0:14:50.82,Default,,0,0,0,,这样做的结果是\NAnd the result is that
Dialogue: 0,0:14:51.32,0:14:55.66,Default,,0,0,0,,每次执行完时钟同步 不确定性就会降低\Nevery time that clock synchronization is performed, the uncertainty drops down,
Dialogue: 0,0:14:55.66,0:15:01.88,Default,,0,0,0,,因为时钟同步过程中的不确定性只来自于服务器的往返时间\Nbecause the uncertainty now is just essentially the round trip time to the server
Dialogue: 0,0:15:01.88,0:15:05.30,Default,,0,0,0,,以及服务器自身时钟的时间不确定性\Nplus any uncertainty that the server had about its own time.
Dialogue: 0,0:15:05.30,0:15:10.52,Default,,0,0,0,,由于我们假设这里的时间服务器都位于本地数据中心\NAnd so, because we're assuming that here the time server is in the local data center,
Dialogue: 0,0:15:10.52,0:15:15.82,Default,,0,0,0,,而时钟服务器的局域网往返时间一般都小于1毫秒\Nlocally the round trip time to the clock server will usually be less than 1 millisecond,
Dialogue: 0,0:15:16.26,0:15:19.80,Default,,0,0,0,,因为这里不存在长距离通信问题\Nbecause there are no big geographic distances to be covered here.
Dialogue: 0,0:15:19.80,0:15:23.80,Default,,0,0,0,,因此 每当我们与时钟服务器同步一次\NAnd so, therefore, whenever we sync with the clock server,
Dialogue: 0,0:15:23.80,0:15:29.26,Default,,0,0,0,,本地时钟的不确定性就会降低到大约为1毫秒\Nthe uncertainty about local clock drops down to about 1 millisecond.
Dialogue: 0,0:15:29.26,0:15:34.14,Default,,0,0,0,,接下来 在没有执行时钟同步的这30秒间隔内\NAnd then, in these 30 second intervals between the synchronizations,
Dialogue: 0,0:15:34.14,0:15:35.28,Default,,0,0,0,,不确定间隔取决于\Nwell, it depends on
Dialogue: 0,0:15:35.28,0:15:41.64,Default,,0,0,0,,本地时钟与真实时间相比的漂移速率\Nthe rate at which the local clock drifts with respect to the actual real time.
Dialogue: 0,0:15:41.64,0:15:43.82,Default,,0,0,0,,为此 谷歌做了一些测量\NAnd so, for this, Google did some measurements,
Dialogue: 0,0:15:43.82,0:15:47.96,Default,,0,0,0,,它们找到了我们必须假设的最坏情况时钟不确定性\Nand they figured out what is the worst-case clock uncertainty that we have to assume
Dialogue: 0,0:15:47.96,0:15:52.62,Default,,0,0,0,,才能保证所有的时钟漂移都低于下图的这个上界\Nto make sure that all of the clocks have a drift that is lower than this bound.
Dialogue: 0,0:15:52.62,0:15:58.14,Default,,0,0,0,,它们指出 最坏情况下 200ppm的漂移量是一个安全的假设\NAnd they figured out that a worst-case drift of 200ppm was a safe assumption to make.
Dialogue: 0,0:15:58.14,0:16:03.68,Default,,0,0,0,,这意味着在30秒的时钟同步之间\NAnd so, this means here that in between these 30-second clock syncs,
Dialogue: 0,0:16:03.68,0:16:09.90,Default,,0,0,0,,每个本地时钟的不确定性以200ppm的速度不断增加\Nthe uncertainty of each local clock keeps drifting up at a rate of 200ppm.
Dialogue: 0,0:16:09.90,0:16:12.70,Default,,0,0,0,,这意味着在30秒的时间内\NSo, this means over the course of 30 seconds,
Dialogue: 0,0:16:12.70,0:16:16.50,Default,,0,0,0,,我们累积了大约6毫秒的时钟不确定性\Nwe rack up about 6 milliseconds of clock uncertainty.
Dialogue: 0,0:16:16.50,0:16:18.46,Default,,0,0,0,,TrueTime持续追踪\NAnd TrueTime keeps track of exactly
Dialogue: 0,0:16:18.46,0:16:21.38,Default,,0,0,0,,距离上一次时钟同步经过了多长时间\Nhow long it's been since the last clock synchronization,
Dialogue: 0,0:16:21.38,0:16:22.08,Default,,0,0,0,,因此\Nand therefore,
Dialogue: 0,0:16:22.08,0:16:26.20,Default,,0,0,0,,不确定间隔会持续扩大、扩大、再扩大\Nit has these uncertainty intervals that keep widening and widening and widening,
Dialogue: 0,0:16:26.20,0:16:28.24,Default,,0,0,0,,直到进行下一次时钟同步\Nuntil the next clock sync.
Dialogue: 0,0:16:28.24,0:16:31.00,Default,,0,0,0,,随后 不确定间隔会落回到1毫秒\NAnd then, the uncertainty drops back down to 1 millisecond.
Dialogue: 0,0:16:31.00,0:16:33.04,Default,,0,0,0,,接下来 不确定间隔会继续扩大 以此类推\NAnd then, they start widening again and so on.
Dialogue: 0,0:16:33.04,0:16:36.38,Default,,0,0,0,,我们可以得到锯齿状的不确定间隔图像\NWe get this kind of sawtooth pattern here.
Dialogue: 0,0:16:36.38,0:16:38.66,Default,,0,0,0,,这样做的结果是\NAnd the result is now that
Dialogue: 0,0:16:38.66,0:16:43.66,Default,,0,0,0,,我们对时钟的不确定性有了一个非常精确的概念\Nwe have a very accurate notion of what our clock uncertainty is,
Dialogue: 0,0:16:43.66,0:16:47.02,Default,,0,0,0,,这可以允许我们确定每个事务的等待时间\Nwhich allows us to determine the wait time for each transaction.
Dialogue: 0,0:16:47.02,0:16:51.06,Default,,0,0,0,,进一步 因为本地时间服务器使用的是精确时钟\NAnd moreover, because we're using these local accurate clocks,
Dialogue: 0,0:16:51.06,0:16:52.94,Default,,0,0,0,,使用的是原子时钟和GPS接收器\Natomic clocks and GPS receivers,
Dialogue: 0,0:16:52.94,0:16:55.38,Default,,0,0,0,,平均时间不确定性实际上非常小\Nthe average time uncertainty is actually quite small.
Dialogue: 0,0:16:55.38,0:17:01.74,Default,,0,0,0,,因此 平均不确定间隔时长大约为4毫秒\NSo, the uncertainty interval average length is about 4 milliseconds.
Dialogue: 0,0:17:01.74,0:17:04.40,Default,,0,0,0,,也就是说 在提交事务之前\NAnd so, an average about 4 milliseconds is the time
Dialogue: 0,0:17:04.40,0:17:07.26,Default,,0,0,0,,平均等待时间约为4毫秒\Nthat the transaction needs to wait before it's allowed to commit.
Dialogue: 0,0:17:07.26,0:17:10.04,Default,,0,0,0,,4毫秒的时间实际上非常短\NAnd 4 milliseconds is a pretty short time actually.
Dialogue: 0,0:17:10.04,0:17:11.84,Default,,0,0,0,,这肯定比\NIt's certainly a lot shorter than
Dialogue: 0,0:17:11.84,0:17:16.80,Default,,0,0,0,,不同大陆之间的数据中心往返时间要短得多\Nthe time it would take to do like a round trip time to a data center on a different continent,
Dialogue: 0,0:17:16.80,0:17:19.30,Default,,0,0,0,,此往返时间一般为100毫秒或更长时间\Nwhich would take like 100 milliseconds or more.
Dialogue: 0,0:17:19.30,0:17:23.78,Default,,0,0,0,,这就是Spanner涉及的关键技术\NSo, this is really the key insight of Spanner
Dialogue: 0,0:17:23.78,0:17:26.66,Default,,0,0,0,,我们可以使用可靠时钟\Nthat we can use these reliable clocks,
Dialogue: 0,0:17:26.66,0:17:32.26,Default,,0,0,0,,并仔细测量和统计时间不确定性\Nand the careful measurement, and careful accounting of uncertainty
Dialogue: 0,0:17:32.26,0:17:35.96,Default,,0,0,0,,从而保证时间戳与因果关系一致\Nto ensure that the timestamps are consistent with causality.
Dialogue: 0,0:17:35.96,0:17:38.64,Default,,0,0,0,,现在 我们有了与因果关系一致的时间戳\NNow that we have timestamps that are consistent with causality,
Dialogue: 0,0:17:38.64,0:17:40.90,Default,,0,0,0,,我们在不用锁的条件下\Nwe get these causally consistent snapshots
Dialogue: 0,0:17:40.90,0:17:44.30,Default,,0,0,0,,通过使用多版本并发控制得到了满足因果一致性的快照\Nusing Multi-Version Concurrency Control without taking any locks.
Dialogue: 0,0:17:44.30,0:17:48.50,Default,,0,0,0,,因此 我们可以在不用锁的条件下执行大规模读事务\NSo, therefore, we can do these large-scale read transactions without any locks.
Dialogue: 0,0:17:48.50,0:17:50.42,Default,,0,0,0,,我们可以执行数据库备份\NSo, we can do database backups
Dialogue: 0,0:17:50.42,0:17:54.78,Default,,0,0,0,,同时又不用中断数据库中正在发生的任何写事务\Nwithout disrupting any write transactions that are happening in the database.
Dialogue: 0,0:17:54.78,0:17:56.22,Default,,0,0,0,,大家可以看到\NSo, you see here,
Dialogue: 0,0:17:56.22,0:18:00.52,Default,,0,0,0,,真实系统会通过组合使用各种假设和算法\Nthis is sort of the stack of assumptions and combinations of algorithms
Dialogue: 0,0:18:00.52,0:18:02.50,Default,,0,0,0,,以满足所需的系统模型\Nthat you get in real systems,
Dialogue: 0,0:18:02.50,0:18:06.82,Default,,0,0,0,,这是一个非常具体、应用广泛的系统\Nbut this is a very concrete really very widely used system
Dialogue: 0,0:18:07.32,0:18:09.24,Default,,0,0,0,,在实际中得到了广泛的部署\Nthat is widely deployed in practice.
Dialogue: 0,0:18:09.24,0:18:10.62,Default,,0,0,0,,大家可以看到\NAnd you can see
Dialogue: 0,0:18:10.62,0:18:15.12,Default,,0,0,0,,所有这些分布式系统概念是如何在单一系统中结合在一起使用的\Nhow all of these distributed systems concepts come together in a single system,
Dialogue: 0,0:18:15.12,0:18:16.66,Default,,0,0,0,,我觉得这非常令人兴奋\Nwhich I find very exciting.
Dialogue: 0,0:18:17.46,0:18:20.10,Default,,0,0,0,,分布式系统课程到此结束\NSo, that is the end of the distributed systems course.
Dialogue: 0,0:18:20.10,0:18:23.32,Default,,0,0,0,,我希望大家能够喜欢这门课 我希望大家能有所收获\NI hope you enjoyed it. I hope you got something out of the ideas.
Dialogue: 0,0:18:23.32,0:18:26.42,Default,,0,0,0,,如果大家有任何问题 请随时给我发邮件\NIf you have any questions, feel free to just ping me an email.
Dialogue: 0,0:18:26.88,0:18:31.86,Default,,0,0,0,,在座的剑桥大学学生也请别忘了填写课程评估\NFor the Cambridge students among you, don't forget to fill out the lecture evaluations.
Dialogue: 0,0:18:31.86,0:18:34.48,Default,,0,0,0,,希望大家能够喜欢这门课\NAnd yes, I hope you enjoyed it.
Dialogue: 0,0:18:34.48,0:18:38.60,Default,,0,0,0,,下次再见 感谢大家 拜拜\NAnd see you another time. Thank you. Bye bye.
