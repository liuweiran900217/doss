[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 4.3_Broadcast algorithms.mp4
Video File: 4.3_Broadcast algorithms.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 180
Active Line: 199
Video Position: 21506

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.04,0:00:02.68,Default,,0,0,0,,接下来 我们将要学习\NNext, let's have a look at
Dialogue: 0,0:00:02.68,0:00:06.82,Default,,0,0,0,,实现不同广播模型的具体算法\Nalgorithms for actually implementing these different models of broadcast.
Dialogue: 0,0:00:06.82,0:00:09.54,Default,,0,0,0,,我们将分两个步骤来讲解\NSo, we're going to do that in two separate stages.
Dialogue: 0,0:00:09.54,0:00:14.74,Default,,0,0,0,,首先 我们将展示如何让尽力广播变为可靠广播\NFirst of all, we'll show how to take best-effort broadcast and make it reliable.
Dialogue: 0,0:00:14.74,0:00:17.28,Default,,0,0,0,,一旦我们有了可靠广播\NAnd then, once we've got reliable broadcast,
Dialogue: 0,0:00:17.28,0:00:21.74,Default,,0,0,0,,我们就可以将可靠广播作为基础层 在此之上构建顺序传递模块\Nwe can layer on top of that modules for doing the delivery order,
Dialogue: 0,0:00:21.74,0:00:27.20,Default,,0,0,0,,从而允许我们实现FIFO广播、因果关系广播、以及全序关系广播\Nwhich allows us then to do either FIFO or causal or total order broadcast.
Dialogue: 0,0:00:27.20,0:00:30.56,Default,,0,0,0,,我们先从可靠层开始\NSo, let's start with the reliability layer here.
Dialogue: 0,0:00:31.60,0:00:36.58,Default,,0,0,0,,你可能觉得 最显然的一种广播算法实现方法是\NThe most obvious thing you might think about as a broadcast algorithm is
Dialogue: 0,0:00:36.58,0:00:39.74,Default,,0,0,0,,你想让一个节点广播一条消息\Nyou have the node that wants to broadcast a message
Dialogue: 0,0:00:39.74,0:00:45.36,Default,,0,0,0,,只需要让将此条消息通过点对点链路发送给所有其他的节点\Njust sends that message individually to every other node via point-to-point links
Dialogue: 0,0:00:45.36,0:00:48.10,Default,,0,0,0,,并保证点对点链路是可靠链路\Nand make those point-to-point links reliable
Dialogue: 0,0:00:48.10,0:00:51.80,Default,,0,0,0,,如果消息在发送过程中丢失 发送者只需要重新发送消息\Nso that if the message gets dropped along the way, then the sender will resend it,
Dialogue: 0,0:00:51.80,0:00:54.48,Default,,0,0,0,,这样一来 通过重传机制\Nand so, because then through the retransmission,
Dialogue: 0,0:00:54.48,0:00:58.24,Default,,0,0,0,,消息最终都可以成功传输到所有其他节点\Nthe message will eventually get through to every other node.
Dialogue: 0,0:00:58.24,0:01:03.14,Default,,0,0,0,,不幸的是 这种方法不可行 原因是可能会发生下面这种情况\NThis unfortunately does not quite work because what could happen is this here,
Dialogue: 0,0:01:03.14,0:01:07.02,Default,,0,0,0,,A尝试向B和C广播消息m_1\NA could try to broadcast message m_1 to B and C,
Dialogue: 0,0:01:07.02,0:01:11.28,Default,,0,0,0,,消息被成功传输到C处 但消息在传输到B的过程中丢失了\Nthe message gets through to C, but the message gets dropped on its way to B.
Dialogue: 0,0:01:11.28,0:01:14.16,Default,,0,0,0,,因此 A要向B重传消息\NSo, A has to retransmit the message to B,
Dialogue: 0,0:01:14.16,0:01:19.56,Default,,0,0,0,,但随后 A在完成消息重传前崩溃了\Nbut then A crashes before A is able to complete this retransmission.
Dialogue: 0,0:01:19.56,0:01:25.18,Default,,0,0,0,,在这种情况下 没有人能够向B重传消息m_1\NAnd in this case, nobody is ever going to retry the sending of message m_1 to B.
Dialogue: 0,0:01:25.18,0:01:29.60,Default,,0,0,0,,因此 C将传递一条B无法传递的消息\NAnd so, therefore, C will have delivered a message that B did not deliver.
Dialogue: 0,0:01:29.60,0:01:31.44,Default,,0,0,0,,B永远无法传递此条消息\NB is never going to deliver this message.
Dialogue: 0,0:01:31.44,0:01:33.38,Default,,0,0,0,,此时 节点间出现了不一致的情况\NAnd therefore, we have an inconsistency.
Dialogue: 0,0:01:33.38,0:01:38.04,Default,,0,0,0,,我们现在需要设计一个健壮算法\NSo, we have to now design an algorithm which is robust
Dialogue: 0,0:01:38.04,0:01:41.44,Default,,0,0,0,,使得即使消息发送方崩溃了\Nso that even if the sender of a message crashes,
Dialogue: 0,0:01:41.44,0:01:46.34,Default,,0,0,0,,所有剩余的节点仍然可以就实际传递的消息达成一致\Nall of the remaining nodes will still agree on which message was actually delivered.
Dialogue: 0,0:01:46.34,0:01:51.26,Default,,0,0,0,,我们可以使用的一种技术称为迫切可靠广播\NAnd so, one technique we can use is called eager reliable broadcast,
Dialogue: 0,0:01:51.26,0:01:55.72,Default,,0,0,0,,此技术本质上是让每个人向每个地方都发送消息\Nand that relies on essentially just everybody sending messages everywhere.
Dialogue: 0,0:01:55.72,0:01:59.92,Default,,0,0,0,,首先 A向B和C广播m_1\NSo, first of all, A wants to broadcast m_1 to B and C.
Dialogue: 0,0:01:59.92,0:02:04.10,Default,,0,0,0,,当B先收到m_1时\NWhen B first receives m_1,
Dialogue: 0,0:02:04.10,0:02:10.12,Default,,0,0,0,,B通过点对点链路向其他每个节点重广播此条消息\Nit rebroadcasts the same message again via point-to-point links to every other node.
Dialogue: 0,0:02:10.12,0:02:17.86,Default,,0,0,0,,这样一来 即使A崩溃了 B仍然可以进一步传播消息\NAnd so, this way, then even if A crashed, B will have further disseminated the message.
Dialogue: 0,0:02:17.86,0:02:20.32,Default,,0,0,0,,当C先收到消息时\NAnd when C first receives the message,
Dialogue: 0,0:02:20.32,0:02:23.76,Default,,0,0,0,,C同样也向其他所有人重广播此条消息\NC will also rebroadcast the message to everyone else.
Dialogue: 0,0:02:23.76,0:02:27.76,Default,,0,0,0,,此算法确实能保证可靠性\NAnd so, this algorithm actually does ensure reliability.
Dialogue: 0,0:02:27.76,0:02:33.66,Default,,0,0,0,,此算法可以保证 即使有节点崩溃 所有未崩溃节点仍然可以收到消息\NIt ensures that even if nodes crash, all of the non-crashed nodes receive the message.
Dialogue: 0,0:02:34.60,0:02:40.04,Default,,0,0,0,,然而 这个算法的开销极大 因为每个收到消息的节点\NHowever, it is quite expensive, because every node that receives a message
Dialogue: 0,0:02:40.04,0:02:44.52,Default,,0,0,0,,都将再次将此条消息发送给其他n-1个节点\Nwill again send that message to n-1 other nodes.
Dialogue: 0,0:02:44.52,0:02:50.56,Default,,0,0,0,,总的来说 每当一个节点想要广播一条消息时\NAnd so, in total, we're going to end up with O(n^2) messages being sent
Dialogue: 0,0:02:51.18,0:02:54.52,Default,,0,0,0,,此协议最终都需要发送O(n^2)条消息\Nfor every single message that a node wants to broadcast.
Dialogue: 0,0:02:54.52,0:02:59.56,Default,,0,0,0,,我们得到了可靠性 但代价是消耗了相当高的网络带宽\NSo, we get reliability, but at the cost of fairly high network bandwidth.
Dialogue: 0,0:02:59.56,0:03:04.10,Default,,0,0,0,,为此 人们设计了很多不同的优化算法\NNow, lots of different algorithms have been designed to optimize this.
Dialogue: 0,0:03:04.10,0:03:09.42,Default,,0,0,0,,一组特别有趣的算法叫流言协议\NAnd one particular interesting group of algorithms are called gossip protocols.
Dialogue: 0,0:03:09.42,0:03:15.96,Default,,0,0,0,,此类协议模仿了流言在人际网络中的传播方式\NSo, they are modeled in the way how gossip might spread through a network of people,
Dialogue: 0,0:03:15.96,0:03:18.52,Default,,0,0,0,,一个人从别人那里听到流言蜚语\Nwhere one person hears gossip from somebody,
Dialogue: 0,0:03:18.52,0:03:20.92,Default,,0,0,0,,他们把这些流言告诉了其他人\Nand they then tell a few other people about this gossip,
Dialogue: 0,0:03:20.92,0:03:22.06,Default,,0,0,0,,最终\Nand so eventually,
Dialogue: 0,0:03:22.06,0:03:26.96,Default,,0,0,0,,流言在群组/群体中完成了传播\Nthis information spreads through a group, through a population of people.
Dialogue: 0,0:03:27.36,0:03:29.54,Default,,0,0,0,,有时也把这类协议称为传染病协议\NAnd they're sometimes also called epidemic protocols,
Dialogue: 0,0:03:29.54,0:03:32.08,Default,,0,0,0,,因为此类协议的消息传播方式\Nbecause they're somewhat similar to the way that
Dialogue: 0,0:03:32.08,0:03:35.62,Default,,0,0,0,,与传染病在人群中的传播方式很相似\Nan infectious disease might spread through a population.
Dialogue: 0,0:03:35.62,0:03:41.68,Default,,0,0,0,,在这个例子中 每一个小黑点都代表系统中的一个节点\NAnd so, in this example here each little blob is a node in the system.
Dialogue: 0,0:03:41.68,0:03:45.88,Default,,0,0,0,,我们已经为算法选择好了参数\NAnd I've just taken as the parameter for this algorithm that
Dialogue: 0,0:03:45.88,0:03:49.98,Default,,0,0,0,,每个节点会向其他3个节点发送消息\Neach node sends on the message to 3 other nodes.
Dialogue: 0,0:03:49.98,0:03:52.48,Default,,0,0,0,,这3个节点是随机选取的\NAnd those 3 other nodes are picked at random.
Dialogue: 0,0:03:52.48,0:03:56.18,Default,,0,0,0,,因此 这里的红色节点将消息发送给其他3个节点\NAnd so, here, the red node is sending the message to 3 other nodes.
Dialogue: 0,0:03:56.18,0:03:59.18,Default,,0,0,0,,这3个节点收到消息后\NAnd then, these 3 other nodes each receive the message
Dialogue: 0,0:03:59.18,0:04:04.42,Default,,0,0,0,,再随机选择3个节点 并将消息重广播给这3个节点\Nand they each rebroadcast the message to 3 other randomly selected nodes.
Dialogue: 0,0:04:04.42,0:04:10.50,Default,,0,0,0,,收到广播消息的接收方再将消息广播给其他节点\NAnd those recipients of those broadcasts, they again broadcast them further to others.
Dialogue: 0,0:04:10.50,0:04:11.24,Default,,0,0,0,,你可以看到\NAnd you see that
Dialogue: 0,0:04:11.24,0:04:15.90,Default,,0,0,0,,消息有时会被发送给之前已经接收过消息的节点\Nsometimes, messages go to a node that has already received a message previously.
Dialogue: 0,0:04:15.90,0:04:18.02,Default,,0,0,0,,消息有时甚至会回传给\NSometimes, messages even go back to a node
Dialogue: 0,0:04:18.02,0:04:20.42,Default,,0,0,0,,过去某个时间拥有该消息的节点\Nthat had the message sometime in the past.
Dialogue: 0,0:04:20.42,0:04:23.38,Default,,0,0,0,,但最终 此协议执行几轮之后\NBut eventually, over several rounds of this protocol,
Dialogue: 0,0:04:23.84,0:04:27.32,Default,,0,0,0,,有很高的概率\Nthere with very high probability, we reach a stage
Dialogue: 0,0:04:27.32,0:04:30.30,Default,,0,0,0,,能使所有节点都收到了消息\Nin which the message has received all of the nodes,
Dialogue: 0,0:04:30.30,0:04:32.56,Default,,0,0,0,,所有节点都变成了黑色\Nand now all of the nodes are black.
Dialogue: 0,0:04:32.56,0:04:35.26,Default,,0,0,0,,我们再来看一遍这个动画 这个动画做得太漂亮了\NLet me just go through that animation again because it's so beautiful.
Dialogue: 0,0:04:35.26,0:04:39.06,Default,,0,0,0,,我们可以看到 消息在节点中不断传播\NSo, we have the node spreading. There is the message spreading here.
Dialogue: 0,0:04:39.06,0:04:40.88,Default,,0,0,0,,此时\NAnd so, in this case,
Dialogue: 0,0:04:40.88,0:04:43.94,Default,,0,0,0,,在本例中 经过6轮通信\Nall 30 nodes in this example have received the message
Dialogue: 0,0:04:43.94,0:04:47.30,Default,,0,0,0,,所有30个节点都收到了消息\Nafter about 6 rounds of communication.
Dialogue: 0,0:04:47.30,0:04:52.04,Default,,0,0,0,,我们可以调整流言协议中的很多参数\NSo, there are lots of details that you can tune about gossip protocols
Dialogue: 0,0:04:52.04,0:04:54.04,Default,,0,0,0,,例如 节点如何决定\Nabout how exactly they decide
Dialogue: 0,0:04:54.04,0:04:58.18,Default,,0,0,0,,什么时候发送消息、什么时候停止发送消息\Nwhen to send messages and when to stop sending messages and so on.
Dialogue: 0,0:04:58.18,0:05:00.00,Default,,0,0,0,,但协议的基本原理就是这样\NBut the basic principle is this.
Dialogue: 0,0:05:00.00,0:05:02.92,Default,,0,0,0,,这是可靠广播的一种实现方法\NThey are a way of achieving reliable broadcasts.
Dialogue: 0,0:05:02.92,0:05:04.20,Default,,0,0,0,,此方法非常健壮\NAnd they are quite robust
Dialogue: 0,0:05:04.20,0:05:08.68,Default,,0,0,0,,即使部分节点崩溃 部分消息在网络传输中丢失\Nso that even if some of the nodes crash or some of the messages get lost in the network,
Dialogue: 0,0:05:08.68,0:05:11.00,Default,,0,0,0,,我们也有很高的概率\Nwe still have very high probability that
Dialogue: 0,0:05:11.00,0:05:14.22,Default,,0,0,0,,使所有节点均成功收到消息\Nall of the messages get through to all of the nodes.
Dialogue: 0,0:05:14.22,0:05:16.72,Default,,0,0,0,,我们现在得到了可靠性\NOK, so, that gives us the reliability.
Dialogue: 0,0:05:16.72,0:05:19.32,Default,,0,0,0,,接下来 我们考虑传递顺序\NNow, next let's look at the ordering.
Dialogue: 0,0:05:19.32,0:05:22.60,Default,,0,0,0,,例如 如果我们想获得FIFO广播\NSo, if we want to achieve FIFO broadcasts, for example,
Dialogue: 0,0:05:22.60,0:05:24.26,Default,,0,0,0,,这意味着我们必须保证\Nthat means we have to ensure that
Dialogue: 0,0:05:24.26,0:05:27.82,Default,,0,0,0,,相同发送方发送的所有消息均要按照正确的顺序传递\Nall of the messages by the same sender are delivered in the right order.
Dialogue: 0,0:05:27.82,0:05:30.74,Default,,0,0,0,,这是一个实现此顺序传递的算法\NThis is an algorithm of how we might achieve this.
Dialogue: 0,0:05:30.74,0:05:34.32,Default,,0,0,0,,每个节点要维护三个变量\NSo, each node here maintains three variables,
Dialogue: 0,0:05:34.32,0:05:37.04,Default,,0,0,0,,发送方顺序号（sendSeq）是一个整数\Nsender sequence number (sendSeq) is just an integer
Dialogue: 0,0:05:37.04,0:05:41.88,Default,,0,0,0,,每当此节点广播一条消息时 此顺序号会递增\Nthat gets incremented for every message broadcast by this particular node,
Dialogue: 0,0:05:41.88,0:05:44.56,Default,,0,0,0,,已传递（delivered）是一个整数向量\Ndelivered is a vector of integers
Dialogue: 0,0:05:44.56,0:05:49.08,Default,,0,0,0,,表示我们已经传递了来自每个特定发送方的消息数量\Nindicating how many messages from each particular sender we have delivered,
Dialogue: 0,0:05:49.08,0:05:54.20,Default,,0,0,0,,缓冲区（buffer）是消息保留队列\Nand buffer is a holdback queue of messages so that
Dialogue: 0,0:05:54.20,0:05:57.16,Default,,0,0,0,,如果一条消息未准备好被传递 我们就将此消息放在缓冲区中\Nif a message is not yet ready to be delivered, we put it in the buffer,
Dialogue: 0,0:05:57.16,0:05:59.56,Default,,0,0,0,,后续某个时刻再从缓冲区中取出这条消息\Nand then pick it out of the buffer sometime later.
Dialogue: 0,0:05:59.56,0:06:01.66,Default,,0,0,0,,如果我们想广播一条消息\NSo, if we want to broadcast a message,
Dialogue: 0,0:06:01.66,0:06:09.04,Default,,0,0,0,,我们在消息上附加发送方i的节点号\Nwe attached the node number of the sender i,
Dialogue: 0,0:06:09.04,0:06:15.40,Default,,0,0,0,,再在消息上附加发送方顺序号\Nand we attach the sequence number of the sender to the message,
Dialogue: 0,0:06:15.40,0:06:19.96,Default,,0,0,0,,通过可靠广播将此三元组传播给所有节点\Nand this triple gets disseminated to all of the nodes via reliable broadcast.
Dialogue: 0,0:06:19.96,0:06:24.10,Default,,0,0,0,,随后 我们将递增发送方顺序号 为下一次广播做准备\NAnd then, we increment the sequence number for next time we want to broadcast.
Dialogue: 0,0:06:24.10,0:06:30.28,Default,,0,0,0,,当节点N_i通过可靠网络收到一条消息时\NAlso, when we receive a message via a reliable broadcast at node N_i,
Dialogue: 0,0:06:30.28,0:06:32.60,Default,,0,0,0,,我们首先将消息放置到缓冲区\Nwe first of all add the message to the buffer,
Dialogue: 0,0:06:32.60,0:06:37.28,Default,,0,0,0,,随后 我们查看缓冲区 尝试获取已经准备好传递的所有消息\Nand then, we look at the buffer trying to find any messages that are ready to be delivered.
Dialogue: 0,0:06:37.28,0:06:40.46,Default,,0,0,0,,这里的“准备好传递”是指\NAnd here, ready to be delivered means that
Dialogue: 0,0:06:40.46,0:06:46.00,Default,,0,0,0,,对于任意给定发送方 我们能在缓冲区找到一条消息\Nfor any given sender, we have a message in the buffer
Dialogue: 0,0:06:46.00,0:06:50.80,Default,,0,0,0,,此消息的顺序号刚好等于\Nwhere the sequence number is the next integer that we are expecting
Dialogue: 0,0:06:50.80,0:06:54.00,Default,,0,0,0,,此特定发送方广播消息所拥有的下一个顺序号\Nin the sequence of sequence number from that particular sender.
Dialogue: 0,0:06:54.00,0:06:56.54,Default,,0,0,0,,如果有一条消息与我们期望的顺序号相匹配\NAnd so, if we have a message matching that,
Dialogue: 0,0:06:56.54,0:06:59.24,Default,,0,0,0,,我们就把这条消息取出来 传递给应用\Nthen we take that message, deliver it to the application,
Dialogue: 0,0:06:59.24,0:07:04.38,Default,,0,0,0,,随后 我们找到表示各发送方已传递消息数量的本地向量\Nand we increment our local vector of the number of messages we have delivered
Dialogue: 0,0:07:04.38,0:07:05.94,Default,,0,0,0,,增加此特定发送方对应位置的计数值\Nfrom a particular sender.
Dialogue: 0,0:07:05.94,0:07:09.60,Default,,0,0,0,,这个协议可以让我们得到FIFO广播\NAnd so, this is it. This achieves FIFO broadcast.
Dialogue: 0,0:07:09.60,0:07:12.44,Default,,0,0,0,,接下来 我们来看看因果关系广播\NNext, let's have a look at causal broadcast.
Dialogue: 0,0:07:12.44,0:07:15.36,Default,,0,0,0,,算法结构非常相似\NThe structure of the algorithm is very similar.
Dialogue: 0,0:07:15.36,0:07:17.28,Default,,0,0,0,,我们仍然从3个变量开始\NWe start with the same 3 variables.
Dialogue: 0,0:07:17.28,0:07:19.04,Default,,0,0,0,,同样地 我们有发送方顺序号（sendSeq）\NSo, again, we have a sender sequence number (sendSeq),
Dialogue: 0,0:07:19.04,0:07:22.28,Default,,0,0,0,,我们有一个记录已传递消息数量的向量（delivered）\Nwe have a vector counting the number of delivered messages (delivered),
Dialogue: 0,0:07:22.28,0:07:24.90,Default,,0,0,0,,我们有保留缓冲区（buffer）\Nand we have the holdback buffer (buffer).
Dialogue: 0,0:07:24.90,0:07:28.32,Default,,0,0,0,,当N_i想广播一条消息时\NWhen we want to broadcast a message at N_i,
Dialogue: 0,0:07:28.32,0:07:31.94,Default,,0,0,0,,首先 我们创建一个名为“依赖”（deps）的新变量\Nfirst of all, we create this new variable deps.
Dialogue: 0,0:07:31.94,0:07:35.22,Default,,0,0,0,,此变量描述了消息的因果依赖关系\NSo, that captures the causal dependencies of this message.
Dialogue: 0,0:07:35.22,0:07:40.72,Default,,0,0,0,,我们用这个变量决定哪条消息在这条消息之前发生\NSo, it's a way of determining which messages happened before this particular message.
Dialogue: 0,0:07:40.72,0:07:42.34,Default,,0,0,0,,在广播这条消息之前\NAnd those will have to be then
Dialogue: 0,0:07:42.34,0:07:46.66,Default,,0,0,0,,所有之前发生的消息都需要先完成传递\Nall of the messages that have to be delivered before this message being broadcast.
Dialogue: 0,0:07:46.66,0:07:50.70,Default,,0,0,0,,我们将已传递消息数量向量拷贝到deps中\NSo, we take deps to be a copy of our delivered vector.
Dialogue: 0,0:07:50.70,0:07:58.64,Default,,0,0,0,,我们将deps中广播节点所对应位置的元素更新为发送方顺序号\NAnd we update the broadcasting node's own entry to be equal to the sendSeq.
Dialogue: 0,0:07:58.64,0:08:01.98,Default,,0,0,0,,随后 我们仍然通过可靠广播发送此条消息\NAnd then, we send the message via reliable broadcast again.
Dialogue: 0,0:08:01.98,0:08:04.24,Default,,0,0,0,,此时 我们不在消息上附加顺序号了\NThis time, we don't attach the sequence number,
Dialogue: 0,0:08:04.24,0:08:10.64,Default,,0,0,0,,我们附加这个依赖向量 以及表示节点索引值的i\Nbut we attach this dependencies vector, in addition to i, which is the index of the node.
Dialogue: 0,0:08:10.64,0:08:13.32,Default,,0,0,0,,随后 我们和之前一样 递增发送方顺序号\NAnd then, we increment the sender sequence number as before.
Dialogue: 0,0:08:13.32,0:08:15.06,Default,,0,0,0,,此时 我们在得到的消息上\NOK, so, this time, we've got messages
Dialogue: 0,0:08:15.06,0:08:19.72,Default,,0,0,0,,附加了一个向量 而不是一个单独的整数了\Nthat have a vector attached to them, rather than a single integer.
Dialogue: 0,0:08:19.72,0:08:23.18,Default,,0,0,0,,当一个节点收到其中一条消息时\NWhen one of these messages gets delivered at a node,
Dialogue: 0,0:08:23.18,0:08:26.88,Default,,0,0,0,,我们首先和之前一样 将消息放置在缓冲区中\Nwe first of all put the message in the buffer as usual.
Dialogue: 0,0:08:26.88,0:08:30.68,Default,,0,0,0,,现在 我们搜索准备好传递的消息\NAnd now, we search for any messages that are ready to be delivered.
Dialogue: 0,0:08:30.68,0:08:35.90,Default,,0,0,0,,即搜索所有满足因果依赖关系的消息\NAnd these are any messages whose causal dependencies have been satisfied.
Dialogue: 0,0:08:35.90,0:08:39.66,Default,,0,0,0,,对于所有与当前消息存在因果关系的广播消息\NSo, any messages that were broadcast before the current message,
Dialogue: 0,0:08:39.66,0:08:44.52,Default,,0,0,0,,本地节点都需要先完成传递\Nthey have already been delivered by the local node.
Dialogue: 0,0:08:44.52,0:08:48.74,Default,,0,0,0,,如果一个消息满足上述条件 则此条消息已经准备好被传递了\NIf those have been delivered, then this message is ready to be delivered
Dialogue: 0,0:08:48.74,0:08:51.52,Default,,0,0,0,,因为所有满足因果依赖关系的消息都已经被传递了\Nbecause its causal dependencies have already been delivered.
Dialogue: 0,0:08:51.52,0:08:56.42,Default,,0,0,0,,我们在缓冲区中遍历所有消息的依赖向量\NSo, here we search for any sender dependencies and message in the buffer
Dialogue: 0,0:08:56.42,0:09:01.46,Default,,0,0,0,,找到依赖向量小于等于当前依赖向量的消息\Nsuch that the dependencies vector is less than or equal to the delivered vector.
Dialogue: 0,0:09:01.46,0:09:04.50,Default,,0,0,0,,这里的≤操作符\NAnd this ≤ operator
Dialogue: 0,0:09:04.50,0:09:10.84,Default,,0,0,0,,就是我们稍早前在向量时钟里定义的≤操作符\Nis exactly the ≤ operator that we defined on vector clocks a little while back.
Dialogue: 0,0:09:10.84,0:09:16.02,Default,,0,0,0,,虽然这个算法与向量时钟算法不完全一样\NSo, even though this algorithm is not exactly the same as the vector clocks algorithm,
Dialogue: 0,0:09:16.02,0:09:20.22,Default,,0,0,0,,但此算法中的整数向量使用方法和向量时钟里的用法很相似\Nit's similar in the way that it does use these vectors of numbers,
Dialogue: 0,0:09:20.22,0:09:27.46,Default,,0,0,0,,这个算法也使用≤操作符来比较依赖向量 从而实现因果关系广播\Nand it uses this ≤ comparison as a part of its algorithm for causal broadcast.
Dialogue: 0,0:09:27.46,0:09:31.12,Default,,0,0,0,,如果我们找到了满足因果依赖关系的消息 我们就传递这条消息\NIf we have a message that satisfies the dependencies, we deliver it,
Dialogue: 0,0:09:31.12,0:09:32.80,Default,,0,0,0,,我们从缓冲区移除这条消息\Nwe remove the message from the buffer,
Dialogue: 0,0:09:32.80,0:09:37.48,Default,,0,0,0,,我们增加此特定发送方的已传递消息数量\Nand we increment the number of messages we have delivered from that particular sender.
Dialogue: 0,0:09:37.48,0:09:39.86,Default,,0,0,0,,此算法可以实现因果关系广播\NAnd this ensures causal broadcast.
Dialogue: 0,0:09:39.86,0:09:42.18,Default,,0,0,0,,你可能需要花点时间想一想\NYou might have to think about the algorithm for a little bit
Dialogue: 0,0:09:42.18,0:09:44.90,Default,,0,0,0,,让自己信服这个算法是正确的\Nto convince yourself that it really is correct,
Dialogue: 0,0:09:44.90,0:09:47.60,Default,,0,0,0,,但我认为这个算法确实是正确的\Nbut I think it is correct.
Dialogue: 0,0:09:47.60,0:09:49.64,Default,,0,0,0,,这就是因果关系广播\NSo, that is causal broadcast.
Dialogue: 0,0:09:49.64,0:09:52.44,Default,,0,0,0,,最后是全序关系广播\NFinally, total order broadcast.
Dialogue: 0,0:09:52.44,0:09:56.92,Default,,0,0,0,,全序关系广播有一点难\NSo, total order broadcast is a bit harder, so, because remember,
Dialogue: 0,0:09:56.92,0:10:01.18,Default,,0,0,0,,我们需要协商消息的全序关系\Nwe have to somehow agree on what this total order is of messages
Dialogue: 0,0:10:01.18,0:10:04.46,Default,,0,0,0,,这样才能确定消息的传递顺序\Nin which order the messages are going to get delivered.
Dialogue: 0,0:10:04.46,0:10:06.40,Default,,0,0,0,,我们来看一个简单实现此目的的算法\NLet's say one simple way of doing this.
Dialogue: 0,0:10:06.40,0:10:09.50,Default,,0,0,0,,我们把其中一个节点选为主节点\NWe're going to pick one of the nodes as the leader.
Dialogue: 0,0:10:09.50,0:10:11.66,Default,,0,0,0,,主节点将负责\NAnd this leader is going to be in charge of
Dialogue: 0,0:10:11.66,0:10:14.94,Default,,0,0,0,,决定消息传递的顺序\Ndetermining the order in which the messages get delivered.
Dialogue: 0,0:10:15.36,0:10:17.60,Default,,0,0,0,,这也是有时会把主节点称为定序节点的原因\NSo, that's why it's also sometimes known as a sequencer,
Dialogue: 0,0:10:17.60,0:10:19.96,Default,,0,0,0,,因为此节点会决定消息的顺序\Nbecause it sequences the messages.
Dialogue: 0,0:10:19.96,0:10:23.34,Default,,0,0,0,,如果一个节点想要广播一条消息\NAnd if one node wants to broadcast a message,
Dialogue: 0,0:10:23.34,0:10:25.90,Default,,0,0,0,,它并不直接向其他节点广播这条消息\Nit doesn't directly broadcast it to the other nodes.
Dialogue: 0,0:10:25.90,0:10:31.76,Default,,0,0,0,,此节点需要通过FIFO链路向主节点发送此条消息\NInstead, the node sends it to the leader via a FIFO link probably.
Dialogue: 0,0:10:31.76,0:10:36.14,Default,,0,0,0,,主节点随后通过FIFO广播向全组广播此条消息\NAnd the leader then broadcast it by a FIFO broadcast to the entire group.
Dialogue: 0,0:10:36.14,0:10:40.60,Default,,0,0,0,,由于所有的消息都会由主节点发送\NAnd so, because all of the messages are going through the leader,
Dialogue: 0,0:10:40.60,0:10:44.40,Default,,0,0,0,,因此 主节点广播消息的顺序\Nsimply the order in which the leader broadcasts the messages then
Dialogue: 0,0:10:44.88,0:10:48.42,Default,,0,0,0,,就是其他所有节点传递消息的顺序\Nis the order in which all of the other nodes will deliver the messages,
Dialogue: 0,0:10:48.42,0:10:51.12,Default,,0,0,0,,这是因为主节点会使用FIFO广播来发送消息\Nsince we're talking about FIFO broadcast here.
Dialogue: 0,0:10:51.12,0:10:53.40,Default,,0,0,0,,这个协议效果良好\NAnd this works quite nicely.
Dialogue: 0,0:10:53.40,0:10:54.64,Default,,0,0,0,,只存在一个问题\NIt just has the problem that
Dialogue: 0,0:10:54.64,0:10:58.34,Default,,0,0,0,,如果主节点崩溃了 广播机制就无法再传递任何消息\Nif our leader crashes, then no more messages can get delivered,
Dialogue: 0,0:10:58.34,0:11:01.56,Default,,0,0,0,,因为我们要求所有消息都通过主节点发送\Nbecause we're requiring all of our messages to go through the leader.
Dialogue: 0,0:11:01.56,0:11:03.60,Default,,0,0,0,,因此 我们需要一种方法\NSo, really, we would need some kind of way of
Dialogue: 0,0:11:03.60,0:11:07.84,Default,,0,0,0,,将主节点从一个节点换为另一个节点 以防止主节点崩溃\Nchanging the leader from one node to another in case that leader crashes.
Dialogue: 0,0:11:07.84,0:11:10.02,Default,,0,0,0,,但安全的实现这一点是很困难的\NBut this is quite difficult to do safely,
Dialogue: 0,0:11:10.02,0:11:12.70,Default,,0,0,0,,因为如果系统最后产生了两个不同的主节点\Nbecause if you end up with two different leaders,
Dialogue: 0,0:11:12.70,0:11:15.28,Default,,0,0,0,,我们就无法保证消息的全序关系了\Nthen your guarantee of total order is gone.
Dialogue: 0,0:11:15.28,0:11:20.00,Default,,0,0,0,,我们后续介绍共识协议时\NSo, we will see ways of actually doing this kind of leader change safely
Dialogue: 0,0:11:20.00,0:11:23.28,Default,,0,0,0,,再介绍安全更换主节点的方法\Nin a later lecture when we'd come to talk about consensus.
Dialogue: 0,0:11:23.28,0:11:26.12,Default,,0,0,0,,现在 我们把这个问题留作一个公开问题\NBut for now, I'm just going to leave this as an open problem.
Dialogue: 0,0:11:26.12,0:11:29.42,Default,,0,0,0,,还有一种实现全序关系广播的方法\NThere's another way you could achieve total order broadcast,
Dialogue: 0,0:11:29.42,0:11:31.50,Default,,0,0,0,,此方法不需要依赖主节点\Nwhich does not rely on a leader.
Dialogue: 0,0:11:31.50,0:11:34.20,Default,,0,0,0,,你需要依赖的是Lamport时钟\NInstead, you could rely on Lamport clocks.
Dialogue: 0,0:11:34.20,0:11:38.62,Default,,0,0,0,,回忆一下 Lamport时钟生成了一个全序关系\NSo, remember, Lamport timestamps have an associated total order.
Dialogue: 0,0:11:38.62,0:11:40.32,Default,,0,0,0,,我们可以把这个全序关系\NAnd we can use that total order
Dialogue: 0,0:11:40.32,0:11:43.06,Default,,0,0,0,,作为传递消息的顺序\Nas the order in which we are going to deliver the messages.
Dialogue: 0,0:11:43.06,0:11:45.60,Default,,0,0,0,,我们在每条消息上附加一个Lamport时间戳\NSo, we attach a Lamport timestamp to every message.
Dialogue: 0,0:11:45.60,0:11:49.54,Default,,0,0,0,,我们按照前面讨论的方法创建Lamport时间戳\NWe create those Lamport timestamps in the usual way like we have discussed,
Dialogue: 0,0:11:49.54,0:11:54.54,Default,,0,0,0,,随后 通过可靠广播来广播消息\Nand then, broadcast those messages via some kind of reliable broadcast.
Dialogue: 0,0:11:54.54,0:11:56.84,Default,,0,0,0,,接下来 每个节点都需要保证\NAnd then, each node needs to ensure that
Dialogue: 0,0:11:56.84,0:12:01.40,Default,,0,0,0,,节点按照Lamport时间戳递增的顺序传递消息\Nit delivers messages in increasing order of their Lamport timestamps.
Dialogue: 0,0:12:01.40,0:12:07.44,Default,,0,0,0,,这是可行的 但是这个算法依赖一个特定的知识\NAnd this works, but it does rely on one particular piece of knowledge
Dialogue: 0,0:12:07.44,0:12:13.98,Default,,0,0,0,,当节点传递一条消息时 它需要确定\Nwhich is at the time when a node delivers a message, it needs to be sure that
Dialogue: 0,0:12:13.98,0:12:17.90,Default,,0,0,0,,后续所有消息的Lamport时间戳\Nthere will be no future messages with a Lamport timestamp
Dialogue: 0,0:12:17.90,0:12:21.56,Default,,0,0,0,,不会小于其将要传递消息所关联的时间戳\Nless than this message that it's about to deliver,
Dialogue: 0,0:12:21.56,0:12:24.98,Default,,0,0,0,,因为如果此节点传递了此条消息\Nbecause if it did deliver the message now,
Dialogue: 0,0:12:24.98,0:12:27.72,Default,,0,0,0,,随后 节点收到了一条时间戳更小的消息\Nand then later, a message with a lower timestamp arrives,
Dialogue: 0,0:12:27.72,0:12:29.58,Default,,0,0,0,,这就意味着此节点按照错误的顺序传递了消息\Nthen it would have delivered them in the wrong order,
Dialogue: 0,0:12:29.58,0:12:35.16,Default,,0,0,0,,因为每个节点都必须严格按照Lamport时间戳递增的顺序传递消息\Nbecause it has to deliver the messages in strictly ascending order of Lamport timestamp.
Dialogue: 0,0:12:35.16,0:12:37.80,Default,,0,0,0,,因此 我们需要通过一种方法知道\NSo, therefore, we need some way of knowing that
Dialogue: 0,0:12:37.80,0:12:40.24,Default,,0,0,0,,后续消息的时间戳\Nthere will not be any future messages
Dialogue: 0,0:12:40.24,0:12:43.84,Default,,0,0,0,,不会小于某个特定的阈值\Nwith a timestamp less than some particular threshold.
Dialogue: 0,0:12:43.84,0:12:45.74,Default,,0,0,0,,这是有可能做到的\NAnd it is possible to know that,
Dialogue: 0,0:12:45.74,0:12:51.20,Default,,0,0,0,,因为如果节点之间通过FIFO链路通信 那么我们实际上知道\Nbecause if we use FIFO links between the nodes, then actually, we know that
Dialogue: 0,0:12:51.20,0:12:55.60,Default,,0,0,0,,每个节点会按照Lamport时间戳递增的顺序发送消息\Neach node will send messages in increasing order of Lamport timestamp,
Dialogue: 0,0:12:55.60,0:12:57.92,Default,,0,0,0,,我们也会按照递增顺序收到这些消息\Nand we receive those messages in increasing order.
Dialogue: 0,0:12:57.92,0:13:00.98,Default,,0,0,0,,因此 如果我们能收到所有其他节点的消息\NSo, therefore, if we've heard from every other node,
Dialogue: 0,0:13:00.98,0:13:03.14,Default,,0,0,0,,那么我们就能知道\Nthen we know that the minimum timestamp
Dialogue: 0,0:13:03.14,0:13:05.16,Default,,0,0,0,,其他所有节点发送消息的最小时间戳\Nthat we've seen across any of the other nodes
Dialogue: 0,0:13:05.16,0:13:07.40,Default,,0,0,0,,就是我们能得到的最小时间戳\Nis going to be the minimum we're ever going to see.
Dialogue: 0,0:13:07.40,0:13:10.90,Default,,0,0,0,,后续不可能收到此时间戳更小的时间戳了\NSo, there will never be any later timestamps than this one.
Dialogue: 0,0:13:10.90,0:13:16.66,Default,,0,0,0,,基于此方法 我们就有可能构建出全序关系广播\NAnd so, based on that, it is now possible to again create total order broadcast.
Dialogue: 0,0:13:16.66,0:13:20.78,Default,,0,0,0,,不幸的是 此方法同样无法容错\NAgain, unfortunately, this approach is not fault-tolerant,
Dialogue: 0,0:13:20.78,0:13:22.12,Default,,0,0,0,,因为在这种情况下\Nbecause in this case,
Dialogue: 0,0:13:22.12,0:13:25.98,Default,,0,0,0,,如果其中一个节点崩溃 这个节点就不会再发送任何消息\Nif just one of the nodes crashes, it will not be sending any more messages.
Dialogue: 0,0:13:25.98,0:13:28.74,Default,,0,0,0,,Lamport时间戳也就不会再向前移动\NSo, the Lamport timestamps won't be moving forward anymore.
Dialogue: 0,0:13:28.74,0:13:31.28,Default,,0,0,0,,因此 节点也不会再传递任何消息\NAnd so, no messages get delivered anymore.
Dialogue: 0,0:13:31.28,0:13:36.12,Default,,0,0,0,,这两个算法都可以运行 但两个算法都无法容错\NSo, these two algorithms do work, but neither of them is fault-tolerant.
Dialogue: 0,0:13:36.12,0:13:38.16,Default,,0,0,0,,在后面的课程中\NAnd in a later lecture,
Dialogue: 0,0:13:38.16,0:13:43.68,Default,,0,0,0,,我们将学习如何实现可容错的全序广播\Nwe will see ways of achieving total order broadcast in a way that is fault-tolerant.
