[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 4.2_Broadcast ordering.mp4
Video File: 4.2_Broadcast ordering.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 42
Active Line: 48
Video Position: 5658

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.76,0:00:04.68,Default,,0,0,0,,我们接下来学习广播协议\NNext, we are going to look at broadcast protocols.
Dialogue: 0,0:00:04.68,0:00:08.20,Default,,0,0,0,,从逻辑时间直接调到了具体协议 这似乎有些突然\NThis might seem like a bit of a sudden jump from logical time.
Dialogue: 0,0:00:08.20,0:00:12.60,Default,,0,0,0,,但我们随后就会看到 广播协议和逻辑时间实际上有很强的关联性\NBut actually, as we will see in a moment, there's a strong connection between the two.
Dialogue: 0,0:00:12.60,0:00:17.18,Default,,0,0,0,,广播协议扩展了我们在分布式系统中\NSo, broadcast protocols generalize the type of network communication
Dialogue: 0,0:00:17.18,0:00:19.40,Default,,0,0,0,,支持的网络通信类型\Nthat we can do in a distributed system.
Dialogue: 0,0:00:19.40,0:00:23.56,Default,,0,0,0,,之前 我们主要考察的是点对点通信\NSo, so far, we've been considering point-to-point communication
Dialogue: 0,0:00:23.56,0:00:28.02,Default,,0,0,0,,一个发送方通过网络将消息发送给一个接收方\Nwhere one sender sends a message to one recipient over the network.
Dialogue: 0,0:00:28.02,0:00:29.68,Default,,0,0,0,,消息可能会被送达 也可能未被送达\NThe message may or may not arrive,
Dialogue: 0,0:00:29.68,0:00:32.84,Default,,0,0,0,,但这仍然是两个节点之间的点对点通信\Nbut it's still one-to-one communication between two nodes.
Dialogue: 0,0:00:32.84,0:00:39.30,Default,,0,0,0,,在广播或组播通信中 我们将通信类型扩展到节点群组\NIn broadcast or multicast communication, we generalize this to a group of nodes
Dialogue: 0,0:00:39.30,0:00:44.06,Default,,0,0,0,,一个节点可以同时向群组中的所有其他节点发送一条消息\Nso that one node may send a message to all of the nodes in the group at the same time.
Dialogue: 0,0:00:44.06,0:00:48.52,Default,,0,0,0,,出于本课程的教学目的 我们总会假设\NNow, for the purpose of this course, we're mostly going to assume that
Dialogue: 0,0:00:48.52,0:00:52.96,Default,,0,0,0,,群组中包含的节点集合是固定的、预先已知的\Nthe set of nodes in the group is fixed and known in advance.
Dialogue: 0,0:00:52.96,0:00:56.04,Default,,0,0,0,,但一般来说 实际应用的系统中\NBut in general, you may well, of course, have a system
Dialogue: 0,0:00:56.04,0:01:01.04,Default,,0,0,0,,节点可以动态加入或离开 或者被管理员添加或移除\Nin which nodes can join and leave or be added or removed by an administrator.
Dialogue: 0,0:01:01.46,0:01:05.36,Default,,0,0,0,,真实协议显然需要处理这类情况\NAnd that is certainly something that real protocols need to deal with.
Dialogue: 0,0:01:05.36,0:01:10.82,Default,,0,0,0,,我们特别希望广播协议满足容错性\NSo, one particular thing that we want of a broadcast protocol is fault tolerance.
Dialogue: 0,0:01:10.82,0:01:15.10,Default,,0,0,0,,也就是说 当群组中的一个节点出现故障时\NAnd this means that, say, one of the nodes in the group is faulty,
Dialogue: 0,0:01:15.10,0:01:16.54,Default,,0,0,0,,剩余的所有节点\Nall of the remaining nodes
Dialogue: 0,0:01:16.54,0:01:21.22,Default,,0,0,0,,应该仍然可以继续广播和传递消息\Nshould still be able to continue broadcasting and delivering messages as before.
Dialogue: 0,0:01:21.22,0:01:27.50,Default,,0,0,0,,我们不希望单节点故障就会让整个系统逐渐中止\NSo, we don't want a single faulty node to make the entire system grind to a halt.
Dialogue: 0,0:01:27.50,0:01:32.56,Default,,0,0,0,,有几种不同的广播或组播实现方式\NThere are a couple of different implementations of broadcast or multicast.
Dialogue: 0,0:01:32.56,0:01:37.36,Default,,0,0,0,,在计算机网络中 大家可能遇到过一种广播机制\NOne that you might have come across in the context of computer networking is that
Dialogue: 0,0:01:37.36,0:01:43.66,Default,,0,0,0,,一些局域网实际上在硬件层支持广播或组播\Nsome local area networks support broadcast or multicast at the hardware level actually.
Dialogue: 0,0:01:43.66,0:01:47.52,Default,,0,0,0,,这在局域网中非常有用\NAnd this is quite useful on local area networks.
Dialogue: 0,0:01:47.52,0:01:51.82,Default,,0,0,0,,一般来说 局域网的组播机制无法在公开互联网上工作\NGenerally, that kind of multicast does not work over the public Internet.
Dialogue: 0,0:01:51.82,0:01:54.50,Default,,0,0,0,,我们在本课程中\NAnd so, what we will consider in this course
Dialogue: 0,0:01:54.50,0:01:57.98,Default,,0,0,0,,考虑的是更一般形式的广播或组播\Nis more general form of multicast or broadcast
Dialogue: 0,0:01:57.98,0:01:59.56,Default,,0,0,0,,我们假设\Nwhere we assume that
Dialogue: 0,0:01:59.56,0:02:05.48,Default,,0,0,0,,基础网络仅提供点对点消息传输机制 即仅提供单播机制\Nthe underlying network only provides point-to-point messaging as in unicast,
Dialogue: 0,0:02:05.48,0:02:09.26,Default,,0,0,0,,我们要在单播机制上构建广播协议\Nand we are going to build broadcast protocols on top of that.
Dialogue: 0,0:02:09.26,0:02:11.92,Default,,0,0,0,,基础网络只允许我们\NSo, the underlying network just allows us to
Dialogue: 0,0:02:11.92,0:02:14.46,Default,,0,0,0,,从一个节点向另一个节点发送一条消息\Nsend a message from one node to one other node,
Dialogue: 0,0:02:14.46,0:02:18.56,Default,,0,0,0,,在此基础上 我们可以将广播协议构建成一个抽象方法\Nbut on top of that, we can build broadcast as an abstraction
Dialogue: 0,0:02:18.56,0:02:21.96,Default,,0,0,0,,允许更高层协议调用广播协议\Nthat we can then use for higher-level protocols.
Dialogue: 0,0:02:21.96,0:02:26.98,Default,,0,0,0,,如果你还记得课程2中有关系统模型的讨论\NSo, if you think back to the discussion of system models in lecture 2,
Dialogue: 0,0:02:26.98,0:02:31.12,Default,,0,0,0,,我们讲解了公平丢包链路和可靠链路的差异\Nwe have the distinction between fair-loss links and reliable links.
Dialogue: 0,0:02:31.98,0:02:34.44,Default,,0,0,0,,当然了 大多数网络链路都是公平丢包链路\NAnd of course, most network links are fair-loss,
Dialogue: 0,0:02:34.44,0:02:37.60,Default,,0,0,0,,但你可以通过消息重传使公平丢包链路变为可靠链路\Nbut you can make them reliable by re-transmitting messages.
Dialogue: 0,0:02:37.60,0:02:41.82,Default,,0,0,0,,广播协议也有相同的链路差异\NExactly the same distinction happens in broadcast protocols,
Dialogue: 0,0:02:41.82,0:02:45.72,Default,,0,0,0,,唯一的区别是 如果网络可能丢失消息\Nexcept here that a network that might lose message,
Dialogue: 0,0:02:45.72,0:02:48.68,Default,,0,0,0,,我们一般称对应的广播机制为尽力广播\Nwe call best-effort broadcast typically.
Dialogue: 0,0:02:49.00,0:02:53.66,Default,,0,0,0,,尽力广播的意思是 一个节点尝试向所有其他节点发送消息\NBest-effort broadcast just means one node tries to send message to all the other nodes,
Dialogue: 0,0:02:53.66,0:02:55.28,Default,,0,0,0,,但消息可能会被传达 也可能不会被传达\Nbut it may or may not arrive.
Dialogue: 0,0:02:55.72,0:02:58.56,Default,,0,0,0,,尤其是当发送方崩溃时\NEspecially if the sender crashes, for example,
Dialogue: 0,0:02:58.56,0:03:01.84,Default,,0,0,0,,消息可能无法传达到所有其他的节点\Nthe message might not reach all of the other nodes.
Dialogue: 0,0:03:02.36,0:03:08.60,Default,,0,0,0,,我们可以让其变成可靠的 同样需要依赖丢失消息重传机制\NOr, we can make it reliable, which again relies on re-transmitting lost messages.
Dialogue: 0,0:03:08.60,0:03:11.60,Default,,0,0,0,,与系统模型中的介绍类似\NLike in the context of system models,
Dialogue: 0,0:03:12.08,0:03:17.72,Default,,0,0,0,,我们假设系统不满足同步系统模型\Nwe are going to assume not a synchronous system model,
Dialogue: 0,0:03:17.72,0:03:21.14,Default,,0,0,0,,我们假设异步或部分同步系统模型\Nbut an asynchronous or partially asynchronous system model,
Dialogue: 0,0:03:21.14,0:03:25.50,Default,,0,0,0,,这意味着我们不为消息延迟设置任何上界\Nwhich means that we're not going to assume any upper bound on message latency.
Dialogue: 0,0:03:25.50,0:03:28.24,Default,,0,0,0,,在可靠广播协议中\NSo, in a reliable broadcast protocol,
Dialogue: 0,0:03:28.24,0:03:31.20,Default,,0,0,0,,我们可以说消息最终一定能传输成功\Nwe can say that the message will eventually go get through,
Dialogue: 0,0:03:31.20,0:03:33.28,Default,,0,0,0,,但我们不会承诺\Nbut we're not making any promises about
Dialogue: 0,0:03:33.28,0:03:37.04,Default,,0,0,0,,消息会花费多长的时间才会传输成功\Nhow long it might take until the message might get through.
Dialogue: 0,0:03:37.04,0:03:39.66,Default,,0,0,0,,这就是广播的相关背景知识了\NOK, so, that's the background on broadcast.
Dialogue: 0,0:03:39.66,0:03:43.90,Default,,0,0,0,,在讲解具体细节之前 我需要介绍一些术语\NI should introduce a little bit of terminology before I get into the details.
Dialogue: 0,0:03:43.90,0:03:48.08,Default,,0,0,0,,在点对点网络链路中\NAnd that is, in the context of point-to-point network links,
Dialogue: 0,0:03:48.08,0:03:52.12,Default,,0,0,0,,我们讨论了通过网络发送和接收消息\Nwe have talked about sending and receiving messages over the network,
Dialogue: 0,0:03:52.12,0:03:55.22,Default,,0,0,0,,在广播协议中\Nwhereas in the context of broadcast protocols,
Dialogue: 0,0:03:55.22,0:04:00.72,Default,,0,0,0,,与点对点网络链路相对应 我们讨论的是广播并传递一条消息\Nwe talk about broadcasting a message and then delivering it as the counterpart.
Dialogue: 0,0:04:00.72,0:04:02.04,Default,,0,0,0,,实际发生的情况是\NSo, what happens is
Dialogue: 0,0:04:02.04,0:04:06.60,Default,,0,0,0,,一个节点的应用希望向整个群组广播一条消息\Nthe application on one node wants to broadcast a message to the entire group.
Dialogue: 0,0:04:06.60,0:04:09.08,Default,,0,0,0,,我们称这个动作为广播\NWe call this action a broadcast.
Dialogue: 0,0:04:09.08,0:04:12.84,Default,,0,0,0,,随后 底层广播算法\NAnd then, the underlying broadcast algorithm
Dialogue: 0,0:04:12.84,0:04:16.76,Default,,0,0,0,,会通过网络发送或接收多条消息\Nmay send or receive multiple messages over the network,
Dialogue: 0,0:04:17.44,0:04:20.86,Default,,0,0,0,,这些消息是通过点对点网络发送或接收的\Nand these are then point-to-point messages that are sent or received.
Dialogue: 0,0:04:20.86,0:04:24.76,Default,,0,0,0,,其他节点可能会收到相应的消息\NAnd on some other node, those messages might be received.
Dialogue: 0,0:04:24.76,0:04:27.50,Default,,0,0,0,,广播算法会接收这些消息\NThey get again picked up by the broadcast algorithm.
Dialogue: 0,0:04:27.50,0:04:33.76,Default,,0,0,0,,随后 广播算法会在某个时间点将消息传递给应用\NAnd the broadcast algorithm at some point then delivers the message to the application.
Dialogue: 0,0:04:33.76,0:04:38.18,Default,,0,0,0,,这里 传递与广播是相互对应的\NSo, here the delivery is the counterpart to the broadcast.
Dialogue: 0,0:04:38.18,0:04:42.64,Default,,0,0,0,,这里的一个细节点是\NAnd one detail that happens here is that
Dialogue: 0,0:04:42.64,0:04:45.00,Default,,0,0,0,,当广播算法收到消息时\Nwhen the broadcast algorithm receives a message,
Dialogue: 0,0:04:45.00,0:04:48.20,Default,,0,0,0,,广播算法可能不会立刻将消息传递给应用\Nit might not immediately deliver that to the application.
Dialogue: 0,0:04:48.20,0:04:52.96,Default,,0,0,0,,广播算法可能会等待一段时间 直到准备好传递消息\NIt may actually have to wait for a little bit before that message is ready to be delivered,
Dialogue: 0,0:04:52.96,0:04:57.70,Default,,0,0,0,,因为我们想要保证消息按照特定的顺序传递给应用\Nbecause we want to ensure that the messages are delivered in a certain order.
Dialogue: 0,0:04:57.70,0:05:00.54,Default,,0,0,0,,这些就是用到的术语了\NSo, this is just the terminology.
Dialogue: 0,0:05:01.30,0:05:05.74,Default,,0,0,0,,我们现在将会介绍几种不同的抽象广播方法\NWe are now going to look at a couple of different broadcast abstractions.
Dialogue: 0,0:05:05.74,0:05:08.48,Default,,0,0,0,,我后面会分别独立地详细介绍这些广播方法\NAnd I'm going to talk about each of these individually.
Dialogue: 0,0:05:08.48,0:05:10.94,Default,,0,0,0,,因此 我现在不会讲解太多的具体细节\NSo, I won't go into too much detail right now.
Dialogue: 0,0:05:11.76,0:05:15.36,Default,,0,0,0,,这里的一个关键点是 这些协议都是可靠广播\NThe point here is that these are all forms of reliable broadcasts.
Dialogue: 0,0:05:15.36,0:05:19.06,Default,,0,0,0,,我们要假设存在一个重传机制\NSo, we're assuming we have a mechanism for re-transmission,
Dialogue: 0,0:05:19.06,0:05:21.96,Default,,0,0,0,,可以保证所有的消息最终都会被成功传输\Nwhich ensures that all of the messages eventually get through.
Dialogue: 0,0:05:21.96,0:05:25.52,Default,,0,0,0,,现在 我们想根据消息传递的顺序\NNow, we want to distinguish different types of broadcasts
Dialogue: 0,0:05:25.52,0:05:29.18,Default,,0,0,0,,来区分不同类型的广播协议\Nbased on the order in which messages get delivered.
Dialogue: 0,0:05:29.18,0:05:32.88,Default,,0,0,0,,我们要介绍的第一个协议是FIFO（先进先出）广播\NAnd so, the first one that we're going to look at is FIFO broadcast.
Dialogue: 0,0:05:32.88,0:05:37.34,Default,,0,0,0,,FIFO广播的消息传递顺序是\NAnd in FIFO broadcast, the ordering property is that
Dialogue: 0,0:05:37.34,0:05:40.64,Default,,0,0,0,,如果两个消息是由同一个节点广播的\Nif two messages are broadcast by the same node,
Dialogue: 0,0:05:40.64,0:05:46.00,Default,,0,0,0,,则所有节点会按照相同的广播顺序传递这些消息\Nthen all nodes will deliver those messages in the same order as they were broadcast.
Dialogue: 0,0:05:46.00,0:05:51.28,Default,,0,0,0,,对于单个特定节点的广播消息 消息传递时会保证顺序一致\NSo, for any messages broadcast from one particular node, they remain in order,
Dialogue: 0,0:05:51.28,0:05:54.72,Default,,0,0,0,,但对于两个不同节点的广播消息\Nbut for any messages broadcast by two different nodes,
Dialogue: 0,0:05:54.72,0:05:57.96,Default,,0,0,0,,协议不会保证传递顺序与发送顺序一致\Nthere's no guarantee about the order in which they might arrive.
Dialogue: 0,0:05:57.96,0:06:00.56,Default,,0,0,0,,我们通过一个具体的例子来了解这个协议的执行过程\NSo, let's look at an example of what this actually looks like.
Dialogue: 0,0:06:00.56,0:06:03.48,Default,,0,0,0,,这里我们同样有三个节点A、B和C\NSo, here we have again three nodes A, B and C.
Dialogue: 0,0:06:03.48,0:06:06.72,Default,,0,0,0,,A想要在群组中广播消息m_1\NA wants to broadcast message m_1 to the group.
Dialogue: 0,0:06:06.72,0:06:11.56,Default,,0,0,0,,因此 A通过网络将消息发送给C和B\NAnd so, it sends that message over the network to C and to B.
Dialogue: 0,0:06:11.56,0:06:15.38,Default,,0,0,0,,请注意 A也给自己发送了这条消息\NAnd notice also that A sends the message to itself,
Dialogue: 0,0:06:15.84,0:06:19.76,Default,,0,0,0,,我们用这个小的回环箭头表示自己给自己发送消息\Nwhich is here denoted by this little loopback arrow.
Dialogue: 0,0:06:19.76,0:06:21.90,Default,,0,0,0,,看起来似乎没必要这样做\NNow, this might seem unnecessary,
Dialogue: 0,0:06:21.90,0:06:25.34,Default,,0,0,0,,为什么需要把一个消息传回给自己呢\Nbecause why do you need to deliver a message back to yourself,
Dialogue: 0,0:06:25.88,0:06:29.68,Default,,0,0,0,,此消息的发送方已经知道要发送的消息是什么了\Nbecause the sender of the message already knows what message is sent,
Dialogue: 0,0:06:29.68,0:06:31.42,Default,,0,0,0,,没必要再接收一次这条消息\Nit doesn't need to receive it again.
Dialogue: 0,0:06:32.26,0:06:35.84,Default,,0,0,0,,我们后续讨论全序关系广播时\NThe reason why a node delivers a message to itself
Dialogue: 0,0:06:35.84,0:06:39.80,Default,,0,0,0,,节点向自己传递一条消息的原因就变得很显然了\Nwill become apparent when we talk about total order broadcast shortly.
Dialogue: 0,0:06:39.80,0:06:42.84,Default,,0,0,0,,现在 我们仅把这看成是一个小怪癖\NSo, for now just assume this as a little quirk that
Dialogue: 0,0:06:42.84,0:06:48.88,Default,,0,0,0,,假设广播协议保证总会让发送方给自己也传递一条广播消息\Nthe guarantee of the broadcast protocol is also always that it delivers a message to itself.
Dialogue: 0,0:06:49.54,0:06:52.16,Default,,0,0,0,,当m_1完成消息传递后\NThen, after m_1 has been delivered,
Dialogue: 0,0:06:52.84,0:06:57.06,Default,,0,0,0,,节点B决定向群组广播消息m_2\Nnode B decides that it wants to broadcast message m_2 to the group.
Dialogue: 0,0:06:57.06,0:07:00.90,Default,,0,0,0,,因此 B通过网络向A和C发送m_2\NAnd so, it sends m_2 over the network to A and C,
Dialogue: 0,0:07:00.90,0:07:03.10,Default,,0,0,0,,B也给自己传递m_2\Nand it also delivers m_2 to itself.
Dialogue: 0,0:07:03.10,0:07:07.00,Default,,0,0,0,,最后 节点A想要广播消息m_3\NAnd then, finally, node A wants to broadcast message m_3.
Dialogue: 0,0:07:07.00,0:07:10.92,Default,,0,0,0,,同样地 A通过网络向B和C发送m_3\NSo, again, it sends that message over the network to B and C,
Dialogue: 0,0:07:10.92,0:07:15.02,Default,,0,0,0,,A也给自己传递m_3\Nand it delivers m_3 to itself.
Dialogue: 0,0:07:15.02,0:07:18.68,Default,,0,0,0,,这就是FIFO广播\NOK, so, this is FIFO broadcast.
Dialogue: 0,0:07:18.68,0:07:22.74,Default,,0,0,0,,正如我前面所说 我们要求FIFO广播满足的性质是\NSo, what we require for FIFO broadcast, as I said just now, is that
Dialogue: 0,0:07:22.74,0:07:28.00,Default,,0,0,0,,因为m_1和m_3都是由相同的节点A广播的\Nbecause m_1 and m_3 are both broadcast by the same node A,
Dialogue: 0,0:07:28.00,0:07:32.84,Default,,0,0,0,,我们要求所有节点在传递m_3之前先传递m_1\Nwe require that all nodes deliver m_1 before they deliver m_3.
Dialogue: 0,0:07:32.84,0:07:35.38,Default,,0,0,0,,我们可以检查一下 事实的确如此\NAnd we can check that this is the case here.
Dialogue: 0,0:07:35.38,0:07:39.10,Default,,0,0,0,,这里A传递m_1 再传递m_3\NA delivers m_1 here, and then delivers m_3, OK?
Dialogue: 0,0:07:39.10,0:07:42.20,Default,,0,0,0,,B传递m_1 再传递m_3\NB delivers m_1, then delivers m_3.
Dialogue: 0,0:07:42.20,0:07:44.96,Default,,0,0,0,,C也先传递m_1 再传递m_3\NAnd C also delivers m_1, and then delivers m_3.
Dialogue: 0,0:07:44.96,0:07:50.10,Default,,0,0,0,,很好 所有节点都按照正确的顺序传递消息\NOK, all fine. All of the nodes delivered these messages in the right order.
Dialogue: 0,0:07:50.10,0:07:52.86,Default,,0,0,0,,FIFO广播下\NNow, there are actually several possible orders
Dialogue: 0,0:07:52.86,0:07:55.80,Default,,0,0,0,,有多种合理的消息传递顺序\Nthat would be valid here under FIFO broadcast.
Dialogue: 0,0:07:56.72,0:08:00.06,Default,,0,0,0,,特别地 由B发送的消息m_2\NIn particular, the message m_2 that is sent by B,
Dialogue: 0,0:08:00.06,0:08:03.54,Default,,0,0,0,,可以把它的传递顺序放在A消息的任意位置上\Nthat can be ordered arbitrarily with respect to A's messages,
Dialogue: 0,0:08:03.54,0:08:08.18,Default,,0,0,0,,因为我们不保证不同节点消息的传递顺序\Nbecause we are not making any guarantees about ordering across different nodes,
Dialogue: 0,0:08:08.18,0:08:11.20,Default,,0,0,0,,而m_2是由B发送的\Nand m_2 was sent by B,
Dialogue: 0,0:08:11.20,0:08:15.46,Default,,0,0,0,,这意味着m_2的传递顺序\Nso, this means that it's OK for m_2 to be delivered
Dialogue: 0,0:08:15.46,0:08:20.16,Default,,0,0,0,,可以在m_1和m_3之前、之间、或者之后\Nbefore m_1 and m_3, or in between the two, or after the two.
Dialogue: 0,0:08:20.16,0:08:21.72,Default,,0,0,0,,这些传递顺序都是合理的\NAnd all of those are fine.
Dialogue: 0,0:08:21.72,0:08:25.86,Default,,0,0,0,,举例来说 我们可以考虑这两个不同的执行效果\NAnd, so here, for example, we can consider these two different executions,
Dialogue: 0,0:08:26.46,0:08:31.06,Default,,0,0,0,,这两个执行效果中 C传递消息的顺序有所不同\Nin which the messages are delivered by C in a different order.
Dialogue: 0,0:08:31.56,0:08:36.12,Default,,0,0,0,,在这个情况下 C先传递m_1、再传递m_2、再传递m_3\NSo, in this case, here m_1 is delivered first, then m_2, then m_3.
Dialogue: 0,0:08:36.12,0:08:40.14,Default,,0,0,0,,在这个情况下 C先传递m_2、再传递m_1、再传递m_3\NIn this case, m_2 is delivered first, then m_1, then m_3.
Dialogue: 0,0:08:40.14,0:08:44.54,Default,,0,0,0,,在FIFO广播下 这两种消息传递顺序都是合理的\NAnd both of these orders are valid under FIFO broadcast.
Dialogue: 0,0:08:44.54,0:08:48.92,Default,,0,0,0,,即使在这种情况下 你认为m_2和m_1有因果关系\NEven though, in this case, here for example, the message m_2,
Dialogue: 0,0:08:48.92,0:08:52.42,Default,,0,0,0,,消息m_2应该发生在消息m_1之后\Nyou would say that happened after m_1 in a causal sense,
Dialogue: 0,0:08:53.00,0:08:58.32,Default,,0,0,0,,但FIFO广播不会保证先传递m_1、再传递m_2\Nbut still FIFO broadcast makes no guarantees about delivering m_2 after m_1.
Dialogue: 0,0:08:58.32,0:09:02.34,Default,,0,0,0,,如果你确实希望传递顺序满足因果关系 你就需要因果关系广播了\NIf you do want that kind of ordering property, you need causal broadcast.
Dialogue: 0,0:09:02.34,0:09:07.68,Default,,0,0,0,,因果关系广播保证消息按照因果顺序传递\NSo, causal broadcast ensures that messages are delivered in causal order.
Dialogue: 0,0:09:07.68,0:09:11.60,Default,,0,0,0,,这意味着如果广播一条消息\NThat means that if the broadcasting of one message
Dialogue: 0,0:09:11.60,0:09:13.96,Default,,0,0,0,,在广播另一条消息之前发生\Nhappened before the broadcasting of another,
Dialogue: 0,0:09:13.96,0:09:16.22,Default,,0,0,0,,也就是说两次广播满足此前发生关系\Nin the sense that happens-before relation,
Dialogue: 0,0:09:16.22,0:09:19.10,Default,,0,0,0,,那么这些消息也必须按照这个顺序传递\Nthen those messages must be delivered in that order
Dialogue: 0,0:09:19.10,0:09:21.20,Default,,0,0,0,,传递顺序要满足此前发生关系\Nthat matches that happens-before relation.
Dialogue: 0,0:09:21.20,0:09:22.34,Default,,0,0,0,,这就是这里演示的传递顺序\NAnd that's what we have here.
Dialogue: 0,0:09:22.34,0:09:25.42,Default,,0,0,0,,首先 m_1由A广播\NSo, first of all, m_1 is broadcast by A,
Dialogue: 0,0:09:25.42,0:09:29.30,Default,,0,0,0,,B和C收到了消息 B传递了此消息\Nand it's received by B and C, and it's delivered by B here.
Dialogue: 0,0:09:29.30,0:09:35.54,Default,,0,0,0,,随后 在B传递m_1之后想广播m_2\NAnd then, after B has delivered m_1, B wants to broadcast m_2.
Dialogue: 0,0:09:35.54,0:09:40.18,Default,,0,0,0,,这里的m_2可能与m_1有因果依赖关系\NAnd so, here m_2 may have a causal dependency on m_1.
Dialogue: 0,0:09:40.18,0:09:46.58,Default,,0,0,0,,因此 我们要求所有的节点必须先传递m_1、再传递m_2\NAnd therefore, we require that all of the nodes must deliver m_1 first and m_2 second.
Dialogue: 0,0:09:46.58,0:09:51.90,Default,,0,0,0,,接下来 节点A可能想广播消息m_3\NNext, the node A might broadcast a message m_3.
Dialogue: 0,0:09:51.90,0:09:54.20,Default,,0,0,0,,A同样通过网络向其他两个节点发送此消息\NAgain, it sends that over the network to the other two nodes,
Dialogue: 0,0:09:54.20,0:09:56.38,Default,,0,0,0,,且A向自己传递了此消息\Nand it delivers the message to itself.
Dialogue: 0,0:09:56.38,0:09:57.26,Default,,0,0,0,,在这种情况下\NAnd in this case,
Dialogue: 0,0:09:57.26,0:10:02.66,Default,,0,0,0,,注意到m_2的广播与m_3的广播是并发的\Nnotice that the broadcast of m_2 is concurrent with the broadcast of m_3,
Dialogue: 0,0:10:02.66,0:10:07.80,Default,,0,0,0,,因为A是在m_3广播之后才传递的m_2\Nbecause on A, m_2 is delivered after m_3 is broadcast,
Dialogue: 0,0:10:07.80,0:10:11.54,Default,,0,0,0,,而B是在m_2广播之后才传递的m_3\Nand on B, m_3 is delivered after m_2 is broadcast.
Dialogue: 0,0:10:11.54,0:10:14.36,Default,,0,0,0,,因此 这两条消息之间没有依赖关系\NSo, these two messages do not depend on each other.
Dialogue: 0,0:10:14.36,0:10:18.40,Default,,0,0,0,,在这种情况下 我们要求的是\NSo, in this case, here what we require is that
Dialogue: 0,0:10:18.40,0:10:24.24,Default,,0,0,0,,任意存在因果依赖关系的消息必须按照因果顺序传递\Nany messages that have a causal dependency are delivered in causal order.
Dialogue: 0,0:10:24.24,0:10:29.30,Default,,0,0,0,,因此 在这种情况下 m_1和m_2存在因果依赖关系\NAnd so, in this case, here we have a causal dependency between m_1 and m_2,
Dialogue: 0,0:10:29.30,0:10:32.50,Default,,0,0,0,,且m_1和m_3存在因果依赖关系\Nand we have a causal dependency between m_1 and m_3,
Dialogue: 0,0:10:32.50,0:10:37.42,Default,,0,0,0,,因为m_1和m_3是由相同的节点A所广播的\Nbecause m_1 and m_3 were broadcast by the same node A.
Dialogue: 0,0:10:37.42,0:10:40.54,Default,,0,0,0,,但m_2和m_3不存在因果依赖关系\NBut there's no causal dependency between m_2 and m_3.
Dialogue: 0,0:10:40.54,0:10:44.46,Default,,0,0,0,,因此 这意味着可以按任意一种顺序传递m_2和m_3\NAnd so, this means m_2 and m_3 can be delivered in either order,
Dialogue: 0,0:10:44.46,0:10:49.32,Default,,0,0,0,,C仍然有两种不同的消息传递顺序\Nwhich means that here again, we have two different orders of delivery for C,
Dialogue: 0,0:10:49.32,0:10:53.62,Default,,0,0,0,,这两种消息传递顺序对于因果关系广播来说都是合理的\Nand both of these are OK under causal broadcast.
Dialogue: 0,0:10:53.62,0:11:00.34,Default,,0,0,0,,在这种情况下 C首先传递m_1、再传递m_3、再传递m_2\NSo, here, in this case, we have C first delivering m_1, then m_3, then m_2.
Dialogue: 0,0:11:00.34,0:11:05.24,Default,,0,0,0,,在这种情况下 C首先传递m_1、再传递m_2、再传递m_3\NIn this case, here we have C first delivering m_1, then m_2, then m_3.
Dialogue: 0,0:11:05.24,0:11:06.94,Default,,0,0,0,,这两种传递顺序都是合理的\NAnd these are both valid orders.
Dialogue: 0,0:11:06.94,0:11:11.74,Default,,0,0,0,,我们可以交换m_2和m_3的传递顺序\NWe can swap around the delivery order of m_2 and m_3.
Dialogue: 0,0:11:11.74,0:11:20.42,Default,,0,0,0,,注意到 这里A先传递m_1、再传递m_3、再传递m_2\NNow, notice here, for example, that A delivers first delivers m_1, then m_3, then m_2,
Dialogue: 0,0:11:20.42,0:11:25.02,Default,,0,0,0,,而B先传递m_1、再传递m_2、再传递m_3\Nwhereas B delivers first m_1, then m_2, then m_3.
Dialogue: 0,0:11:25.02,0:11:30.74,Default,,0,0,0,,这两种都是合理的因果顺序 但这两种顺序不相同\NSo, both of these orders are valid causal orders, but they are not the same.
Dialogue: 0,0:11:30.74,0:11:34.36,Default,,0,0,0,,有些情况下 我们实际上要求\NAnd in some cases, we actually want to require that
Dialogue: 0,0:11:34.36,0:11:37.34,Default,,0,0,0,,所有节点按照相同的顺序传递消息\Nall of the nodes deliver messages in the same order.
Dialogue: 0,0:11:37.34,0:11:42.98,Default,,0,0,0,,如果我们希望满足这一要求 我们就需要转向所谓的全序关系广播了\NAnd if that is what we want, we need to move to what is called total order broadcast.
Dialogue: 0,0:11:42.98,0:11:44.78,Default,,0,0,0,,全序关系广播\NSo, total order broadcast
Dialogue: 0,0:11:44.78,0:11:48.48,Default,,0,0,0,,将系统中的所有广播消息按照全序关系排列\Nputs all of the messages that are broadcast in the system into a total order.
Dialogue: 0,0:11:48.48,0:11:51.54,Default,,0,0,0,,这意味着消息的传递顺序总是清晰的\NThat means it's always clear which one came first.
Dialogue: 0,0:11:51.54,0:11:55.74,Default,,0,0,0,,全序关系广播保证所有节点按照相同的顺序传递消息\NAnd it ensures that all of the nodes deliver messages in that same order.
Dialogue: 0,0:11:55.74,0:11:58.96,Default,,0,0,0,,所有节点将会一起协商好\NSo, there's agreement between all of the nodes on the order
Dialogue: 0,0:11:58.96,0:12:01.34,Default,,0,0,0,,所需的消息传递顺序\Nin which the messages should be delivered.
Dialogue: 0,0:12:01.34,0:12:05.16,Default,,0,0,0,,举例来说 在这个例子中 我们从A广播m_1开始\NSo, in this example, again, we start with m_1 broadcast by A,
Dialogue: 0,0:12:05.16,0:12:10.26,Default,,0,0,0,,随后 我们让B在m_1之后广播m_2\Nthen we have m_2 broadcast by B, which happens after m_1,
Dialogue: 0,0:12:10.26,0:12:15.90,Default,,0,0,0,,最后 我们让A广播消息m_3\Nand finally, we have a message m_3 that is broadcast by A again.
Dialogue: 0,0:12:15.90,0:12:19.26,Default,,0,0,0,,在这种情况 我们需要在某个地方\NNow, in this case, something somewhere
Dialogue: 0,0:12:19.26,0:12:21.82,Default,,0,0,0,,决定这些消息的传递顺序\Nhas to decide on the order in which these will be delivered.
Dialogue: 0,0:12:21.82,0:12:24.82,Default,,0,0,0,,假定决定好的顺序是\NLet's say that the order that was decided is to
Dialogue: 0,0:12:24.82,0:12:28.32,Default,,0,0,0,,先传递m_1、再传递m_2、再传递m_3\Ndeliver first m_1, then m_2, then m_3, OK?
Dialogue: 0,0:12:28.32,0:12:31.60,Default,,0,0,0,,我们以C为例 看看会发生什么\NAnd so, we can see on C, for example, that's what happened.
Dialogue: 0,0:12:31.60,0:12:36.16,Default,,0,0,0,,C先传递m_1、再传递m_2、再传递m_3\NC first delivers m_1, then it delivers m_2, then it delivers m_3.
Dialogue: 0,0:12:36.16,0:12:38.96,Default,,0,0,0,,C按照正确的顺序传递消息\NSo, C is delivering them in the correct order.
Dialogue: 0,0:12:38.96,0:12:40.02,Default,,0,0,0,,我们来看看B\NLet's look at B.
Dialogue: 0,0:12:40.02,0:12:46.32,Default,,0,0,0,,这里B先传递m_1、再给自己传递m_2、再传递m_3\NHere B first delivers m_1, then it delivers m_2 to itself, then it delivers m_3, OK?
Dialogue: 0,0:12:46.32,0:12:49.24,Default,,0,0,0,,因此 B也按照正确的顺序传递消息\NSo, B also delivers the messages in the correct order.
Dialogue: 0,0:12:49.24,0:12:50.84,Default,,0,0,0,,来看看节点A\NLet's look at node A here.
Dialogue: 0,0:12:50.84,0:12:53.66,Default,,0,0,0,,A先给自己传递m_1\NNode A first delivers m_1 to itself,
Dialogue: 0,0:12:53.66,0:12:59.72,Default,,0,0,0,,接下来 A广播m_3 但稍等下 此时A不能给自己传递m_3\Nthen it broadcasts m_3, but wait, it's not allowed to deliver m_3 to itself yet,
Dialogue: 0,0:12:59.72,0:13:04.58,Default,,0,0,0,,因为决定好的顺序要求先传递m_2、再传递m_3\Nbecause the order that was decided is that m_2 must be delivered before m_3.
Dialogue: 0,0:13:04.58,0:13:09.30,Default,,0,0,0,,因此 节点A不能立刻给自己传递m_3\NSo, therefore, node A cannot immediately deliver m_3 to itself.
Dialogue: 0,0:13:09.30,0:13:17.38,Default,,0,0,0,,A需要先等待m_2的到来并传递m_2\NInstead, it has to wait first for m_2 to arrive and m_2 to be delivered by A,
Dialogue: 0,0:13:17.38,0:13:21.90,Default,,0,0,0,,随后A才能给自己传递m_3\Nand only then is A allowed to deliver m_3 to itself.
Dialogue: 0,0:13:21.90,0:13:26.86,Default,,0,0,0,,这就是自我传递顺序变得非常有趣、非常关键的地方\NSo, this is now where this delivery-to-self becomes very interesting and crucial,
Dialogue: 0,0:13:26.86,0:13:31.76,Default,,0,0,0,,你可以看到 当要给自己传递消息时\Nbecause you can see that sometimes there has to be this delay
Dialogue: 0,0:13:32.34,0:13:35.94,Default,,0,0,0,,节点在这种情况下必须引入一些延迟\Nif a node wants to deliver a message to itself.
Dialogue: 0,0:13:35.94,0:13:43.34,Default,,0,0,0,,这里的m_1、m_2、m_3是一种可能的消息传递顺序\NNow here, m_1, m_2, then m_3 is one possible order of delivering these messages.
Dialogue: 0,0:13:44.76,0:13:47.40,Default,,0,0,0,,我们也可以决定使用不同的消息传递顺序\NIt could also be that we decide on a different order.
Dialogue: 0,0:13:47.40,0:13:52.44,Default,,0,0,0,,另一个合理的消息传递顺序可能是m_1、m_3、m_2\NSo, a different valid order might be for the delivery order to be m_1, m_3, m_2.
Dialogue: 0,0:13:52.44,0:13:58.38,Default,,0,0,0,,我们只要求所有节点按照相同的顺序传递消息\NAnd that is also fine, as long as all of the nodes deliver the messages in that same order.
Dialogue: 0,0:13:58.38,0:14:00.52,Default,,0,0,0,,这里 我们从C开始\NAnd so, here again, we have start with C.
Dialogue: 0,0:14:00.52,0:14:04.98,Default,,0,0,0,,C先传递m_1、再传递m_3、再传递m_2\NSo, C first delivers m_1, then m_3, then m_2.
Dialogue: 0,0:14:04.98,0:14:07.42,Default,,0,0,0,,注意 这里可能出现的情况是\NNotice here that it's possible that
Dialogue: 0,0:14:07.42,0:14:11.94,Default,,0,0,0,,C在收到m_3之前 先通过网络收到了m_2\NC receives m_2 over the network before it receives m_3,
Dialogue: 0,0:14:11.94,0:14:18.78,Default,,0,0,0,,此时 C必须等待m_3的到来 延迟传递m_2\Nin which case, C will have to delay the delivery of m_2 until after m_3 has arrived.
Dialogue: 0,0:14:18.78,0:14:22.72,Default,,0,0,0,,在广播算法中 这被称为保留广播\NSo here, this is called a holdback in the broadcast algorithm.
Dialogue: 0,0:14:22.72,0:14:27.70,Default,,0,0,0,,如果消息还没有准备好传递 通常需要先保留消息\NIt's often necessary for a message to be held back if it's not yet ready to be delivered,
Dialogue: 0,0:14:27.70,0:14:30.86,Default,,0,0,0,,因为我们需要先等待其他消息的到来\Nbecause we're waiting for some other message to arrive first.
Dialogue: 0,0:14:30.86,0:14:33.66,Default,,0,0,0,,C就遇到了这种情况\NAnd that has happened here in the case of C.
Dialogue: 0,0:14:33.66,0:14:37.46,Default,,0,0,0,,在节点B中 为了让传递顺序为m_1、m_3、m_2\NIn the node B, for the delivery order to be m_1, m_3, m_2,
Dialogue: 0,0:14:37.46,0:14:44.02,Default,,0,0,0,,我们首先传递m_1 再广播m_2\Nwell, first, we deliver m_1, then we broadcast m_2,
Dialogue: 0,0:14:44.02,0:14:47.28,Default,,0,0,0,,但我们不能立刻让B给自己传递m_2\Nbut we can't immediately deliver m_2 to ourselves.
Dialogue: 0,0:14:47.28,0:14:50.70,Default,,0,0,0,,我们需要先等待m_3传递完毕\NWe have to first wait for m_3 to be delivered.
Dialogue: 0,0:14:50.70,0:14:54.58,Default,,0,0,0,,随后 我们才能让B传递m_2\NAnd then, we're allowed to deliver m_2 to ourselves at B.
Dialogue: 0,0:14:54.58,0:14:57.04,Default,,0,0,0,,节点A的情况比较简单\NAnd on node A, things are simpler now.
Dialogue: 0,0:14:57.04,0:15:08.48,Default,,0,0,0,,首先 我们让A给自己传递m_1 随后我们让A给自己传递m_3\NSo, first, we deliver m_1 to ourselves, then we deliver m_3 to ourselves,
Dialogue: 0,0:15:08.48,0:15:13.20,Default,,0,0,0,,最后 m_2通过网络到达A 我们让A给自己传递m_2\Nand finally, m_2 arrives over the network, and we deliver m_2 to ourselves.
Dialogue: 0,0:15:13.20,0:15:18.30,Default,,0,0,0,,以上两种情况都是合理的全序关系广播执行过程\NSo, both of these here are valid executions of total order broadcasts.
Dialogue: 0,0:15:18.30,0:15:24.06,Default,,0,0,0,,重要的是 无论我们按照何种顺序传递消息\NThe crucial thing is just that whatever order the messages get delivered in,
Dialogue: 0,0:15:24.06,0:15:26.90,Default,,0,0,0,,所有节点的消息传递顺序必须都相同\Nthat order has to be the same for all of the nodes.
Dialogue: 0,0:15:26.90,0:15:30.08,Default,,0,0,0,,最后 我们还有所谓的FIFO全序关系广播\NFinally, there's something called FIFO-total order broadcast,
Dialogue: 0,0:15:30.08,0:15:33.54,Default,,0,0,0,,就是把全序关系广播与FIFO顺序组合在一起\Nwhich just combines total order broadcast with FIFO ordering.
Dialogue: 0,0:15:33.54,0:15:37.28,Default,,0,0,0,,意思是所有节点必须按照相同的顺序传递消息\NSo, that means all the nodes have to deliver messages in the same order,
Dialogue: 0,0:15:37.28,0:15:37.98,Default,,0,0,0,,同时\Nand also,
Dialogue: 0,0:15:37.98,0:15:42.30,Default,,0,0,0,,相同节点发送的消息必须按照发送顺序传递\Nmessages sent by the same node have to be the delivered in the order they were sent.
Dialogue: 0,0:15:42.70,0:15:47.82,Default,,0,0,0,,可以证明 FIFO全序关系广播严格强于因果关系广播\NAnd it turns out that FIFO-total order broadcast is strictly stronger than causal broadcast.
Dialogue: 0,0:15:47.82,0:15:51.44,Default,,0,0,0,,每次执行FIFO全序关系广播\NSo, every execution of FIFO-total order broadcast
Dialogue: 0,0:15:51.44,0:15:54.96,Default,,0,0,0,,也必须满足因果关系广播的要求\Nalso meets the requirement of causal broadcast,
Dialogue: 0,0:15:54.96,0:15:59.74,Default,,0,0,0,,每次执行因果关系广播也必须满足FIFO广播的要求\Nand every execution of causal broadcast also meets the requirement of FIFO broadcast.
Dialogue: 0,0:15:59.74,0:16:03.24,Default,,0,0,0,,每次执行FIFO广播也必须满足可靠广播的要求 以此类推\NEvery FIFO broadcast meets the requirement of reliable broadcast, and so on.
Dialogue: 0,0:16:03.24,0:16:06.96,Default,,0,0,0,,本节课的讲义中有一个练习\NSo, there's actually an exercise in the lecture notes for this lecture
Dialogue: 0,0:16:06.96,0:16:11.54,Default,,0,0,0,,就是要求你证明广播模型之间的这一相互关系\Nthat asks you to prove some of these relationships between the broadcast models.
Dialogue: 0,0:16:11.54,0:16:14.32,Default,,0,0,0,,下一小节 我们将学习\NIn the next section, we will then look at
Dialogue: 0,0:16:14.32,0:16:17.72,Default,,0,0,0,,如何实现这些广播算法\Nhow to actually implement some of these broadcast algorithms.
