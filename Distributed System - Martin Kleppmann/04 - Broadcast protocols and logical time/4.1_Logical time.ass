[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 4.1_Logical time.mp4
Video File: 4.1_Logical time.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 156
Active Line: 176
Video Position: 20699

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.76,0:00:05.78,Default,,0,0,0,,大家好 欢迎来到分布式系统的第4课\NHello everyone. Welcome to lecture 4 of distributed systems.
Dialogue: 0,0:00:05.78,0:00:10.50,Default,,0,0,0,,今天 我们将讨论广播协议和逻辑时间\NToday, we will be talking about broadcast protocols and logical time.
Dialogue: 0,0:00:10.50,0:00:15.22,Default,,0,0,0,,作为背景知识 回忆一下上一节课的这页幻灯片\NAs background, remember this slide here from the last lecture,
Dialogue: 0,0:00:15.22,0:00:17.76,Default,,0,0,0,,我们有两条消息\Nwhere we have the case of two messages.
Dialogue: 0,0:00:17.76,0:00:22.16,Default,,0,0,0,,第一条消息是用户A说“月亮是奶酪做的！”\NFirst, m_1 is user A says “The moon is made of cheese!”,
Dialogue: 0,0:00:22.16,0:00:28.14,Default,,0,0,0,,第二条消息是用户B回复m_1的m_2：“不 不是的！”\Nm_2 is user B replies to m_1 saying “Oh, no, it isn't!”.
Dialogue: 0,0:00:28.14,0:00:31.80,Default,,0,0,0,,使用物理时钟所面临的问题是\NAnd what could happen with physical clocks is that
Dialogue: 0,0:00:31.80,0:00:37.82,Default,,0,0,0,,m_1的时间戳可能会比m_2的时间戳大\Nthe timestamp of m_1 ends up being greater than the timestamp of m_2.
Dialogue: 0,0:00:37.82,0:00:42.92,Default,,0,0,0,,有可能出现的一种情况是 两个时间戳的大小关系\NSo, it could be the case that those timestamps are inconsistent with the order
Dialogue: 0,0:00:42.92,0:00:45.88,Default,,0,0,0,,与我们期望的事件发生顺序不一致\Nthat we intuitively expect of those two messages,
Dialogue: 0,0:00:45.88,0:00:49.64,Default,,0,0,0,,两个消息的时间戳大小关系与事件的因果关系不一致\Nthat those messages are inconsistent with causality.
Dialogue: 0,0:00:49.64,0:00:52.68,Default,,0,0,0,,即使我们使用NTP协议等各种方法同步时钟\NNow, this is a problem with physical clocks
Dialogue: 0,0:00:52.68,0:00:57.92,Default,,0,0,0,,使用物理时钟仍然可能会遇到上述问题\Neven after we've gone to all of these efforts to synchronize them using NTP.
Dialogue: 0,0:00:57.92,0:01:03.84,Default,,0,0,0,,即便进行了时钟同步 时间戳大小关系与事件的因果关系也可能不一致\NEven then, it could happen that you get these inconsistencies with causality.
Dialogue: 0,0:01:03.84,0:01:06.52,Default,,0,0,0,,这时就要引入逻辑时钟了\NSo, this is where logical clocks come in.
Dialogue: 0,0:01:06.52,0:01:12.66,Default,,0,0,0,,逻辑时钟是分布式系统对时钟的另一种定义\NLogical clocks are an alternative definition of clocks that are used in distributed systems,
Dialogue: 0,0:01:12.66,0:01:17.26,Default,,0,0,0,,设计逻辑时钟就是为了描述\Nwhich are specifically designed to capture the causal relationships
Dialogue: 0,0:01:17.26,0:01:20.20,Default,,0,0,0,,系统中所发生事件的因果关系\Nbetween the events that happen in a system.
Dialogue: 0,0:01:20.20,0:01:24.80,Default,,0,0,0,,逻辑时钟也是一种时钟\NAnd so, logical clocks, they are sort of clocks.
Dialogue: 0,0:01:24.80,0:01:27.00,Default,,0,0,0,,逻辑时钟并不是传统意义上的时钟\NThey're not clocks in the sense of
Dialogue: 0,0:01:27.00,0:01:28.66,Default,,0,0,0,,不用来度量时间\Nmeasuring how long it's been,
Dialogue: 0,0:01:28.66,0:01:32.60,Default,,0,0,0,,不用来度量地球围绕太阳的公转周期\Nmeasuring how far the earth has turned around the sun,
Dialogue: 0,0:01:32.60,0:01:37.28,Default,,0,0,0,,不用来度量地球的自转周期\Nmeasuring how far the earth has rotated around its own axis, those kinds of things.
Dialogue: 0,0:01:37.28,0:01:39.08,Default,,0,0,0,,那些都是物理时间\NThat's all physical time.
Dialogue: 0,0:01:39.08,0:01:43.30,Default,,0,0,0,,在逻辑时间中 我们对时间流逝了多少秒不感兴趣\NIn logical time, we're not actually interested in how many seconds have elapsed.
Dialogue: 0,0:01:43.30,0:01:47.20,Default,,0,0,0,,我们感兴趣的是发生了多少个事件\NInstead, what we're interested in is how many events have occurred.
Dialogue: 0,0:01:47.20,0:01:51.28,Default,,0,0,0,,逻辑时间戳本质上只是一个计数器\NAnd so, logical timestamps are essentially just counters that we increment
Dialogue: 0,0:01:51.28,0:01:53.08,Default,,0,0,0,,只要发生了某件事 就增加计数器的计数值\Nevery time when something happens.
Dialogue: 0,0:01:53.08,0:01:58.76,Default,,0,0,0,,这意味着逻辑时间也随时间流逝而增加\NAnd so, this means they do move forwards in time. They get greater as stuff happens.
Dialogue: 0,0:01:58.76,0:02:04.06,Default,,0,0,0,,但逻辑时间和物理时间没有直接关系\NBut they don't have a direct relationship to physical time.
Dialogue: 0,0:02:04.06,0:02:09.56,Default,,0,0,0,,我们希望逻辑时间完成的工作是\NSo, the key thing that we want of a logical clock is that
Dialogue: 0,0:02:09.56,0:02:13.22,Default,,0,0,0,,表达因果关系 表达此前发生关系\Nit captures causality, it captures the happens-before relationship.
Dialogue: 0,0:02:13.22,0:02:17.72,Default,,0,0,0,,特别地 如果e_1→e_2\NIn particular, if e_1→e_2,
Dialogue: 0,0:02:17.72,0:02:22.80,Default,,0,0,0,,则我们希望e_1的时间戳小于e_2的时间戳\Nthen we want the timestamp of e_1 to be less than the timestamp of e_2.
Dialogue: 0,0:02:22.80,0:02:28.84,Default,,0,0,0,,这是我们期望逻辑时钟所满足的最小要求\NThis is like a minimum basic thing that we expect of our logical clocks.
Dialogue: 0,0:02:28.84,0:02:32.60,Default,,0,0,0,,我们将学习逻辑时钟的两种构造方法\NAnd we're going to look at two different constructions of logical clocks,
Dialogue: 0,0:02:32.60,0:02:34.96,Default,,0,0,0,,Lamport时钟和向量时钟\NLamport clocks and vector clocks.
Dialogue: 0,0:02:34.96,0:02:40.00,Default,,0,0,0,,这两种逻辑时钟都可以表达因果关系\NBoth of these satisfy this need to capture causality,
Dialogue: 0,0:02:40.00,0:02:44.42,Default,,0,0,0,,但它们有一些微小的不同点 适合在不同场景下使用 我们稍后就会讲到\Nbut they have slightly different properties in other areas as we shall see.
Dialogue: 0,0:02:44.42,0:02:46.96,Default,,0,0,0,,我们先从Lamport时钟开始\NSo, let's start with Lamport clocks.
Dialogue: 0,0:02:47.36,0:02:49.30,Default,,0,0,0,,此时钟因Leslie Lamport而命名\NThese are named after Leslie Lamport,
Dialogue: 0,0:02:49.30,0:02:53.20,Default,,0,0,0,,他在1978年左右发表了此时钟算法的论文\Nwho published this algorithm in about 1978 or so.
Dialogue: 0,0:02:53.20,0:02:56.64,Default,,0,0,0,,这是分布式系统非常经典的算法\NAnd this has really been a classic of distributed systems.
Dialogue: 0,0:02:56.64,0:02:58.70,Default,,0,0,0,,此算法非常简单\NAnd the algorithm is fairly simple.
Dialogue: 0,0:02:58.70,0:03:05.14,Default,,0,0,0,,算法启动时 每个节点都有一个变量t\NSo, the algorithm starts at every node we have a variable that we call t.
Dialogue: 0,0:03:05.14,0:03:09.72,Default,,0,0,0,,当启动系统时 此变量被初始化为0\NAnd this variable is initialized to 0 when we start up the system.
Dialogue: 0,0:03:09.72,0:03:14.28,Default,,0,0,0,,每个节点分别持有自己的变量 每个节点都拥有自己的t\NAnd each node has its own copy of this variable. Each node has its own t.
Dialogue: 0,0:03:14.28,0:03:19.08,Default,,0,0,0,,当节点中发生某个事件时 我们增加t\NAnd every time when some event occurs at a node, we just increment t.
Dialogue: 0,0:03:19.08,0:03:22.50,Default,,0,0,0,,事件可以是节点在本地执行了一个步骤\NSo, an event could be some local execution step taking place.
Dialogue: 0,0:03:22.50,0:03:24.60,Default,,0,0,0,,事件也可以是节点发送或接收了一条消息\NSo, it could be sending a message or receiving a message.
Dialogue: 0,0:03:24.60,0:03:27.56,Default,,0,0,0,,只要发生了一个事件 我们就增加t\NIn all of these cases, we just increment t.
Dialogue: 0,0:03:27.56,0:03:31.20,Default,,0,0,0,,现在 每当我们想通过网络发送一条消息或者想执行本地事件\NNow, every time we want to send a message over the network,
Dialogue: 0,0:03:31.20,0:03:34.34,Default,,0,0,0,,我们就增加t\Nwe increment t as usual as for any local event.
Dialogue: 0,0:03:34.34,0:03:38.48,Default,,0,0,0,,增加t后 我们取t的值\NAnd also, we take the value of t after incrementing it.
Dialogue: 0,0:03:38.48,0:03:40.42,Default,,0,0,0,,将t的值附加在消息上\NAnd we attach that to the message.
Dialogue: 0,0:03:40.42,0:03:45.40,Default,,0,0,0,,我们发送的消息是时间戳和实际消息所组成的数据对\NSo, the message we send is actually this pair of a timestamp and the actual message.
Dialogue: 0,0:03:45.40,0:03:47.40,Default,,0,0,0,,这就是我们要通过网络发送的消息\NAnd that is what gets sent on the network.
Dialogue: 0,0:03:47.40,0:03:51.78,Default,,0,0,0,,现在 当另一端收到了其中一个数据对后\NNow, when one of these pairs is received at the other end,
Dialogue: 0,0:03:51.78,0:03:58.52,Default,,0,0,0,,收到消息的节点从数据对中取出时间戳\Nthe node that is receiving the message takes the timestamp out of the message,
Dialogue: 0,0:03:58.52,0:04:01.32,Default,,0,0,0,,t'表示从消息中取出的时间戳\Nt' is the timestamp in the message.
Dialogue: 0,0:04:01.32,0:04:04.94,Default,,0,0,0,,同时 节点查看自己的本地变量t\NAnd it looks at its own local variable t.
Dialogue: 0,0:04:04.94,0:04:08.52,Default,,0,0,0,,他将t更新为\NAnd it updates t to be the maximum of
Dialogue: 0,0:04:08.52,0:04:13.70,Default,,0,0,0,,本地时间戳和消息时间戳的最大值再加1\Neither its own local existing timestamp or the timestamp of the message, plus 1,
Dialogue: 0,0:04:13.70,0:04:16.84,Default,,0,0,0,,就像本地执行事件那样增加t\Nincrementing it again like for every local event.
Dialogue: 0,0:04:16.84,0:04:20.28,Default,,0,0,0,,完成这一步后 我们就得到了更新后的t\NAnd so, after this has been done, we've got updated value t.
Dialogue: 0,0:04:20.28,0:04:23.82,Default,,0,0,0,,我们将消息传递给应用程序\NAnd we deliver the message to the application.
Dialogue: 0,0:04:23.82,0:04:28.32,Default,,0,0,0,,我们再来仔细研究一下Lamport时钟\NSo, let's look at a bit of around Lamport clocks.
Dialogue: 0,0:04:28.32,0:04:33.08,Default,,0,0,0,,每个节点都有一个计数器t\NSo, we have this counter t here on each node.
Dialogue: 0,0:04:33.08,0:04:37.90,Default,,0,0,0,,每个事件都可以与t的一个特定取值相关联\NAnd we can associate a particular value of t with every event.
Dialogue: 0,0:04:37.90,0:04:43.10,Default,,0,0,0,,我们把一个本地发生的事件称为事件e\NSo, let's say that some local event occurred and called that event e.
Dialogue: 0,0:04:43.92,0:04:45.98,Default,,0,0,0,,对于每一个本地事件 我们都增加计数器的值\NFor every local event, we increment the counter.
Dialogue: 0,0:04:45.98,0:04:47.14,Default,,0,0,0,,增加完毕后\NSo, after that increment,
Dialogue: 0,0:04:47.14,0:04:51.38,Default,,0,0,0,,我们取出计数器的值 将其与事件e相关联\Nwe take the value of that counter and associated that with that event e,
Dialogue: 0,0:04:51.38,0:04:54.88,Default,,0,0,0,,关联结果为L(e) 表示这是一个Lamport时钟\Nand call that L(e) for Lamport clock.
Dialogue: 0,0:04:55.72,0:04:56.38,Default,,0,0,0,,我前面讲到\NAs I said,
Dialogue: 0,0:04:56.38,0:05:01.36,Default,,0,0,0,,我们把此计数器值也附加在消息上 通过网络一起发送出去\Nwe attach those values over on the messages that we send over the network as well.
Dialogue: 0,0:05:01.36,0:05:05.48,Default,,0,0,0,,Lamport时钟拥有非常好的性质\NAnd so, these Lamport clocks have some very nice properties.
Dialogue: 0,0:05:05.48,0:05:11.82,Default,,0,0,0,,首先 如果a→b 则这个方案将保证\NFirst of all, if a→b, then this scheme guarantees that
Dialogue: 0,0:05:11.82,0:05:14.02,Default,,0,0,0,,事件a的Lamport时间戳\Nthe Lamport timestamp of event a
Dialogue: 0,0:05:14.02,0:05:19.50,Default,,0,0,0,,将严格小于事件b的Lamport时间戳\Nis strictly less than the Lamport timestamp of event b.
Dialogue: 0,0:05:19.50,0:05:24.90,Default,,0,0,0,,讲义上的一个练习就是要让大家证明\NAnd there's actually an exercise in the lecture notes that asks you to prove that
Dialogue: 0,0:05:24.90,0:05:26.62,Default,,0,0,0,,确实满足这个性质\Nthis is indeed the case.
Dialogue: 0,0:05:27.20,0:05:30.02,Default,,0,0,0,,然而 逆命题不成立\NHowever, the converse is not true.
Dialogue: 0,0:05:30.02,0:05:33.02,Default,,0,0,0,,如果我们对比两个Lamport时间戳\NSo, if we have two Lamport timestamps, and we compare them,
Dialogue: 0,0:05:33.02,0:05:38.78,Default,,0,0,0,,L(a)<L(b)并不意味着a→b\Nand we find that L(a)<L(b), that does not imply that a→b.
Dialogue: 0,0:05:38.78,0:05:41.84,Default,,0,0,0,,还可能出现的一种情况是a‖b\NIt could also be the case that a‖b.
Dialogue: 0,0:05:41.84,0:05:48.26,Default,,0,0,0,,也就是说 Lamport时间戳无法告诉我们到底是a‖b还是a→b\NSo, the Lamport timestamps don't allow us to tell whether a‖b or if a→b.
Dialogue: 0,0:05:48.26,0:05:52.50,Default,,0,0,0,,我们唯一可以确定的是可以排除b→a\NThe only thing we can do is we can rule out that b→a,
Dialogue: 0,0:05:52.50,0:05:57.20,Default,,0,0,0,,因为如果b→a 则时间戳大小关系应该反过来\Nbecause if b→a, then the timestamps would have to be the other way around.
Dialogue: 0,0:05:58.48,0:06:00.94,Default,,0,0,0,,Lamport时间戳可能出现的另一个现象是\NAnother thing that can happen with these Lamport timestamps is
Dialogue: 0,0:06:00.94,0:06:04.76,Default,,0,0,0,,两个不同的事件可能拥有相同的时间戳\Nit's possible that we have two different events with the same timestamp.
Dialogue: 0,0:06:04.76,0:06:06.70,Default,,0,0,0,,无法阻止这种情况的出现\NThere's nothing preventing this.
Dialogue: 0,0:06:07.28,0:06:09.50,Default,,0,0,0,,我们来看一个具体的例子\NSo, let's have a look at a concrete example here.
Dialogue: 0,0:06:09.50,0:06:13.54,Default,,0,0,0,,这里我们通过一些事件执行了一个任务\NSo, here we've got an execution with some events.
Dialogue: 0,0:06:13.54,0:06:17.20,Default,,0,0,0,,事件仍然用小黑点表示 网络仍然会传输一些发送的消息\NThe events are again little black blobs, and we have messages sent over the network.
Dialogue: 0,0:06:17.20,0:06:21.88,Default,,0,0,0,,节点A的第一个事件是本地事件 我们增加本地计数器的值\NSo, here for the first event by node A, we just increment the counter for that local event.
Dialogue: 0,0:06:21.88,0:06:26.72,Default,,0,0,0,,节点A的第二个事件是要通过网络发送消息m_1\NThe second event by node A is that we send the message m_1 over the network.
Dialogue: 0,0:06:26.72,0:06:31.84,Default,,0,0,0,,我们让时间戳2关联到此事件上\NAnd so, here we have the timestamp 2 associated with that event.
Dialogue: 0,0:06:31.84,0:06:35.20,Default,,0,0,0,,我们还将此时间戳拷贝到要发送的消息中\NAnd we also copied that timestamp into the message that we send,
Dialogue: 0,0:06:35.20,0:06:36.80,Default,,0,0,0,,将时间戳附加在消息上\Nand attach it to the message.
Dialogue: 0,0:06:36.80,0:06:44.90,Default,,0,0,0,,当B收到m_1之前 B的本地时间戳为0\NNow here, when B receives m_1, before that, the local timestamp at B will just be 0,
Dialogue: 0,0:06:44.90,0:06:48.02,Default,,0,0,0,,因为B在收到消息之前没有任何事件\Nbecause no events have happened so far at B.
Dialogue: 0,0:06:48.02,0:06:52.98,Default,,0,0,0,,但当带有时间戳2的消息到达B后\NBut when the message with timestamp 2 arrives at B,
Dialogue: 0,0:06:52.98,0:06:56.66,Default,,0,0,0,,我们将B的本地时间戳前移 再加上1\Nwe move the local timestamp forward to B, and increment it by 1 again.
Dialogue: 0,0:06:56.66,0:07:00.58,Default,,0,0,0,,这样 接收事件的时间戳就变成了3\NSo, we end up with 3 as this timestamp of the receive event.
Dialogue: 0,0:07:00.58,0:07:06.00,Default,,0,0,0,,B在本地发生了下一个事件 此事件关联的时间戳变成了4\NThen, next local event happens at B, and that gets the timestamp of 4.
Dialogue: 0,0:07:06.00,0:07:10.46,Default,,0,0,0,,时间戳4会附加在消息m_2中 并通过网络发送出去\NThat timestamp 4 gets attached to the message m_2 that's sent over the network.
Dialogue: 0,0:07:10.46,0:07:14.18,Default,,0,0,0,,节点C也一样\NAnd so, here, likewise, at node C, again,
Dialogue: 0,0:07:14.18,0:07:19.52,Default,,0,0,0,,C的本地时间戳前移为4+1 也就是5\Nthe local timestamp at C gets moved forward to 4+1, which is 5.
Dialogue: 0,0:07:19.52,0:07:21.64,Default,,0,0,0,,请注意观察几个现象\NNow, a few things to notice here.
Dialogue: 0,0:07:21.64,0:07:28.10,Default,,0,0,0,,第一个现象是 有两个不同的事件所对应的时间戳都是3\NOne is, for example, that there are two different events with the same timestamp 3,
Dialogue: 0,0:07:28.10,0:07:31.60,Default,,0,0,0,,有两个不同事件的时间戳都是1\Nand also, two different events with the timestamp 1.
Dialogue: 0,0:07:31.60,0:07:36.10,Default,,0,0,0,,我们还希望\NAnd so, one thing we might want to do is to
Dialogue: 0,0:07:36.10,0:07:40.74,Default,,0,0,0,,在整个系统中 每个事件用唯一的一个时间戳所标识\Nhave timestamps that uniquely identify events in the entire system.
Dialogue: 0,0:07:40.74,0:07:45.42,Default,,0,0,0,,具体实现方法是 将Lamport时间戳\NAnd we can do this by combining the Lamport timestamp
Dialogue: 0,0:07:45.42,0:07:49.74,Default,,0,0,0,,与此事件发生的节点名称组合在一起\Nwith the name of the node at which that particular event occurred.
Dialogue: 0,0:07:49.74,0:07:54.62,Default,,0,0,0,,举个例子 如果你查看A的事件\NSo, if we say here, for example, if you look at the events that happened at A,
Dialogue: 0,0:07:54.62,0:07:57.98,Default,,0,0,0,,在A的视角下 每个事件都包含一个唯一的时间戳\Nwithin the scope of A, each of the events has a unique timestamp,
Dialogue: 0,0:07:57.98,0:07:59.32,Default,,0,0,0,,因为我们总是会增加时间戳\Nbecause we always increment,
Dialogue: 0,0:07:59.32,0:08:03.30,Default,,0,0,0,,我们不会为同一节点的两个事件生成相同的时间戳\Nwe never generate two events at the same node with the same timestamp.
Dialogue: 0,0:08:03.30,0:08:09.28,Default,,0,0,0,,因此 对于一个特定的节点来说 每个事件的时间戳都是唯一的\NAnd so, therefore, within one particular node, each event timestamp is unique.
Dialogue: 0,0:08:09.28,0:08:15.04,Default,,0,0,0,,如果我们假定每个节点都有一个唯一的名字 如这里的A、B和C\NSo, if we assume that each node has a unique name, here like A, B and C,
Dialogue: 0,0:08:15.04,0:08:18.86,Default,,0,0,0,,我们将一个事件的Lamport时间戳\Nand we combine the Lamport timestamp of an event
Dialogue: 0,0:08:18.86,0:08:21.90,Default,,0,0,0,,和此事件发生的节点名称组合在一起\Nwith the name of the node at which that event occurred,
Dialogue: 0,0:08:21.90,0:08:26.60,Default,,0,0,0,,这两个参数的组合将会唯一标识一个特定的事件\Nthose two taken together will uniquely identify a particular event.
Dialogue: 0,0:08:26.60,0:08:29.42,Default,,0,0,0,,两者的组合就是一个唯一标识符\NThat combination is a unique identifier.
Dialogue: 0,0:08:29.42,0:08:32.52,Default,,0,0,0,,我们可以更新一下这个示意图\NSo, we could actually update this diagram here,
Dialogue: 0,0:08:32.52,0:08:34.84,Default,,0,0,0,,现在 每个事件上不仅标识了时间戳\Nand instead of just having the timestamp at each,
Dialogue: 0,0:08:34.84,0:08:37.14,Default,,0,0,0,,还标识了事件对应的节点名称\Nwe have the pair of the timestamp and the node.
Dialogue: 0,0:08:37.14,0:08:41.66,Default,,0,0,0,,我们可以看到 这个事件的标识符为(3,A) \NAnd now, we can see, here this event here has an identifier of (3,A),
Dialogue: 0,0:08:41.66,0:08:43.16,Default,,0,0,0,,这个事件的标识符为(3,B) \Nwhereas this one here is (3,B).
Dialogue: 0,0:08:43.16,0:08:47.04,Default,,0,0,0,,不同事件的标识符不再相同\NSo, they're no longer the same.
Dialogue: 0,0:08:47.04,0:08:50.64,Default,,0,0,0,,Lamport时间戳还满足一个重要的性质\NNow, there's one more thing that we can do with Lamport timestamps.
Dialogue: 0,0:08:50.64,0:08:52.64,Default,,0,0,0,,这个性质非常有用\NAnd this is extremely useful.
Dialogue: 0,0:08:52.64,0:08:56.80,Default,,0,0,0,,我们可以应用此时间戳定义事件的全序关系\NAnd that is we can define a total order using those.
Dialogue: 0,0:08:56.80,0:08:59.94,Default,,0,0,0,,假设我们有两个事件a和b\NSo, let's say we have two events a and b.
Dialogue: 0,0:08:59.94,0:09:02.82,Default,,0,0,0,,我们可以用弯曲小于号符号≺\NAnd we can define that a is less than b
Dialogue: 0,0:09:02.82,0:09:06.24,Default,,0,0,0,,定义a小于b\Naccording to this little curly less than symbol here,
Dialogue: 0,0:09:06.24,0:09:09.28,Default,,0,0,0,,a≺b当前仅当\Na≺b if and only if
Dialogue: 0,0:09:09.28,0:09:14.26,Default,,0,0,0,,a的Lamport时间戳小于b的Lamport时间戳\Nthe Lamport timestamp of a is less than the Lamport timestamp of b,
Dialogue: 0,0:09:14.26,0:09:18.14,Default,,0,0,0,,或者a和b拥有相同的Lamport时间戳\Nor if a and b have the same Lamport timestamp,
Dialogue: 0,0:09:18.14,0:09:25.26,Default,,0,0,0,,但事件a的节点名称小于事件b的节点名称\Nbut the node name of event a is less than the node name of event b.
Dialogue: 0,0:09:25.26,0:09:29.46,Default,,0,0,0,,这意味着我们假设A、B和C等节点名称是可以相互比较的\NSo, this is assuming we have some way of comparing node names like A, B and C.
Dialogue: 0,0:09:29.46,0:09:33.42,Default,,0,0,0,,我们可以按照字母表顺序比较节点名称\NWe could just have like a lexicographic comparison of those
Dialogue: 0,0:09:33.82,0:09:37.06,Default,,0,0,0,,例如 A在B之前 B在C之间\Nso that A comes before B and B comes before C, for example.
Dialogue: 0,0:09:37.06,0:09:42.52,Default,,0,0,0,,这样一来 我们就可以定义事件的顺序了\NAnd so, this now means we can define an ordering on these events
Dialogue: 0,0:09:42.52,0:09:44.78,Default,,0,0,0,,首先查看事件的Lamport时间戳\Nby first of all looking at their Lamport timestamps.
Dialogue: 0,0:09:44.78,0:09:50.80,Default,,0,0,0,,如果时间戳相同 我们用节点名称来打破相等性\Nand if the timestamps are the same, we break ties using the name of the nodes.
Dialogue: 0,0:09:50.80,0:09:54.22,Default,,0,0,0,,这一顺序定义方法称为全序关系\NAnd this ordering here is a total order.
Dialogue: 0,0:09:54.22,0:09:57.84,Default,,0,0,0,,也就是说 对于任意两个事件 如果这两个事件不相同\NThat means for any two events, if they're distinct events,
Dialogue: 0,0:09:57.84,0:10:01.82,Default,,0,0,0,,则一定满足a≺b或b≺a\Nit is always the case that either a≺b or b≺a.
Dialogue: 0,0:10:01.82,0:10:03.62,Default,,0,0,0,,这不是偏序定义\NSo, it's not a partial order.
Dialogue: 0,0:10:03.62,0:10:06.02,Default,,0,0,0,,此前发生关系是偏序的\NThe happens-before relationship was a partial order,
Dialogue: 0,0:10:06.02,0:10:08.90,Default,,0,0,0,,换句话说 在此前发生关系下 我们无法比较并发事件的相互顺序\Nin which some events are incomparable if they are concurrent.
Dialogue: 0,0:10:08.90,0:10:10.32,Default,,0,0,0,,但这是全序关系定义\NBut here, this is a total order,
Dialogue: 0,0:10:10.32,0:10:13.12,Default,,0,0,0,,对于系统中任何位置发生的任何事件\Nwhich means any event that happened anywhere in the system,
Dialogue: 0,0:10:13.12,0:10:17.26,Default,,0,0,0,,我们都可以根据此种顺序定义为事件严格排序\Nwe can always put them one after the other according to this order.
Dialogue: 0,0:10:17.26,0:10:23.76,Default,,0,0,0,,此顺序也与因果关系保持一致 也就是说 如果a→b\NAnd this order is consistent with causality, which means that if a happens before b,
Dialogue: 0,0:10:23.76,0:10:29.62,Default,,0,0,0,,则根据全序关系 一定有a≺b\Nthen it is always the case that that a≺b according to this total order.
Dialogue: 0,0:10:29.62,0:10:31.52,Default,,0,0,0,,可以直接从Lamport时间戳与因果关系保持一致\NAnd that follows directly from the fact that
Dialogue: 0,0:10:31.52,0:10:34.76,Default,,0,0,0,,推导出此顺序也与因果关系保持一致\Nthe Lamport timestamps are consistent with causality.
Dialogue: 0,0:10:34.76,0:10:37.24,Default,,0,0,0,,这就是Lamport时间戳\NSo, that's what Lamport timestamps are.
Dialogue: 0,0:10:37.24,0:10:43.92,Default,,0,0,0,,它是为系统中的事件附加时间戳的一种方法\NThey essentially give us a way of attaching timestamps to all of the events in a system
Dialogue: 0,0:10:43.92,0:10:46.54,Default,,0,0,0,,此方法可以表达此前发生关系\Nin a way that captures the happens-before relationships.
Dialogue: 0,0:10:46.54,0:10:52.06,Default,,0,0,0,,我们现在可以用事件的时间戳定义所有事件的全序关系了\NSo, we can now define this total order over the events using their timestamps.
Dialogue: 0,0:10:52.06,0:10:54.16,Default,,0,0,0,,我们利用时间戳\NSo, we can use the timestamps as a way of
Dialogue: 0,0:10:54.16,0:10:57.94,Default,,0,0,0,,标识系统中各个事件的发生顺序\Ndetecting the order of the events that happened in the system.
Dialogue: 0,0:10:57.94,0:11:01.02,Default,,0,0,0,,在“月亮是由奶酪做的”的例子中\NAnd in our example of “the moon being made of cheese”,
Dialogue: 0,0:11:01.02,0:11:02.52,Default,,0,0,0,,我们很确定\Nit would certainly be the case that
Dialogue: 0,0:11:02.52,0:11:06.50,Default,,0,0,0,,第一条消息的时间戳小于回复消息的时间戳\Nthe first message would have a lower timestamp than the reply to that message.
Dialogue: 0,0:11:06.50,0:11:09.92,Default,,0,0,0,,这就是Lamport时间戳的定义 以及Lamport时钟所能带来的保证\NThis is what Lamport timestamps, Lamport clocks guarantee.
Dialogue: 0,0:11:10.70,0:11:14.96,Default,,0,0,0,,但Lamport时钟不是完美的 它还有一些局限性\NBut there are still limitations. The Lamport clocks are not perfect.
Dialogue: 0,0:11:14.96,0:11:16.90,Default,,0,0,0,,其中一个局限性是\NOne limitation is that
Dialogue: 0,0:11:16.90,0:11:21.94,Default,,0,0,0,,如果你有两个Lamport时间戳L(a)和L(b) \Nif you're given the two Lamport timestamps L(a) and L(b),
Dialogue: 0,0:11:21.94,0:11:29.94,Default,,0,0,0,,假定L(a)<L(b) 你无法得知到底是a→b还是a‖b\Nand let's say L(a)<L(b), you can't actually tell whether a→b or if a‖b.
Dialogue: 0,0:11:29.94,0:11:35.08,Default,,0,0,0,,我们可以说不满足b→a 因为如果是这样\NWe can tell that b did not happen before a, because if that were the case,
Dialogue: 0,0:11:35.08,0:11:37.10,Default,,0,0,0,,则Lamport时间戳的大小关系应该反过来\Nthe Lamport timestamps would have to be the other way around.
Dialogue: 0,0:11:37.10,0:11:38.96,Default,,0,0,0,,我们可以得到一些信息\NSo, we can tell something,
Dialogue: 0,0:11:38.96,0:11:40.40,Default,,0,0,0,,但我们无法得知\Nbut we can't actually tell the difference
Dialogue: 0,0:11:40.40,0:11:42.04,Default,,0,0,0,,两个事件是并发的\Nbetween two events that are concurrent
Dialogue: 0,0:11:42.04,0:11:44.92,Default,,0,0,0,,还是其中一个事件在另一个事件之前发生\Nand two events where one happened before the other.
Dialogue: 0,0:11:44.92,0:11:49.26,Default,,0,0,0,,如果一个逻辑时钟方案能告知我们这一点 那可能会带来很大的帮助\NSo, it might also be useful to have a scheme of logical clocks
Dialogue: 0,0:11:49.26,0:11:51.48,Default,,0,0,0,,我们希望逻辑时钟方案可以告诉我们\Nin which it is possible to tell the difference
Dialogue: 0,0:11:51.48,0:11:53.54,Default,,0,0,0,,两个事件是并发的\Nbetween two events that are concurrent
Dialogue: 0,0:11:53.54,0:11:56.16,Default,,0,0,0,,还是其中一个事件在另一个事件之前发生\Nand two events where one happened before the other.
Dialogue: 0,0:11:56.16,0:11:58.04,Default,,0,0,0,,这就是向量时钟的作用\NAnd this is where vector clocks come in.
Dialogue: 0,0:11:58.04,0:12:01.40,Default,,0,0,0,,向量时钟是另一种逻辑时钟方案\NSo, vector clocks are a different scheme for logical time
Dialogue: 0,0:12:01.40,0:12:04.10,Default,,0,0,0,,此时钟可以区分并发和此前发生\Nthat allows us to tell this difference.
Dialogue: 0,0:12:04.10,0:12:06.80,Default,,0,0,0,,向量时钟的工作原理如下\NSo, vector clocks work as follows.
Dialogue: 0,0:12:06.80,0:12:11.54,Default,,0,0,0,,首先 我们需要假设我们知道系统中所有节点的名称\NFirst of all, we're going to assume we know the names of all of the nodes in the system.
Dialogue: 0,0:12:11.94,0:12:14.88,Default,,0,0,0,,假设系统中有n个节点\NLet's say, we have n nodes in the system.
Dialogue: 0,0:12:14.88,0:12:17.10,Default,,0,0,0,,我们将这n个名称放在一个向量中\NAnd we're just going to put them in a vector.
Dialogue: 0,0:12:17.46,0:12:19.06,Default,,0,0,0,,这是一个n维向量\NSo, this is an n-dimensional vector,
Dialogue: 0,0:12:19.06,0:12:22.76,Default,,0,0,0,,向量中的每一个元素代表了系统中的一个节点\Nwhere each of the elements of the vector is one of the nodes in the system.
Dialogue: 0,0:12:22.76,0:12:26.84,Default,,0,0,0,,我们把时间戳也定义为一个向量\NAnd we can define timestamps which are also vectors.
Dialogue: 0,0:12:26.84,0:12:34.10,Default,,0,0,0,,向量时钟的时间戳由整数序列组成\NSo, in this case, we have a timestamp here consists of a sequence of integers.
Dialogue: 0,0:12:34.58,0:12:38.12,Default,,0,0,0,,系统中的每一个节点都对应向量中的一个整数\NAnd we have one integer for every node in the system.
Dialogue: 0,0:12:38.12,0:12:42.70,Default,,0,0,0,,我们用尖括号来表示向量\NNow, this is here written using these angle brackets as vector notation.
Dialogue: 0,0:12:42.70,0:12:47.52,Default,,0,0,0,,你可以把向量看成一个列表或一个整数数组\NYou could equally well think of this as a list or an array of integers.
Dialogue: 0,0:12:48.06,0:12:54.26,Default,,0,0,0,,现在 我们不用单个整数关联每一个事件了\NAnd so, now, for every event, rather than associating a single number with it,
Dialogue: 0,0:12:54.26,0:12:57.80,Default,,0,0,0,,我们用整数向量关联每一个事件\Nwe associate this vector of numbers with each event.
Dialogue: 0,0:12:57.80,0:13:04.58,Default,,0,0,0,,整数向量的含义是 向量的第i个元素 也就是这里的t_i\NAnd the meaning of these numbers is that for the i-th entry in this vector, here t_i,
Dialogue: 0,0:13:04.58,0:13:11.62,Default,,0,0,0,,其含义是我们观察到节点N_i所发生的事件编号\Nthat is the number of events that we have observed happening on node N_i.
Dialogue: 0,0:13:11.62,0:13:15.20,Default,,0,0,0,,我们按照Lamport时间戳的方法为事件计数\NSo, we're counting events like we did in the Lamport timestamps,
Dialogue: 0,0:13:15.20,0:13:18.38,Default,,0,0,0,,但现在 我们不把所有节点的计数结果混在一个计数器里\Nbut now, rather than mixing all of the nodes together into a single counter,
Dialogue: 0,0:13:18.38,0:13:20.96,Default,,0,0,0,,我们为每一个节点的事件单独计数\Nwe actually have a separate counter for every node
Dialogue: 0,0:13:20.96,0:13:26.14,Default,,0,0,0,,每一个特定的节点都有一个特定的事件计数器\Nfor the number of events that have occurred on that particular node.
Dialogue: 0,0:13:26.14,0:13:29.60,Default,,0,0,0,,与Lamport时间戳类似\NNow, like with the Lamport timestamps,
Dialogue: 0,0:13:29.60,0:13:33.02,Default,,0,0,0,,我们为每一个事件附加一个向量时间戳\Nwe can attach a vector timestamp to every event.
Dialogue: 0,0:13:33.02,0:13:39.50,Default,,0,0,0,,我们需要按照一定的规则来更新时间戳\NAnd there are certain rules for updating these timestamps.
Dialogue: 0,0:13:39.50,0:13:43.56,Default,,0,0,0,,当我们想计算一个特定事件的时间戳时\NSo, if we want to compute the timestamp for a particular event,
Dialogue: 0,0:13:43.56,0:13:49.18,Default,,0,0,0,,我们要做的第一件事是 每当节点N_i发生了一个事件\Nthe first thing we do is every time that an event occurs at a node N_i,
Dialogue: 0,0:13:49.18,0:13:56.02,Default,,0,0,0,,我们根据节点在向量中的位置 增加向量中特定元素的计数器值\Nwe increment the particular element of that vector corresponding to that particular node.
Dialogue: 0,0:13:56.02,0:13:59.68,Default,,0,0,0,,我们这里使用了方括号\NSo, I'm going to just use these square brackets here this notation
Dialogue: 0,0:13:59.68,0:14:03.06,Default,,0,0,0,,很多编程语言也用方括号来表示数组的下标\Njust like the array subscript in many programming languages.
Dialogue: 0,0:14:03.06,0:14:10.48,Default,,0,0,0,,方括号表示数组T所对应向量的第i个元素\NIt's just a way of referring to the i-th element of this vector or this array T here.
Dialogue: 0,0:14:10.48,0:14:12.32,Default,,0,0,0,,与Lamport时间戳类似\NLike with the Lamport timestamps,
Dialogue: 0,0:14:12.32,0:14:15.66,Default,,0,0,0,,我们将向量时钟附加在消息上 并通过网络发送出去\Nwe're going to attach vector clocks to messages that get sent over the network.
Dialogue: 0,0:14:15.66,0:14:17.92,Default,,0,0,0,,我们用一个算法来合并向量时间戳\NAnd there's an algorithm for merging those.
Dialogue: 0,0:14:17.92,0:14:20.30,Default,,0,0,0,,我们现在介绍合并向量时间戳的算法\NAnd we're going to look at this algorithm now.
Dialogue: 0,0:14:20.30,0:14:25.26,Default,,0,0,0,,合并算法的起始状态与Lamport时钟的合并算法类似\NSo here, we start in a way that is somewhat similar to the Lamport clocks.
Dialogue: 0,0:14:25.26,0:14:28.94,Default,,0,0,0,,每个节点本地都有一个时间戳\NAnd that is, every node locally has a timestamp.
Dialogue: 0,0:14:28.94,0:14:31.10,Default,,0,0,0,,在向量算法中 时间戳不再是一个整数了\NIn this case, the timestamp is not just an integer,
Dialogue: 0,0:14:31.10,0:14:35.42,Default,,0,0,0,,而是一个初始值全为0的整数向量\Nbut it's a vector of integers which starts off as being all 0.
Dialogue: 0,0:14:35.42,0:14:39.28,Default,,0,0,0,,系统中的每个节点都对应此向量的一个元素\NSo, we have one entry in this vector for each node in the system.
Dialogue: 0,0:14:39.84,0:14:44.00,Default,,0,0,0,,这是一个包含n个元素的向量\NSo, this is a vector that has n elements along here.
Dialogue: 0,0:14:44.00,0:14:47.12,Default,,0,0,0,,当系统中的节点发生了一个本地事件时\NAnd every time a local event occurs somewhere in the system,
Dialogue: 0,0:14:47.12,0:14:51.44,Default,,0,0,0,,我们将根据发生事件所对应的节点\Nwe're going to increment the particular vector element
Dialogue: 0,0:14:51.44,0:14:54.62,Default,,0,0,0,,增加向量中特定位置元素的计数器值\Ncorresponding to the node at which that event occurs.
Dialogue: 0,0:14:54.62,0:15:00.64,Default,,0,0,0,,N_i处理了某个事件 则增加向量中自己位置的计数器值\NSo, N_i processes some event, it increments its own entry in the vector.
Dialogue: 0,0:15:00.64,0:15:02.96,Default,,0,0,0,,当我们想通过网络发送一条消息时\NWhen we want to send a message over the network,
Dialogue: 0,0:15:02.96,0:15:07.24,Default,,0,0,0,,我们像发生本地事件一样 增加向量中自己位置的计数器值\Nagain, we increment our own entry in the vector like for every local event.
Dialogue: 0,0:15:07.24,0:15:12.70,Default,,0,0,0,,随后 我们将向量T附加在消息上 通过网络发送出去\NAnd then, we attach the vector T to the message to get sent of the network.
Dialogue: 0,0:15:12.70,0:15:16.26,Default,,0,0,0,,现在 当我们从网络中收到其中一条消息时\NNow, when we receive one of these messages over the network,
Dialogue: 0,0:15:16.26,0:15:20.04,Default,,0,0,0,,令T'为消息中的时间戳\Nsay, T' is the timestamp in the message,
Dialogue: 0,0:15:20.04,0:15:21.58,Default,,0,0,0,,我们现在要做的是\Nnow we are going to
Dialogue: 0,0:15:21.58,0:15:30.30,Default,,0,0,0,,将接收方节点的本地时间戳T与消息中的时间戳T'合并到一起\Nmerge the recipient nodes current local time T with the timestamp in the message T'.
Dialogue: 0,0:15:30.30,0:15:32.12,Default,,0,0,0,,我们合并时间戳的方法是\NAnd the way we're going to merge those is
Dialogue: 0,0:15:32.12,0:15:35.50,Default,,0,0,0,,逐个位置合并两个向量时间戳\Nwe're going to go through the two vectors element-wise.
Dialogue: 0,0:15:35.50,0:15:42.04,Default,,0,0,0,,我们先取出T中的第一个元素和T'中的第一个元素\NAnd so, we're going to take the first element of T and the first element of T'.
Dialogue: 0,0:15:42.04,0:15:46.40,Default,,0,0,0,,我们取这两个元素的最大值 把最大值作为T的第一个元素\NI'm going to take the maximum of those two, and that becomes the first element of T.
Dialogue: 0,0:15:46.40,0:15:49.48,Default,,0,0,0,,我们再取T中的第二个元素和T'中的第二个元素\NWe're going to take the second element of T, the second element of T',
Dialogue: 0,0:15:49.48,0:15:50.64,Default,,0,0,0,,再取最大值 以此类推\Ntake the maximum, and so on.
Dialogue: 0,0:15:50.64,0:15:56.82,Default,,0,0,0,,我们逐个位置取出最大值 用最大值更新变量T\NSo, element-wise, we take the maximum, and the result is this updated variable T here.
Dialogue: 0,0:15:56.82,0:16:02.80,Default,,0,0,0,,接下来 我们增加T的本地计数器值 将消息m传递给应用\NThen, again, we increment the local entry in T and we deliver m to the application.
Dialogue: 0,0:16:02.80,0:16:06.32,Default,,0,0,0,,我们通过一个具体的例子来演示向量时钟的执行流程\NSo, let's look at an example of what this actually looks like here.
Dialogue: 0,0:16:06.32,0:16:10.08,Default,,0,0,0,,我们把向量写为\NSo, I'm going to write my vectors as being
Dialogue: 0,0:16:10.08,0:16:11.82,Default,,0,0,0,,A是向量中的第一个元素\NA is the first entry in the vector,
Dialogue: 0,0:16:11.82,0:16:13.42,Default,,0,0,0,,B是向量中的第二个元素\NB is the second entry in the vector,
Dialogue: 0,0:16:13.42,0:16:15.26,Default,,0,0,0,,C是向量中的第三个元素\Nand C is the third entry.
Dialogue: 0,0:16:15.26,0:16:18.88,Default,,0,0,0,,当A发生了第一个本地事件时\NAnd so, here, when the first local event happens at A,
Dialogue: 0,0:16:18.88,0:16:21.46,Default,,0,0,0,,这意味着A要增加向量中自己位置的计数值\Nthat means A increments its own entry in the vector.
Dialogue: 0,0:16:21.46,0:16:24.44,Default,,0,0,0,,这意味着第一个元素变为1\NSo, that means the first entry becomes 1,
Dialogue: 0,0:16:24.44,0:16:27.48,Default,,0,0,0,,向量中剩余元素取值保持不变\Nand the remaining entries in the vector remain unchanged.
Dialogue: 0,0:16:27.48,0:16:32.70,Default,,0,0,0,,当A发生了第二个本地事件时 A再增加自己位置的计数值\NOn the second event here, again, A increments its own entry.
Dialogue: 0,0:16:32.70,0:16:34.30,Default,,0,0,0,,时间戳变为<2,0,0>\NSo, this becomes <2,0,0>.
Dialogue: 0,0:16:34.30,0:16:39.36,Default,,0,0,0,,向量<2,0,0>会被附加在消息m_1上 通过网络发送输出\NAnd <2,0,0> is the vector that is attached to message m_1 as it sent over the network.
Dialogue: 0,0:16:39.36,0:16:45.42,Default,,0,0,0,,当B收到<2,0,0>时 B要逐个位置取最大值\NNow, when <2,0,0> is received by B, it does the element-wise maximum.
Dialogue: 0,0:16:45.42,0:16:47.82,Default,,0,0,0,,这意味着B的时间戳变为了<2,0,0>\NSo, that means it also ends up with <2,0,0>.
Dialogue: 0,0:16:47.82,0:16:49.68,Default,,0,0,0,,随后 B增加自己位置的计数值\NAnd then, it increments its own entry.
Dialogue: 0,0:16:49.68,0:16:52.28,Default,,0,0,0,,因为下一个事件是B执行的\NNow, because this is B executing now,
Dialogue: 0,0:16:52.28,0:16:55.74,Default,,0,0,0,,因此B增加向量时间戳中自己位置的计数值\Nit increments the second entry of the vector clock.
Dialogue: 0,0:16:55.74,0:17:02.24,Default,,0,0,0,,这个事件的时间戳最终变为了<2,1,0>\NAnd so, we end up with <2,1,0> as the timestamp of this particular event.
Dialogue: 0,0:17:02.24,0:17:07.22,Default,,0,0,0,,B下一个事件的时间戳为<2,1,0> 这同样涉及一次本地递增操作\NOn the next event by B, we have <2,2,0>, because, again, it's a local increment.
Dialogue: 0,0:17:07.22,0:17:12.00,Default,,0,0,0,,时间戳<2,2,0>会被附加在消息m_2上\N<2,2,0> is the timestamp that gets attached to message m_2
Dialogue: 0,0:17:12.00,0:17:13.78,Default,,0,0,0,,通过网络发送出去\Nas it gets sent over the network.
Dialogue: 0,0:17:13.78,0:17:17.18,Default,,0,0,0,,当C收到消息时 C同样要逐个元素取最大值\NAnd again, we have the element-wise maximum here when it gets received.
Dialogue: 0,0:17:17.64,0:17:21.14,Default,,0,0,0,,C在收到消息之前会执行一个事件\NSo, here, even though there was a previous event on C,
Dialogue: 0,0:17:21.14,0:17:26.86,Default,,0,0,0,,因为这是由C执行的事件 因此这一个事件的时间戳为<0,0,1>\Nthat previous event will have had <0,0,1>, because it's executed on node C,
Dialogue: 0,0:17:26.86,0:17:29.86,Default,,0,0,0,,也就是C要增加向量第三个位置的计数值\Nwhich is incrementing the third entry of the vector,
Dialogue: 0,0:17:29.86,0:17:34.14,Default,,0,0,0,,但随后 C要逐个位置取最大值 并增加C对应位置的计数值\Nbut then, here we do the element-wise maximum, and the increment of C's entry.
Dialogue: 0,0:17:34.14,0:17:35.68,Default,,0,0,0,,我们得到<2,2,2>\NSo, we get <2,2,2>.
Dialogue: 0,0:17:36.90,0:17:41.20,Default,,0,0,0,,我们可以这样理解这些向量\NSo, one way of thinking about these vectors here is that
Dialogue: 0,0:17:41.20,0:17:44.48,Default,,0,0,0,,每一个向量都表示一个事件集合\Na vector represents a set of events.
Dialogue: 0,0:17:44.48,0:17:52.12,Default,,0,0,0,,我们以B第二个事件的<2,2,0>为例\NAnd so, let's take for example this <2,2,0> here, the second event on B.
Dialogue: 0,0:17:52.56,0:17:54.50,Default,,0,0,0,,这个时间戳表示一个事件集合\NThis represents the set of events
Dialogue: 0,0:17:54.50,0:17:59.74,Default,,0,0,0,,事件集合定义为 此事件本身再加上所有之前发生的事件\Nwhich is this event itself plus all of the events that happened before it.
Dialogue: 0,0:17:59.74,0:18:02.20,Default,,0,0,0,,如果我们令其为事件e\NSo, if that's this event e,
Dialogue: 0,0:18:02.80,0:18:09.12,Default,,0,0,0,,则这个时间戳表示e和e之前发生的所有事件所构成的集合求并集\Nthat's the set of e union all of the events that happened before e.
Dialogue: 0,0:18:09.12,0:18:12.20,Default,,0,0,0,,在示意图中 我们可以把时间戳看成\NAnd so, visually, we can think of this in the diagram
Dialogue: 0,0:18:12.20,0:18:14.26,Default,,0,0,0,,按照时间顺序倒转\Nby traveling backwards in time
Dialogue: 0,0:18:14.26,0:18:19.40,Default,,0,0,0,,通过倒转到达所有之前发生的事件\Nand finding all of the events that we can reach through travelling backwards
Dialogue: 0,0:18:19.40,0:18:22.60,Default,,0,0,0,,倒转过程既覆盖每个节点独立执行的事件顺序\Neither on each node's individual execution order,
Dialogue: 0,0:18:22.60,0:18:27.66,Default,,0,0,0,,也覆盖接收方收到的每一条消息\Nor by going backwards from the receipt to each sending of messages.
Dialogue: 0,0:18:27.66,0:18:29.84,Default,,0,0,0,,这里的意思是 从<2,2,0>开始\NAnd so, here, that means from <2,2,0>,
Dialogue: 0,0:18:29.84,0:18:35.50,Default,,0,0,0,,我们可以回到<2,1,0> 回到<2,0,0> 回到<1,0,0>\Nwe can get back to <2,1,0>, we can get back to <2,0,0> and <1,0,0>.
Dialogue: 0,0:18:35.50,0:18:39.62,Default,,0,0,0,,我们可以从<2,2,0>倒转 到达这4个事件\NSo, we can reach these 4 events here by going backwards from <2,2,0>.
Dialogue: 0,0:18:39.62,0:18:44.50,Default,,0,0,0,,我们可以到达A的前两个事件 到达B的前两个事件\NWe can reach the first two events on A, and we can reach the first two events on B,
Dialogue: 0,0:18:44.50,0:18:48.00,Default,,0,0,0,,但我们无法从此事件倒转到C的事件\Nbut none of the events on C by going backwards from this event.
Dialogue: 0,0:18:48.00,0:18:50.58,Default,,0,0,0,,这就是此事件对应<2,2,0>的原因\NAnd that's why it has <2,2,0>.
Dialogue: 0,0:18:50.58,0:18:56.08,Default,,0,0,0,,意思是此时间戳包含A的前两个事件、B的前两个事件 不包含C的事件\NIt means the first two events on A, the first two events on B, and no events from C.
Dialogue: 0,0:18:56.08,0:18:57.90,Default,,0,0,0,,时间戳包含了事件之间的关联性\NSo, here you can see this correspondence.
Dialogue: 0,0:18:57.90,0:18:58.98,Default,,0,0,0,,时间戳和系统中的事件集合\NThere's a direct correspondence
Dialogue: 0,0:18:58.98,0:19:02.94,Default,,0,0,0,,有直接的对应关系\Nbetween these vectors and the set of events in the system.
Dialogue: 0,0:19:02.94,0:19:04.98,Default,,0,0,0,,向量时间戳\NThe vector is essentially a way of
Dialogue: 0,0:19:04.98,0:19:08.12,Default,,0,0,0,,总结了系统中已发生的全部事件\Nsummarizing a set of events that occurred in the system
Dialogue: 0,0:19:08.12,0:19:10.72,Default,,0,0,0,,时间戳记录了每个节点\Nsimply by counting for each node
Dialogue: 0,0:19:10.72,0:19:14.68,Default,,0,0,0,,从开始到现在\Nfrom the start of that node's execution of how many events
Dialogue: 0,0:19:14.68,0:19:19.16,Default,,0,0,0,,历史上所发生的全部事件\Ndown do we go in that node's history.
Dialogue: 0,0:19:19.16,0:19:22.44,Default,,0,0,0,,现在 我们定义了这些向量\NSo now, now that we've defined these vectors
Dialogue: 0,0:19:22.44,0:19:24.60,Default,,0,0,0,,并定义了计算向量的算法\Nand the algorithm for computing the vectors,
Dialogue: 0,0:19:24.60,0:19:26.92,Default,,0,0,0,,我们现在可以比较各个向量了\Nwe can now compare them.
Dialogue: 0,0:19:26.92,0:19:29.76,Default,,0,0,0,,首先 我们定义相等性\NAnd so, first of all, we're going to say that
Dialogue: 0,0:19:30.24,0:19:34.06,Default,,0,0,0,,如果每个元素都相等 则这两个向量时间戳也相等\Ntwo vector timestamps are equal if each of the elements are equal.
Dialogue: 0,0:19:34.06,0:19:43.68,Default,,0,0,0,,如果对于每一个位置i都有T[i]=T'[i] 则T=T'\NSo, T=T' if for each of the elements i, T[i]=T'[i].
Dialogue: 0,0:19:43.68,0:19:47.42,Default,,0,0,0,,相等性的定义非常直接\NAnd so, this is just a straightforward equality.
Dialogue: 0,0:19:47.42,0:19:51.56,Default,,0,0,0,,类似地 我们定义≤运算符\NAlso, similarly, we define the ≤ operator.
Dialogue: 0,0:19:51.56,0:20:00.14,Default,,0,0,0,,如果我们对比两个向量\NSo, T≤T' if we compare the two vectors,
Dialogue: 0,0:20:00.14,0:20:07.06,Default,,0,0,0,,查看T和T'的第一个元素 满足T[1]≤T'[1] \Nlook at the first element of T and the first element of T', and if that's less than or equal,
Dialogue: 0,0:20:07.06,0:20:10.88,Default,,0,0,0,,第二个元素满足T[2]≤T'[2] 第三个元素满足T[3]≤T'[3] \Nand the second one is less than or equal, and the third one is less than or equal,
Dialogue: 0,0:20:10.88,0:20:12.78,Default,,0,0,0,,如果所有位置都满足T[i]≤T'[i] \Nif all of them are less than or equal,
Dialogue: 0,0:20:12.78,0:20:17.84,Default,,0,0,0,,则我们称T≤T'\Nthen we say that that T≤T'.
Dialogue: 0,0:20:17.84,0:20:26.74,Default,,0,0,0,,我们可以把严格小于（T<T'）定义为T≤T'且T≠T'\NWe can define <, strictly less than simply as being T≤T', and then T≠T',
Dialogue: 0,0:20:26.74,0:20:30.60,Default,,0,0,0,,意思是向量中至少有一个元素不相等\Nwhich means that there must be at least one element in which they differ,
Dialogue: 0,0:20:31.06,0:20:33.76,Default,,0,0,0,,但其他所有位置的元素都满足小于等于关系\Nbut they might be the same in all of the other elements.
Dialogue: 0,0:20:33.76,0:20:40.52,Default,,0,0,0,,最后 给定两个向量时间戳T和T'\NAnd finally, it is possible that for two vector timestamps T and T',
Dialogue: 0,0:20:40.52,0:20:47.12,Default,,0,0,0,,既不满足T≤T' 也不满足T'≤T\Nneither is T≤T' nor is T'≤T,
Dialogue: 0,0:20:47.12,0:20:51.38,Default,,0,0,0,,此时 我们称T和T'是不可比较的\Nand in that case, we say that T and T' are incomparable.
Dialogue: 0,0:20:51.38,0:20:57.70,Default,,0,0,0,,现在 大家可以把此结论和我之前讲的“时间戳表示事件集合”联系到一起\NAnd now, here you can relate back to what I just said about sets of events.
Dialogue: 0,0:20:57.70,0:21:03.22,Default,,0,0,0,,我前面讲到 V(a)相当于\NSo, remember, we said that here, this V(a) here corresponds to
Dialogue: 0,0:21:03.22,0:21:08.32,Default,,0,0,0,,事件a加上a之前发生的所有事件所构成的集合\Nthe set of event a plus all of the events that happened before a.
Dialogue: 0,0:21:08.32,0:21:11.86,Default,,0,0,0,,V(b)相当于\NAnd the V(b) corresponds to
Dialogue: 0,0:21:11.86,0:21:16.94,Default,,0,0,0,,事件b加上b之前发生的所有事件所构成的集合\Nthe set of event b plus all of the events that happened before b.
Dialogue: 0,0:21:16.94,0:21:22.54,Default,,0,0,0,,向量的≤关系等价于\NAnd now, this ≤ relationship on the vectors corresponds exactly to
Dialogue: 0,0:21:22.54,0:21:26.50,Default,,0,0,0,,两个事件集合满足子集关系\Na subset relationship on those two sets of events.
Dialogue: 0,0:21:26.50,0:21:27.90,Default,,0,0,0,,这个结论很有意思\NThis is quite interesting now.
Dialogue: 0,0:21:27.90,0:21:33.72,Default,,0,0,0,,这个结论很好地体现了向量时间戳的含义\NThis gives you a nice way of reasoning about what these vectors actually mean,
Dialogue: 0,0:21:33.72,0:21:36.96,Default,,0,0,0,,因为向量时间戳相当于事件集合\Nbecause since they correspond to sets of events,
Dialogue: 0,0:21:37.68,0:21:39.64,Default,,0,0,0,,因此向量时间戳的≤关系描述了事件集合的子集关系\Nthere's a subset relationship between the two.
Dialogue: 0,0:21:39.64,0:21:42.24,Default,,0,0,0,,一个事件集合可能是另一个事件集合的子集\NAnd it might be the case that one is a subset of the other,
Dialogue: 0,0:21:42.24,0:21:45.10,Default,,0,0,0,,一个事件集合也可能不是另一个事件集合的子集\Nor it might be the case that neither is a subset of the other,
Dialogue: 0,0:21:45.10,0:21:48.70,Default,,0,0,0,,因为两个事件集合中可能存在非共有事件\Nbecause there are some elements that they don't have in common.
Dialogue: 0,0:21:48.70,0:21:54.66,Default,,0,0,0,,向量时间戳的顺序定义非常有用\NAnd so, now, this order that we have defined on these vector timestamps is very useful,
Dialogue: 0,0:21:54.66,0:21:58.04,Default,,0,0,0,,因为向量时间戳的顺序定义严格描述了此前发生关系\Nbecause it corresponds exactly to the happens-before relationship.
Dialogue: 0,0:21:58.04,0:22:00.38,Default,,0,0,0,,向量时间戳顺序是一个偏序\NSo, it gives us a partial order.
Dialogue: 0,0:22:00.38,0:22:03.50,Default,,0,0,0,,此偏序与因果关系保持一致\NAnd this partial order is consistent with causality.
Dialogue: 0,0:22:03.50,0:22:08.98,Default,,0,0,0,,首先 我们可以得出结论 给定两个事件a和b\NSo, first of all, we have the fact that given two events a and b,
Dialogue: 0,0:22:08.98,0:22:18.80,Default,,0,0,0,,根据顺序定义 V(a)<V(b)当且仅当a→b\NV(a)<V(b) according to this order above here if and only if a→b.
Dialogue: 0,0:22:18.80,0:22:23.72,Default,,0,0,0,,在Lamport时间戳中 我们只有单向蕴含关系\NSo, for the Lamport timestamps, we only had a one-way implication.
Dialogue: 0,0:22:23.72,0:22:30.82,Default,,0,0,0,,也就是说 如果a→b 则一个时间戳小于另一个时间戳\NWe had that if a→b, then one timestamp is less than the other.
Dialogue: 0,0:22:30.82,0:22:35.16,Default,,0,0,0,,但在向量时间戳中 我们得到了当且仅当关系\NBut with vector clocks, we have an if-and-only-if relationship.
Dialogue: 0,0:22:35.16,0:22:37.72,Default,,0,0,0,,这是一个双向蕴含关系\NIt's a bi-directional implication.
Dialogue: 0,0:22:37.72,0:22:41.38,Default,,0,0,0,,给定两个时间戳 我们可以得出结论\NSo, we can also conclude that looking at two timestamps,
Dialogue: 0,0:22:41.38,0:22:47.00,Default,,0,0,0,,如果一个时间戳小于另一个时间戳 那么一定有a→b\Nif one is less than the other, then we know that a→b.
Dialogue: 0,0:22:47.88,0:22:51.50,Default,,0,0,0,,时间戳也唯一标识了事件\NIt's also the case that the timestamps uniquely identify events.
Dialogue: 0,0:22:51.50,0:22:55.64,Default,,0,0,0,,如果两个事件拥有相同的向量时间戳\NSo, if two events have the same vector timestamps,
Dialogue: 0,0:22:55.64,0:22:57.68,Default,,0,0,0,,则这些事件都是相同的事件\Nthat means that those events are the same.
Dialogue: 0,0:22:57.68,0:23:03.26,Default,,0,0,0,,这也是一个双向蕴含关系 是一个当且仅当关系\NAnd so, this is again a bi-directional implication. it's an if-and-only-if.
Dialogue: 0,0:23:03.26,0:23:09.02,Default,,0,0,0,,最后 如果按照上述定义 两个时间戳不可比较\NAnd finally, if the two timestamps are incomparable according to the definition up here,
Dialogue: 0,0:23:09.02,0:23:11.76,Default,,0,0,0,,这意味着两个事件是并发的\Nthat means that the two events are concurrent.
Dialogue: 0,0:23:11.76,0:23:15.74,Default,,0,0,0,,如果两个事件是并发的 则它们的时间戳也不可比较\NAnd if the two events are concurrent, then their timestamps will be incomparable.
Dialogue: 0,0:23:15.74,0:23:19.44,Default,,0,0,0,,通过使用向量时钟\NSo, what we now have here using vector clocks
Dialogue: 0,0:23:19.44,0:23:22.66,Default,,0,0,0,,我们得到了一种计算此前发生关系的方法\Nis a way of computing the happens-before relationship.
Dialogue: 0,0:23:22.66,0:23:27.16,Default,,0,0,0,,在这之间 此前发生关系只是一个抽象的定义\NSo far, the happens-before relation has been essentially this abstract definition.
Dialogue: 0,0:23:27.16,0:23:30.28,Default,,0,0,0,,我们可以通过查看事件示意图\NBy looking at the diagram of the events on paper,
Dialogue: 0,0:23:30.28,0:23:33.30,Default,,0,0,0,,指出哪些事件在其他事件之前发生\Nwe can work out what thing happened before which other thing,
Dialogue: 0,0:23:33.30,0:23:35.46,Default,,0,0,0,,但这不是一种算法描述\Nbut that's not an algorithm for computing it,
Dialogue: 0,0:23:35.46,0:23:37.06,Default,,0,0,0,,有了向量时钟后\Nwhereas here with vector clocks,
Dialogue: 0,0:23:37.06,0:23:39.18,Default,,0,0,0,,我们得到了一个算法\Nwe actually have an algorithm
Dialogue: 0,0:23:39.18,0:23:42.60,Default,,0,0,0,,应用此算法可以严格计算出哪些事件在其他事件之前发生\Nfor computing exactly which event happened before which other event.
Dialogue: 0,0:23:42.60,0:23:47.42,Default,,0,0,0,,我们也能计算出两个事件是否是并发的\NAnd we have a way of telling whether two events are concurrent or not.
Dialogue: 0,0:23:47.42,0:23:51.18,Default,,0,0,0,,这就是与Lamport时钟相比\NSo, this is the really interesting thing about vector clocks
Dialogue: 0,0:23:51.18,0:23:53.66,Default,,0,0,0,,向量时钟所满足的有趣性质\Nthat Lamport clocks do not have.
Dialogue: 0,0:23:53.66,0:23:54.56,Default,,0,0,0,,这就是本小节\NSo, these have been
Dialogue: 0,0:23:54.56,0:24:00.14,Default,,0,0,0,,我们要学习的两种逻辑时钟\Nthe two types of logical time that we're going to look at in this section.
