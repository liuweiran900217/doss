[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 7.2_Linearizability.mp4
Video File: 7.2_Linearizability.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 203
Active Line: 222
Video Position: 25785

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.88,0:00:06.44,Default,,0,0,0,,我现在想和大家讨论的是线性一致性模型\NI would now like to talk about a consistency model called linearizability.
Dialogue: 0,0:00:06.44,0:00:11.04,Default,,0,0,0,,我们前面看到的两阶段提交和原子提交\NSo, what we've seen so far with two-phase commit and atomic commitment is
Dialogue: 0,0:00:11.04,0:00:13.50,Default,,0,0,0,,都是面对崩溃的一致性保证\Nensuring consistency in the face of crashes.
Dialogue: 0,0:00:13.50,0:00:15.86,Default,,0,0,0,,这些协议保证即使有节点崩溃\NSo, ensuring that even if nodes crash,
Dialogue: 0,0:00:15.86,0:00:18.60,Default,,0,0,0,,所有节点都会一起提交或中止一个事务\Nall of the nodes will either commit or abort a transaction.
Dialogue: 0,0:00:18.60,0:00:22.44,Default,,0,0,0,,我们在面对并发时也会考虑一致性问题\NBut we also have to worry about consistency in the face of concurrency.
Dialogue: 0,0:00:22.44,0:00:26.58,Default,,0,0,0,,如果多个节点并发读取或写入一些数据\NSo, what if multiple nodes are concurrently reading and writing some data,
Dialogue: 0,0:00:26.58,0:00:30.22,Default,,0,0,0,,我们如何使这些操作互相之间\Nhow do we ensure those operations are consistent with each other
Dialogue: 0,0:00:30.22,0:00:32.40,Default,,0,0,0,,满足某种定义下的一致性保证\Nfor some definition of consistency.
Dialogue: 0,0:00:32.40,0:00:34.56,Default,,0,0,0,,这就是线性一致性的含义\NAnd this is what linearizability is about.
Dialogue: 0,0:00:34.56,0:00:39.04,Default,,0,0,0,,线性一致性是一个专门面向并发系统的一致性定义\NSo, it's one particular definition of consistency for concurrent systems.
Dialogue: 0,0:00:39.04,0:00:44.42,Default,,0,0,0,,是目前被广泛使用的最强一致性模型\NAnd it is the strongest such model that is in widespread use.
Dialogue: 0,0:00:44.42,0:00:48.08,Default,,0,0,0,,线性一致性背后的基本思想是\NAnd the idea behind linearizability is that
Dialogue: 0,0:00:48.08,0:00:52.72,Default,,0,0,0,,系统作为一个整体 其行为看起来好像不是一个复制系统或分布式系统\Nthe system as a whole behaves as if it was not replicated or distributed at all.
Dialogue: 0,0:00:52.72,0:00:57.08,Default,,0,0,0,,系统看起来好像只有一份数据拷贝\NSo, it behaves as if there was actually only a single copy of the data,
Dialogue: 0,0:00:57.08,0:01:01.28,Default,,0,0,0,,且对于这份数据拷贝的所有操作都是原子性的\Nand all of the operations happen atomically on that single copy of the data.
Dialogue: 0,0:01:01.28,0:01:05.50,Default,,0,0,0,,当你提交一个读或写操作时\NSo, when you issue a read or write operation,
Dialogue: 0,0:01:05.50,0:01:10.50,Default,,0,0,0,,此操作将在某个时刻在满足原子性要求的条件下生效\Nthat operation will take effect atomically at some point in time.
Dialogue: 0,0:01:10.50,0:01:14.66,Default,,0,0,0,,即使系统存在多个副本\NAnd even though there might be multiple replicas in the system,
Dialogue: 0,0:01:14.66,0:01:16.20,Default,,0,0,0,,但站在客户端的角度看\Nfrom the point of view of the clients,
Dialogue: 0,0:01:16.20,0:01:19.54,Default,,0,0,0,,系统好像只有一份数据拷贝\Nit looks as though there was only a single copy of the data.
Dialogue: 0,0:01:19.54,0:01:22.42,Default,,0,0,0,,这个定义非常友好 很容易面向这一定义来实现系统\NSo, this is very nice, because it's easy to program against,
Dialogue: 0,0:01:22.42,0:01:27.12,Default,,0,0,0,,这个定义把分布式系统的所有复杂性\Nbecause it kind of reduces the all of the distributed systems complexity
Dialogue: 0,0:01:27.12,0:01:30.90,Default,,0,0,0,,归约到一个非常漂亮、描述简单、易于理解的定义\Ndown to something which is very nice and manageable and small,
Dialogue: 0,0:01:30.90,0:01:33.34,Default,,0,0,0,,即系统好像只有一份数据拷贝\Nlike a single copy of the data.
Dialogue: 0,0:01:33.98,0:01:38.36,Default,,0,0,0,,线性一致性定义的效果是\NA consequence of this definition of linearizability is that
Dialogue: 0,0:01:38.36,0:01:42.40,Default,,0,0,0,,当你读取某个数据时 系统会保证你得到的一定是最新的值\Nwhenever you read some data, you're guaranteed to get an up-to-date value
Dialogue: 0,0:01:42.40,0:01:45.68,Default,,0,0,0,,我们稍后就会看到如何定义最新的值\Nfor some definition of up-to-date that we will see in a moment.
Dialogue: 0,0:01:46.10,0:01:49.28,Default,,0,0,0,,有时也把这一性质称为强一致性\NAnd this is sometimes also called strong consistency.
Dialogue: 0,0:01:49.28,0:01:54.42,Default,,0,0,0,,但强一致性这个术语的定义有点模糊、也有点混乱\NBut the term strong consistency is a bit poorly defined. It's a bit vague and hand-wavy.
Dialogue: 0,0:01:54.42,0:01:58.58,Default,,0,0,0,,我们主要考虑线性一致性 这是一致性的一种形式化定义\NSo, we're going to stick with linearizability, which is formally defined.
Dialogue: 0,0:01:58.58,0:02:02.14,Default,,0,0,0,,我们在本课程中不会详细讨论线性一致性的形式化定义\NWe will not go into the exact formal definition in this course.
Dialogue: 0,0:02:02.14,0:02:06.80,Default,,0,0,0,,我只会通过一些例子向大家介绍线性一致性的直观思想\NI'm just going to give you the intuition behind linearizability through some examples.
Dialogue: 0,0:02:07.74,0:02:11.90,Default,,0,0,0,,有趣的是 线性一致性不仅对于分布式系统来说非常重要\NInterestingly, linearizability is not only important in distributed systems,
Dialogue: 0,0:02:11.90,0:02:14.58,Default,,0,0,0,,单计算机下的共享内存并发操作\Nbut it actually is used also in the context of
Dialogue: 0,0:02:14.58,0:02:17.42,Default,,0,0,0,,也会用到线性一致性\Nshared-memory concurrency on a single computer.
Dialogue: 0,0:02:17.42,0:02:21.10,Default,,0,0,0,,原因在于 如果你有多个CPU核\NAnd the reason there is that if you have multiple CPU cores,
Dialogue: 0,0:02:21.10,0:02:25.84,Default,,0,0,0,,每个CPU核都会有自己的缓存\Nthen actually each CPU core has its own memory caches.
Dialogue: 0,0:02:25.84,0:02:28.76,Default,,0,0,0,,如果线程在两个不同的CPU核下运行\NAnd if you have threads running on two different CPU cores,
Dialogue: 0,0:02:28.76,0:02:33.18,Default,,0,0,0,,可能有一个线程会将数据写入内存 此时写入数据会从CPU的缓存中写入\Nyou might have one thread writing a value to memory, which actually goes to its cache,
Dialogue: 0,0:02:33.18,0:02:37.48,Default,,0,0,0,,随后 另一个线程正在读取内存相同位置下的数据\Nand then, a different thread reading that same location in memory,
Dialogue: 0,0:02:37.48,0:02:40.54,Default,,0,0,0,,这个线程此时可能无法看到第一个线程写入的数据\Nand it might not see the value that was written by the first thread,
Dialogue: 0,0:02:40.54,0:02:43.66,Default,,0,0,0,,因为这个线程的CPU缓存还没有更新这个数据的值\Nbecause its cache hasn't yet been updated with that value.
Dialogue: 0,0:02:43.66,0:02:48.00,Default,,0,0,0,,因此 即使只考虑单计算机\NAnd so, within the scope of a single computer,
Dialogue: 0,0:02:48.00,0:02:51.26,Default,,0,0,0,,单计算机也可能会出现与复制系统类似的行为\Nyou get this similar kind of behavior as in a replicated system,
Dialogue: 0,0:02:51.26,0:02:57.58,Default,,0,0,0,,因为不同级别缓存之间的行为与复制系统有些类似\Nbecause these different levels of caches give you something quite like replication.
Dialogue: 0,0:02:58.16,0:03:03.70,Default,,0,0,0,,这很有趣 因为线性一致性是分布式系统中的思想\NI think this is interesting, because we're taking now this idea from distributed systems,
Dialogue: 0,0:03:03.70,0:03:08.88,Default,,0,0,0,,而单计算机的行为也开始和分布式系统有些相似了\Nand a single computer starts actually behaving a little bit like a distributed system too.
Dialogue: 0,0:03:08.88,0:03:12.64,Default,,0,0,0,,另一个需要注意的术语是\NAnother piece of terminology just to be careful of is
Dialogue: 0,0:03:12.92,0:03:16.30,Default,,0,0,0,,线性一致性和可串行化是两个不同的概念\Nlinearizability and serializability are not the same thing.
Dialogue: 0,0:03:16.30,0:03:20.80,Default,,0,0,0,,虽然这两个概念对应的英文单词看起来有点像 但它们的含义完全不同\NEven though the words look kind of similar, but they mean totally different things.
Dialogue: 0,0:03:20.80,0:03:25.00,Default,,0,0,0,,可串行化指的是事务之间的一种隔离形式\NSo, serializability is a form of isolation between transactions.
Dialogue: 0,0:03:25.00,0:03:27.86,Default,,0,0,0,,可串行化指的是 事务的执行效果\NIt's about transactions having the same effect
Dialogue: 0,0:03:27.86,0:03:30.26,Default,,0,0,0,,就像是在按照某种顺序串行执行\Nas if they were executed in some serial order.
Dialogue: 0,0:03:30.26,0:03:36.44,Default,,0,0,0,,线性一致性指的是多个副本的行为看起来好像只存在单一副本一样\NLinearizability is around multiple replicas behaving as if there was a single replica.
Dialogue: 0,0:03:36.44,0:03:38.34,Default,,0,0,0,,因此 这是完全不同的两个概念\NSo, they're very different things.
Dialogue: 0,0:03:38.34,0:03:43.10,Default,,0,0,0,,为了让大家体会到线性一致性究竟是什么意思\NOK, so, in order to give you a sense of what linearizability means,
Dialogue: 0,0:03:43.10,0:03:45.92,Default,,0,0,0,,我们要回顾之前课程中介绍过的一个概念\NI'm going to go back to something we saw in a previous lecture,
Dialogue: 0,0:03:45.92,0:03:48.04,Default,,0,0,0,,即写后读一致性\Nwhich is read-after-write consistency.
Dialogue: 0,0:03:48.04,0:03:50.62,Default,,0,0,0,,回顾一下我们之前讨论过的知识点\NSo, if you remember what we discussed back then,
Dialogue: 0,0:03:51.08,0:03:53.84,Default,,0,0,0,,写后读一致性是在读写quorum的上下文中定义的\Nthis was in the context of read and write quorums.
Dialogue: 0,0:03:53.84,0:04:01.44,Default,,0,0,0,,如果你有一个客户端 它想向某个对象x中写入某个值v_1\NSo, if you have a client that wants to write some value v_1 to some object x,
Dialogue: 0,0:04:01.44,0:04:04.80,Default,,0,0,0,,它可以把写入请求发送给quorum副本\Nit can make this write request to a quorum of replicas.
Dialogue: 0,0:04:04.80,0:04:09.98,Default,,0,0,0,,如果quorum返回OK 则set（设置）请求执行成功\NIf a quorum responds OK, then this set request is successful.
Dialogue: 0,0:04:09.98,0:04:13.70,Default,,0,0,0,,随后 相同的客户端想执行一次get（获得）请求\NAnd then, subsequently, that same client might make a get requests,
Dialogue: 0,0:04:13.70,0:04:19.64,Default,,0,0,0,,它将get请求发送给quorum副本 得到一些响应\Nand send that get request to a quorum of replicas, get some responses back,
Dialogue: 0,0:04:19.64,0:04:23.64,Default,,0,0,0,,它使用时间戳来判断请求中的哪个值是最新值\Nuse the timestamps to figure out which is the more recent value in the responses,
Dialogue: 0,0:04:23.64,0:04:26.34,Default,,0,0,0,,并让get请求返回这个最新值\Nand return that value from the get request.
Dialogue: 0,0:04:26.34,0:04:29.62,Default,,0,0,0,,我这里引入了一个新的表示符号\NSo, what is new here in this notation is now
Dialogue: 0,0:04:29.62,0:04:34.72,Default,,0,0,0,,这些方块表示执行特定操作的持续时间\NI've got these boxes which indicate the execution time of this particular operation.
Dialogue: 0,0:04:34.72,0:04:39.22,Default,,0,0,0,,当操作开始时 我们先发送出这些请求\NSo, when the operation begins, we start by sending out these requests.
Dialogue: 0,0:04:39.22,0:04:41.92,Default,,0,0,0,,当收到quorum响应后\NAnd then after a quorum of responses have been received,
Dialogue: 0,0:04:41.92,0:04:44.82,Default,,0,0,0,,我们宣布操作完成\Nwe declare the operation to be finished.
Dialogue: 0,0:04:44.82,0:04:46.76,Default,,0,0,0,,因此 这些方块\NSo, the box here, this rectangle
Dialogue: 0,0:04:46.76,0:04:51.82,Default,,0,0,0,,表示客户端视角下操作的持续时间\Nshows the duration of the operation from the client's point of view.
Dialogue: 0,0:04:51.82,0:04:54.92,Default,,0,0,0,,现在 我们可以抽象具体的处理过程\NNow, we can actually abstract away
Dialogue: 0,0:04:54.92,0:04:58.68,Default,,0,0,0,,忽略所有的内部状态、所有的通信消息、以及所有的副本\Nall of the internals, and this message communication, and all of the replicas.
Dialogue: 0,0:04:58.68,0:05:03.98,Default,,0,0,0,,我们可以只根据客户端看到的内容来定义一致性模型\NAnd we can define a consistency model purely in terms of what the client sees,
Dialogue: 0,0:05:03.98,0:05:06.58,Default,,0,0,0,,也就是说 只站在客户端的视角来定义一致性模型\Nso, looking at things only from the client's point of view.
Dialogue: 0,0:05:06.58,0:05:10.42,Default,,0,0,0,,这会带来很大的帮助 因为这意味着我们的一致性模型\NAnd this is useful, because it means our consistency model
Dialogue: 0,0:05:10.42,0:05:13.58,Default,,0,0,0,,不与系统的任何特定实现相绑定\Nis now not tied to one particular implementation of a system,
Dialogue: 0,0:05:13.58,0:05:15.64,Default,,0,0,0,,不与任何特定的分布式算法相绑定\Nor one particular distributed algorithm.
Dialogue: 0,0:05:15.64,0:05:19.28,Default,,0,0,0,,我们可以只站在客户端的视角来定义行为\NWe can define the behavior only from the client's point of view,
Dialogue: 0,0:05:19.28,0:05:23.86,Default,,0,0,0,,不考虑系统的内部是如何实现的\Nregardless of how the internals of this system are implemented.
Dialogue: 0,0:05:23.86,0:05:26.06,Default,,0,0,0,,每个操作内部\NAnd so, within the execution of each operation,
Dialogue: 0,0:05:26.06,0:05:28.16,Default,,0,0,0,,可能会涉及多个消息的发送和接收过程\Nthere might be multiple messages sent and received.
Dialogue: 0,0:05:28.16,0:05:31.82,Default,,0,0,0,,我们并不关心这些消息到底是什么\NAnd we don't care particularly what those messages are exactly.
Dialogue: 0,0:05:31.82,0:05:35.22,Default,,0,0,0,,我们真正关心的是\NWhat we do care about here is that
Dialogue: 0,0:05:35.22,0:05:40.36,Default,,0,0,0,,set操作完成后的get操作\Nthis get operation here started after the set operation finished.
Dialogue: 0,0:05:40.36,0:05:42.72,Default,,0,0,0,,这两个操作存在时间依赖关系\NSo, there's this time dependence here
Dialogue: 0,0:05:42.72,0:05:47.16,Default,,0,0,0,,即get操作会在set操作之后发生\Nthat the get operation happened later in time than the set operation.
Dialogue: 0,0:05:47.16,0:05:51.92,Default,,0,0,0,,因此 我们期望get操作看到的x的值\NAnd therefore, we would expect the get operation to see a value of x
Dialogue: 0,0:05:51.92,0:05:57.28,Default,,0,0,0,,要至少等于最近一次set操作所设置的值\Nthat is at least as recent as the value that was written by the previous set operation.
Dialogue: 0,0:05:57.28,0:05:59.88,Default,,0,0,0,,我们可以把这一时间依赖关系泛化\NAnd we can generalize this timing dependency
Dialogue: 0,0:05:59.88,0:06:03.80,Default,,0,0,0,,不仅考虑一个客户端节点 而是考虑多个客户端节点\Nto be not just on a single node, but actually across multiple nodes.
Dialogue: 0,0:06:03.80,0:06:07.22,Default,,0,0,0,,这里我们有了客户端2\NSo, we could have the client 2 here,
Dialogue: 0,0:06:07.22,0:06:09.34,Default,,0,0,0,,客户端2\Nwhich starts a get operation
Dialogue: 0,0:06:09.34,0:06:14.52,Default,,0,0,0,,在另一个不同的客户端执行set操作后的某一时刻开始了get操作\Nsometime later in time after the set operation by a different client has completed.
Dialogue: 0,0:06:14.52,0:06:17.36,Default,,0,0,0,,这里同样存在实时依赖关系\NAnd again, we have this real-time dependency here.
Dialogue: 0,0:06:17.36,0:06:21.22,Default,,0,0,0,,在线性一致性下 我们期望\NSo, under linearizability, we expect that
Dialogue: 0,0:06:21.22,0:06:25.44,Default,,0,0,0,,客户端2也可以看到最新的v_1\Nthis client 2 will also see the up-to-date value v_1,
Dialogue: 0,0:06:25.78,0:06:29.94,Default,,0,0,0,,因为当我们只有单个数据拷贝时 所有操作都满足原子性\Nbecause that's the behavior we would get if we have a single copy of the data
Dialogue: 0,0:06:29.94,0:06:32.46,Default,,0,0,0,,我们就应该能得到最新的值\Non which all of the operations are atomic.
Dialogue: 0,0:06:32.46,0:06:37.56,Default,,0,0,0,,这里的时间依赖关系看起来有点像此前发生关系\NNow, this timing dependency here, it looks like the happens-before relationship,
Dialogue: 0,0:06:37.56,0:06:42.56,Default,,0,0,0,,但时间依赖关系与我们在前面课程中讨论的此前发生关系并不一样\Nbut it is not the same as happens-before as we discussed in previous lectures.
Dialogue: 0,0:06:42.56,0:06:46.10,Default,,0,0,0,,回忆一下 我们是在消息发送和接收的场景下\NSo, if you remember, the way happens-before is defined is
Dialogue: 0,0:06:46.10,0:06:48.66,Default,,0,0,0,,定义的此前发生关系\Nit's defined in terms of sending and receiving messages.
Dialogue: 0,0:06:48.66,0:06:53.22,Default,,0,0,0,,如果在消息发送和接收图中存在某个路径\NSo, if there is some path through our message send and receive graph
Dialogue: 0,0:06:53.22,0:06:55.86,Default,,0,0,0,,使得你可以从一个事件流转到另一个事件\Nso that you can get from one event to the other event,
Dialogue: 0,0:06:55.86,0:06:58.66,Default,,0,0,0,,则我们称一个事件在另一个事件之前发生\Nthen we have that one event happens before the other event.
Dialogue: 0,0:06:58.66,0:07:01.70,Default,,0,0,0,,此前发生关系并不是在实时场景下定义的\NSo, happens-before is not defined in terms of real-time,
Dialogue: 0,0:07:01.70,0:07:04.26,Default,,0,0,0,,而是在消息发送和接收的场景下定义的\Nit's defined in terms of message sending and receiving,
Dialogue: 0,0:07:04.26,0:07:09.32,Default,,0,0,0,,而线性一致性是在实时场景下定义的\Nwhereas linearizability is defined in terms of real-time.
Dialogue: 0,0:07:09.32,0:07:13.30,Default,,0,0,0,,我们假设存在某个假想的观察者\NSo, we are assuming if there is some hypothetical observer
Dialogue: 0,0:07:13.30,0:07:18.26,Default,,0,0,0,,观察者可以看到操作何时结束、操作何时开始\Nwho can see exactly when which operation finished and when which operation started,
Dialogue: 0,0:07:18.26,0:07:20.14,Default,,0,0,0,,观察者可以告诉我们\Nthis observer can tell us
Dialogue: 0,0:07:20.14,0:07:24.18,Default,,0,0,0,,某个特定的操作是否在另一个操作之后发生\Nwhether a certain operation started after another operation finished.
Dialogue: 0,0:07:24.18,0:07:29.64,Default,,0,0,0,,如果在之后发生 那么此操作就应该能观察到最新的状态\NAnd therefore, it should be able to observe its up-to-date state.
Dialogue: 0,0:07:29.64,0:07:33.04,Default,,0,0,0,,即使节点之间没有相互通信 此种时间依赖关系仍然存在\NAnd we have that dependency even if those nodes did not communicate.
Dialogue: 0,0:07:33.04,0:07:37.12,Default,,0,0,0,,即使客户端1没有给客户端2发送任何消息\NSo, even here, client 1 might not send a message to client 2 at all,
Dialogue: 0,0:07:37.12,0:07:41.66,Default,,0,0,0,,两个操作之间仍然存在实时时间依赖关系\Nbut nevertheless, we have this real-time timing dependency between the two operations,
Dialogue: 0,0:07:41.66,0:07:44.04,Default,,0,0,0,,因为客户端2的操作\Nbecause this operation by client 2
Dialogue: 0,0:07:44.04,0:07:48.00,Default,,0,0,0,,一定发生在客户端1的操作之后\Ndefinitely happened later in time than client 1’s operation.
Dialogue: 0,0:07:48.00,0:07:51.68,Default,,0,0,0,,另一方面 如果两个操作的发生时间存在重叠\NOn the other hand, if the two operations overlap in real time,
Dialogue: 0,0:07:51.68,0:07:54.08,Default,,0,0,0,,则两个操作的可以按照任意顺序生效\Nthen they can take effect in either order.
Dialogue: 0,0:07:54.08,0:07:55.68,Default,,0,0,0,,举例来说 在图中所示的情况下\NSo, in this case, here for example,
Dialogue: 0,0:07:55.68,0:07:58.58,Default,,0,0,0,,首先 set操作生效\Nwe might have the set operation taking effect first,
Dialogue: 0,0:07:58.58,0:08:00.72,Default,,0,0,0,,随后 get操作生效\Nand then, the get operation taking effect second,
Dialogue: 0,0:08:00.72,0:08:04.60,Default,,0,0,0,,这种情况下 get操作将返回v_1\Nin which case, the get operation will return the value v_1.
Dialogue: 0,0:08:04.60,0:08:06.98,Default,,0,0,0,,但也有可能反过来\NBut it could just as well be the other way round.
Dialogue: 0,0:08:06.98,0:08:11.90,Default,,0,0,0,,也可能是get操作先生效 set操作后生效\NSo, it could be that the get operation takes effect first, the set operation second,
Dialogue: 0,0:08:11.90,0:08:17.02,Default,,0,0,0,,这两种行为都满足线性一致性\Nand both of these two behaviors are absolutely fine under linearizability,
Dialogue: 0,0:08:17.02,0:08:19.80,Default,,0,0,0,,因为线性一致性只是说\Nso, because linearizability just says that
Dialogue: 0,0:08:19.80,0:08:22.32,Default,,0,0,0,,操作生效的时间\Nthe time when an operation takes effect
Dialogue: 0,0:08:22.32,0:08:26.40,Default,,0,0,0,,一定在操作开始后和操作结束前之间的某一时刻\Nmust be some time after it started and before the operation finished.
Dialogue: 0,0:08:26.40,0:08:30.40,Default,,0,0,0,,也就是说 操作会在方块之间的某个位置\NSo, somewhere within this rectangle has to be the moment in time
Dialogue: 0,0:08:30.40,0:08:33.04,Default,,0,0,0,,在满足原子性的条件下生效\Nwhen the operation takes effect atomically,
Dialogue: 0,0:08:33.04,0:08:36.10,Default,,0,0,0,,但我们不知道生效时间具体在方块中的哪个位置\Nbut we don't know where exactly within this rectangle,
Dialogue: 0,0:08:36.10,0:08:39.28,Default,,0,0,0,,因为我们无法准确知道网络的延时情况\Nbecause we don't know what the exact network latency is going to be.
Dialogue: 0,0:08:39.28,0:08:43.70,Default,,0,0,0,,在两个操作发生时间存在重叠的情况下\NAnd so, in this particular case, where two operations overlap in time,
Dialogue: 0,0:08:43.70,0:08:45.36,Default,,0,0,0,,操作可以按照任意顺序生效\Nthey can be ordered either way.
Dialogue: 0,0:08:45.36,0:08:50.80,Default,,0,0,0,,但如果操作发生时间不存在重叠 一个操作在另一个操作开始前就结束了\NBut if they do not overlap in time, so one operation finished before the other one started,
Dialogue: 0,0:08:50.80,0:08:53.90,Default,,0,0,0,,则在线性一致性下我们要求操作满足时间依赖关系\Nthen we have this timing dependency under linearizability
Dialogue: 0,0:08:53.90,0:08:56.76,Default,,0,0,0,,从而告诉我们读取到的值必须是什么\Nthat tells us what value we must read.
Dialogue: 0,0:08:56.76,0:09:00.00,Default,,0,0,0,,我们讨论过读后写一致性\NSo, we talked about read-after-write consistency,
Dialogue: 0,0:09:00.00,0:09:04.36,Default,,0,0,0,,可以通过quorum写和quorum读来保证读后写一致性\Nand that is ensured using quorum writes and quorum reads.
Dialogue: 0,0:09:04.36,0:09:05.60,Default,,0,0,0,,你可能会问\NAnd you might wonder
Dialogue: 0,0:09:05.60,0:09:10.76,Default,,0,0,0,,使用quorum读和quorum写是否就足以保证系统满足线性一致性了\Nif those quorum reads and writes are sufficient in order to ensure linearizability.
Dialogue: 0,0:09:10.76,0:09:13.98,Default,,0,0,0,,有趣的是 答案是否定的\NAnd the answer is no, interestingly.
Dialogue: 0,0:09:13.98,0:09:20.18,Default,,0,0,0,,只使用quorum读和quorum写无法保证系统满足线性一致性\NIt is not sufficient to ensure a linearizability just to have these quorum reads and writes.
Dialogue: 0,0:09:20.18,0:09:23.62,Default,,0,0,0,,我将通过一个例子来为大家讲解为什么无法保证线性一致性\NAnd I'm going to show you with an example why that is the case.
Dialogue: 0,0:09:23.62,0:09:28.86,Default,,0,0,0,,在这个例子中 客户端1先有了一个set操作\NSo, in this example, here we have first of all a set operation by client 1.
Dialogue: 0,0:09:28.86,0:09:33.40,Default,,0,0,0,,和前面一样 客户端1想要把x的值设置为v_1\NSo, as before, client 1 wants to set the value of x to be v_1.
Dialogue: 0,0:09:33.40,0:09:38.50,Default,,0,0,0,,因此 它将set请求发送给所有三个副本\NAnd so, it sends this set request to all three of the replicas.
Dialogue: 0,0:09:38.50,0:09:41.38,Default,,0,0,0,,我们这里假设 由于某种原因\NAnd let's just assume for now that for some reason,
Dialogue: 0,0:09:41.38,0:09:44.84,Default,,0,0,0,,发送给副本A的请求很快就传输成功了\Nthe request to replica A goes through very quickly,
Dialogue: 0,0:09:44.84,0:09:48.62,Default,,0,0,0,,但向B和C通信时 网络出现了延迟\Nbut there's a network delay in communicating that request to B and C.
Dialogue: 0,0:09:48.62,0:09:52.26,Default,,0,0,0,,虽然B和C最终仍然能够得到更新的值v_1\NSo, eventually, B and C will get updated with the value v_1,
Dialogue: 0,0:09:52.26,0:09:56.46,Default,,0,0,0,,但目前只有副本A可以看到v_1\Nbut right now, only replica A can see the value v_1,
Dialogue: 0,0:09:56.46,0:10:00.94,Default,,0,0,0,,因为网络出现了延迟\Njust because of the way the network happened to time things.
Dialogue: 0,0:10:00.94,0:10:04.76,Default,,0,0,0,,现在 客户端2开始提交get请求\NNow, client 2 starts and makes a get request.
Dialogue: 0,0:10:04.76,0:10:07.78,Default,,0,0,0,,它向quorum请求x的值\NAnd it requests the value of x from a quorum.
Dialogue: 0,0:10:07.78,0:10:12.02,Default,,0,0,0,,它从包含副本A和B的quorum得到响应\NIt gets a response from a quorum consisting of replicas A and B.
Dialogue: 0,0:10:12.02,0:10:15.02,Default,,0,0,0,,它像往常一样比较时间戳\NAnd it's going to compare the timestamps as usual.
Dialogue: 0,0:10:15.02,0:10:17.44,Default,,0,0,0,,它会看到最新的值是v_1\NAnd it's going to see that v_1 is the more up-to-date value.
Dialogue: 0,0:10:17.44,0:10:20.92,Default,,0,0,0,,因此 它会让get请求返回v_1\NAnd so, it's going to return value v_1 from this get request.
Dialogue: 0,0:10:20.92,0:10:26.00,Default,,0,0,0,,接下来 客户端3来了 客户端3也想读取x的值\NNext, client 3 comes along, and client 3 also wants to read the value of x.
Dialogue: 0,0:10:26.00,0:10:31.20,Default,,0,0,0,,它向节点发送一个get请求 它从quorum得到响应\NIt sends a get request to the nodes. It receives a quorum of responses.
Dialogue: 0,0:10:31.20,0:10:35.14,Default,,0,0,0,,此时 它从节点B和C得到了响应\NIn this case, it happens to get responses from nodes B and C.
Dialogue: 0,0:10:35.14,0:10:37.82,Default,,0,0,0,,这也是一个有效的quorum 没有任何问题\NNow, this is also a valid quorum. So, this is fine.
Dialogue: 0,0:10:37.82,0:10:43.26,Default,,0,0,0,,但是B和C都还没有看到最新的v_1\NBut it happens that B and C, neither of them has seen that up-to-date value v_1 yet,
Dialogue: 0,0:10:43.26,0:10:47.50,Default,,0,0,0,,因为v_1仅到达了副本A 还没有到达B和C\Nbecause so far, value v_1 is only on replica A, but not on B and C.
Dialogue: 0,0:10:47.50,0:10:54.74,Default,,0,0,0,,因此 客户端3将只能看到v_0 它意识不到v_1的存在\NSo, client 3 is going to only see the value v_0. It is not a very aware of v_1.
Dialogue: 0,0:10:54.74,0:11:01.46,Default,,0,0,0,,两个get请求结束后 客户端1的set操作到达了副本B和C\NNow, after this has happened, now client 1’s set operation reaches replicas B and C.
Dialogue: 0,0:11:01.46,0:11:05.08,Default,,0,0,0,,现在 副本B和C完成了更新并回复ok\NSo now, replicas B and C get updated and they respond ok.
Dialogue: 0,0:11:05.08,0:11:09.78,Default,,0,0,0,,所有请求都满足quorum条件\NSo, all of these requests here satisfy the quorum condition.
Dialogue: 0,0:11:09.78,0:11:13.66,Default,,0,0,0,,所有请求都获得了quorum节点的确认\NSo, all of them have acknowledgement from a quorum of nodes.
Dialogue: 0,0:11:13.66,0:11:17.16,Default,,0,0,0,,整个过程没有发生任何错误情况\NAnd there are no errors happening here.
Dialogue: 0,0:11:17.16,0:11:19.50,Default,,0,0,0,,尽管如此 你可以看到\NBut nevertheless, you can see that
Dialogue: 0,0:11:19.50,0:11:22.76,Default,,0,0,0,,我们有两个get请求 两个请求分别来自客户端2和客户端3\Nwe have these two get requests from client 2 and client 3.
Dialogue: 0,0:11:22.76,0:11:25.98,Default,,0,0,0,,这两个请求存在实时依赖关系\NAnd we have a real-time dependency between these two requests,
Dialogue: 0,0:11:25.98,0:11:31.80,Default,,0,0,0,,因为客户端3的请求是在客户端2请求结束后开始的\Nbecause client 3's requests started later than client 2's requests finished.
Dialogue: 0,0:11:31.80,0:11:35.88,Default,,0,0,0,,因此 这两个操作存在实时依赖关系\NSo, as before, we have this real-time dependency between these two operations.
Dialogue: 0,0:11:35.88,0:11:41.42,Default,,0,0,0,,线性一致性不仅要考虑set和get操作的依赖关系\NAnd linearizability is not only about this dependency between set and get operations,
Dialogue: 0,0:11:41.42,0:11:44.50,Default,,0,0,0,,也要考虑一个get操作与另一个get操作之间的依赖关系\Nbut also from one get operation to another get operation.
Dialogue: 0,0:11:44.50,0:11:49.60,Default,,0,0,0,,和之前一样 我们期望系统满足线性一致性\NAnd so, as before, we would expect here, under linearizability,
Dialogue: 0,0:11:49.60,0:11:56.00,Default,,0,0,0,,我们期望客户端3读到的值也和客户端2读到的值一样 都是最新的值\Nwe would expect client 3 to read a value that is no older than the value read by client 2.
Dialogue: 0,0:11:56.00,0:12:00.34,Default,,0,0,0,,我们期望这里返回的是v_1 但实际上这里返回的是v_0\NSo, we expect this to return v_1 when in fact it returned v_0.
Dialogue: 0,0:12:00.34,0:12:03.58,Default,,0,0,0,,这违反了线性一致性\NAnd so, this is a violation of linearizability.
Dialogue: 0,0:12:04.94,0:12:07.42,Default,,0,0,0,,现在 你可能会问 我们能修复这一问题吗？\NNow, you might be wondering can we fix this.
Dialogue: 0,0:12:07.42,0:12:10.48,Default,,0,0,0,,我们能修复quorum读和quorum写算法\NCan we fix this quorum read and write algorithm
Dialogue: 0,0:12:10.48,0:12:13.48,Default,,0,0,0,,使系统在任何情况下都满足线性一致性吗？\Nin order to make it linearizable under all circumstances?
Dialogue: 0,0:12:13.48,0:12:17.52,Default,,0,0,0,,答案是 是的 我们可以做到 具体方法描述如下\NAnd the answer is yes, we can do that. And it works like this.
Dialogue: 0,0:12:17.52,0:12:22.90,Default,,0,0,0,,首先 客户端1的set请求和之前的做法完全一样\NSo, first of all, the set operation from client 1 that's exactly the same as it was before.
Dialogue: 0,0:12:22.90,0:12:28.34,Default,,0,0,0,,此请求会被立即发送给A 但发送给B和C时遇到了延迟 这没什么问题\NSo, it gets sent immediately to A, and it's delayed on its way to B and C. That's fine.
Dialogue: 0,0:12:28.34,0:12:33.46,Default,,0,0,0,,接下来是客户端2 客户端2和之前一样发送一个get请求\NAnd next, client 2. So, client 2, as before, sends a get request,
Dialogue: 0,0:12:33.46,0:12:36.58,Default,,0,0,0,,并从包含A和B的quorum处得到响应\Ngets back responses from a quorum consisting of A and B.
Dialogue: 0,0:12:36.58,0:12:40.20,Default,,0,0,0,,它根据时间戳判断v_1是更新的值\NIt decides that v_1 is the newer value based on the timestamp.
Dialogue: 0,0:12:40.20,0:12:43.48,Default,,0,0,0,,但现在 我们不立即返回v_1\NBut now, we don't just return v_1 immediately.
Dialogue: 0,0:12:43.48,0:12:49.64,Default,,0,0,0,,客户端2现在知道副本B拥有一个过期值\NBut client 2 now knows that replica B has an outdated value.
Dialogue: 0,0:12:49.64,0:12:54.56,Default,,0,0,0,,客户端2不知道副本C的值是什么\NAnd client 2 doesn't know what the value on replica C is,
Dialogue: 0,0:12:54.56,0:12:56.52,Default,,0,0,0,,但那个值也可能是过期值\Nbut it might be outdated as well.
Dialogue: 0,0:12:56.52,0:12:58.38,Default,,0,0,0,,因此 客户端2要做的是\NAnd so, what client 2 is going to do is
Dialogue: 0,0:12:58.38,0:13:04.70,Default,,0,0,0,,他向所有尚未持有最新值的副本重新发送set请求\Nnow it's going to resend the set request to any replicas that did not have the latest value.
Dialogue: 0,0:13:04.70,0:13:09.52,Default,,0,0,0,,这种情况下 客户端2要把v_1与响应的原始时间戳t_1发送给其他副本\NSo, in this case, it's going to send the value v_1 along with the original timestamp t_1.
Dialogue: 0,0:13:09.52,0:13:13.12,Default,,0,0,0,,它将把v_1和t_1发送给副本B和C\NIt's going to send that to replicas B and C.
Dialogue: 0,0:13:13.12,0:13:16.52,Default,,0,0,0,,它要等待至少一个副本响应此请求\NAnd it's going to wait for at least one of them to respond.
Dialogue: 0,0:13:16.52,0:13:19.70,Default,,0,0,0,,在图中 客户端2等待两个副本响应此请求 但得到一个副本的响应就够了\NIn this case, it's waiting for both of them to respond, but one of them is enough.
Dialogue: 0,0:13:19.70,0:13:24.72,Default,,0,0,0,,如果两个副本中有一个副本响应了 则此时客户端2知道\NSo, if one of the two responds, now client 2 knows that
Dialogue: 0,0:13:24.72,0:13:29.26,Default,,0,0,0,,当get请求结束后\Nthe value v_1 is present on a quorum of replicas
Dialogue: 0,0:13:29.26,0:13:32.34,Default,,0,0,0,,quorum副本就拥有了v_1\Nat the time when this get request finishes.
Dialogue: 0,0:13:32.34,0:13:38.76,Default,,0,0,0,,因为客户端2现在知道quorum副本拥有了v_1\NAnd because client 2 now knows that the value v_1 is present on the quorum,
Dialogue: 0,0:13:38.76,0:13:42.70,Default,,0,0,0,,因此 任意从quorum返回值的get请求\Ntherefore, any subsequent get request that gets values from a quorum
Dialogue: 0,0:13:42.70,0:13:45.16,Default,,0,0,0,,也将能得到最新的值\Nwill also see that up-to-date value.
Dialogue: 0,0:13:45.16,0:13:49.38,Default,,0,0,0,,我在前面的一个课程中把这一过程叫做读修复\NSo, this is what I call read repair in a previous lecture.
Dialogue: 0,0:13:49.38,0:13:56.34,Default,,0,0,0,,这里 客户端承担了将更新后的值分发给其他副本的角色\NSo, that is the clients taking a role in distributing the updated value to the other replicas.
Dialogue: 0,0:13:56.34,0:14:03.06,Default,,0,0,0,,而且 客户端2在这里没有立刻从get请求中返回\NAnd here, as long as the client 2 does not immediately return from the get request,
Dialogue: 0,0:14:03.06,0:14:08.96,Default,,0,0,0,,它必须等待 确认新的值已经到达quorum副本后\Nbut it has to wait until it is sure that the new value has reached a quorum of replicas,
Dialogue: 0,0:14:08.96,0:14:10.42,Default,,0,0,0,,才返回get请求\Nthen it's allowed to return.
Dialogue: 0,0:14:10.42,0:14:16.36,Default,,0,0,0,,我们在get请求中增加额外这轮读修复后\NAnd if we do that additional round of read repair as part of a get request,
Dialogue: 0,0:14:16.36,0:14:19.48,Default,,0,0,0,,算法就满足线性一致性了\Nthen the algorithm becomes linearizable.
Dialogue: 0,0:14:19.48,0:14:23.32,Default,,0,0,0,,最后 客户端1得到了其它副本的响应\NSo, in this case now, finally, we have the response going to client 1.
Dialogue: 0,0:14:23.32,0:14:25.02,Default,,0,0,0,,所有人都对结果表示满意\NAnd in this case, everyone is happy.
Dialogue: 0,0:14:25.02,0:14:31.72,Default,,0,0,0,,这种情况下 算法将保证客户端能看到v_1\NIn this case, client 3 is going to see the value v_1. It's assured to see that.
Dialogue: 0,0:14:31.72,0:14:36.44,Default,,0,0,0,,此算法让get和set请求满足线性一致性\NSo, this gives us linearizability for get and set requests.
Dialogue: 0,0:14:36.44,0:14:39.90,Default,,0,0,0,,我们用quorum读和读修复来实现get请求\NIn this case, we do the get by doing a quorum read with read repair,
Dialogue: 0,0:14:39.90,0:14:43.30,Default,,0,0,0,,我们把读修复包含的set请求称为盲写\Nand a set request is what we might call a blind write.
Dialogue: 0,0:14:43.30,0:14:47.46,Default,,0,0,0,,无论对象的当前值是什么 我们都用这个set请求覆盖当前值\NSo, the set request just overwrites whatever the value of this object is.
Dialogue: 0,0:14:47.46,0:14:49.94,Default,,0,0,0,,这不是一个条件覆盖操作\NIt doesn't like conditionally overwrite it.
Dialogue: 0,0:14:49.94,0:14:56.06,Default,,0,0,0,,这是一个无条件覆盖操作 不考虑当前值是什么\NIt's just an unconditional overwrite its value with whatever the current value is,
Dialogue: 0,0:14:56.06,0:14:58.10,Default,,0,0,0,,直接执行覆盖操作\Njust overwrite it with a new value.
Dialogue: 0,0:15:00.06,0:15:04.60,Default,,0,0,0,,这个算法被称为ABD算法\NAnd this algorithm here, it's called the ABD algorithm,
Dialogue: 0,0:15:04.60,0:15:08.92,Default,,0,0,0,,这个算法足以保证请求满足线性一致性\Nis enough to ensure linearizability of these requests.
Dialogue: 0,0:15:09.40,0:15:10.56,Default,,0,0,0,,然而 可能发生的一种情况是\NHowever, what might happen is
Dialogue: 0,0:15:10.56,0:15:14.24,Default,,0,0,0,,如果多个客户端并发在相同的对象上执行写操作\Nif multiple clients are concurrently writing to the same object,
Dialogue: 0,0:15:14.24,0:15:16.02,Default,,0,0,0,,则写操作会相互覆盖\Nthen those might overwrite each other.
Dialogue: 0,0:15:16.02,0:15:18.90,Default,,0,0,0,,写操作之间没有任何协调过程\NSo, there's no coordination between the writes.
Dialogue: 0,0:15:18.90,0:15:25.52,Default,,0,0,0,,我们确实能保证所有节点从所有副本中都能读到相同的值\NWe will be ensured that they all end up with the same value across all of the replicas,
Dialogue: 0,0:15:25.52,0:15:29.84,Default,,0,0,0,,但两个并发写入可能存在冲突\Nbut you might have a conflict due to two concurrent writes.
Dialogue: 0,0:15:29.84,0:15:33.80,Default,,0,0,0,,另一个你可能想获得的是比较交换操作\NSo, one other thing you might want is a compare-and-swap operation.
Dialogue: 0,0:15:33.80,0:15:38.20,Default,,0,0,0,,在本课程前半部分的并发系统课程中我们讲到过\NSo, remember this again from the first half of this course on concurrent systems,
Dialogue: 0,0:15:38.20,0:15:43.72,Default,,0,0,0,,比较交换操作通常作为原子指令内置在CPU中\Na compare-and-swap operation is often built into CPUs as an atomic instruction,
Dialogue: 0,0:15:43.72,0:15:48.62,Default,,0,0,0,,这个操作实现的功能是 仅当某个内存位置的旧值等于某个特定值时\Nwhich allows you to set the value of some memory location to some new value
Dialogue: 0,0:15:48.62,0:15:51.34,Default,,0,0,0,,才能在此内存上设置某个新的值\Nonly if its old value is some particular value.
Dialogue: 0,0:15:51.34,0:15:52.50,Default,,0,0,0,,这个操作是原子性的\NAnd it does this atomically.
Dialogue: 0,0:15:52.50,0:15:53.80,Default,,0,0,0,,即使多个线程\NSo, even if multiple threads
Dialogue: 0,0:15:53.80,0:15:57.70,Default,,0,0,0,,并发执行比较交换操作\Nare concurrently executing these compare-and-swap operations,
Dialogue: 0,0:15:58.62,0:16:00.12,Default,,0,0,0,,也只有一个线程才能写入成功\Nonly one of them is going to succeed.
Dialogue: 0,0:16:00.12,0:16:03.86,Default,,0,0,0,,因此 比较交换操作不允许并发的上下文切换\NSo, it's not going to allow concurrent context switches
Dialogue: 0,0:16:03.86,0:16:08.06,Default,,0,0,0,,不允许并发检查旧值并设置新值\Nbetween like the checking of the old value and the setting of the new value.
Dialogue: 0,0:16:08.06,0:16:10.98,Default,,0,0,0,,你可能会问 分布式系统下能否做到这一点呢？\NAnd you might wonder can we do the same thing?
Dialogue: 0,0:16:10.98,0:16:15.42,Default,,0,0,0,,我们能否在分布式系统下实现满足线性一致性的比较交换操作？\NCan we do a linearizable compare-and-swap operation in a distributed system?
Dialogue: 0,0:16:15.42,0:16:17.94,Default,,0,0,0,,答案是 是的 我们能实现\NAnd the answer is, actually, yes, we can.
Dialogue: 0,0:16:17.94,0:16:20.14,Default,,0,0,0,,但我们要使用\NBut we have to use a different algorithm
Dialogue: 0,0:16:20.14,0:16:22.90,Default,,0,0,0,,与quorum读和quorum写不一样的算法\Nfrom the quorum reads and writes that we just did.
Dialogue: 0,0:16:22.90,0:16:26.38,Default,,0,0,0,,我们需要再次使用全序关系广播\NWe can instead use total order broadcast again.
Dialogue: 0,0:16:26.38,0:16:29.56,Default,,0,0,0,,全序关系广播再一次发挥了作用\NSo, once again, total order broadcast comes to the rescue.
Dialogue: 0,0:16:29.56,0:16:32.84,Default,,0,0,0,,这个算法用一张幻灯片就能介绍完 非常简单\NAnd this algorithm fits on just one slide. It's quite simple.
Dialogue: 0,0:16:32.84,0:16:37.20,Default,,0,0,0,,我们实现满足线性一致性的比较交换操作和get操作的方法\NThe way we can implement a linearizable compare-and-swap operation
Dialogue: 0,0:16:37.20,0:16:41.22,Default,,0,0,0,,就是使用全序关系广播\Nand a linearizable get operation is using total order broadcast.
Dialogue: 0,0:16:41.22,0:16:46.66,Default,,0,0,0,,如果我们想执行一个get操作 我们将构造格式为(get, x)的消息\NIf we want to do a get operation, we're going to make a message saying “get x”.
Dialogue: 0,0:16:46.66,0:16:50.30,Default,,0,0,0,,我们用全序关系广播将此消息发送给所有的节点\NAnd we're going to total order broadcast that to all of the nodes.
Dialogue: 0,0:16:50.30,0:16:51.94,Default,,0,0,0,,我们不要立刻响应此消息\NAnd we're not going to respond immediately.
Dialogue: 0,0:16:51.94,0:16:56.30,Default,,0,0,0,,我们要等待全序关系广播完成消息传递后再响应\NWe're going to wait for that message to be delivered by total order broadcast.
Dialogue: 0,0:16:56.30,0:16:59.76,Default,,0,0,0,,类似地 如果我们想原子性地执行一次比较交换操作\NLikewise, if we want to do an atomic compare-and-swap operation,
Dialogue: 0,0:16:59.76,0:17:03.46,Default,,0,0,0,,我们将此操作打包成一条消息\Nwe're just going to package that operation up as a message,
Dialogue: 0,0:17:03.46,0:17:05.76,Default,,0,0,0,,通过全序关系广播分发此条消息\Ndistributed via total order broadcast,
Dialogue: 0,0:17:05.76,0:17:08.32,Default,,0,0,0,,等待消息完成传递\Nand wait for that message to be delivered.
Dialogue: 0,0:17:08.32,0:17:13.60,Default,,0,0,0,,当全序关系广播传递了一条get消息时\NNow, when one of the get messages is delivered by total order broadcast,
Dialogue: 0,0:17:13.60,0:17:16.46,Default,,0,0,0,,回忆一下全序关系广播所做的事情\Nwell, remember what total order broadcast does,
Dialogue: 0,0:17:16.46,0:17:19.74,Default,,0,0,0,,它会保证所有节点按照相同的顺序传递相同的消息\Nit just ensures delivery of the same messages in the same order.
Dialogue: 0,0:17:19.74,0:17:25.60,Default,,0,0,0,,因此 所有副本都会按照相同的顺序收到这些消息\NSo, therefore, all replicas are going to receive these messages in the same order.
Dialogue: 0,0:17:25.60,0:17:29.28,Default,,0,0,0,,因此 当get消息被传递时\NSo, therefore, here now, when that message is delivered,
Dialogue: 0,0:17:29.28,0:17:31.94,Default,,0,0,0,,我们只需要读取本地状态 读取x的值\Nwe can just read the local state, read the value of x,
Dialogue: 0,0:17:31.94,0:17:37.84,Default,,0,0,0,,并把当前值作为get消息的返回值\Nand return that current value as the result of this get operation.
Dialogue: 0,0:17:37.84,0:17:41.90,Default,,0,0,0,,类似地 如果我们从全序关系广播收到一条CAS消息\NAnd likewise, if we receive a CAS message
Dialogue: 0,0:17:42.30,0:17:45.42,Default,,0,0,0,,这里的CAS是比较交换的英文缩写\Nfor compare-and-swap from total order broadcast,
Dialogue: 0,0:17:45.42,0:17:49.56,Default,,0,0,0,,我们只需要在本地直接执行比较交换算法\Nthen we just do the straightforward compare-and-swap algorithm.
Dialogue: 0,0:17:49.56,0:17:53.86,Default,,0,0,0,,如果当前状态就是我们想要的旧值\NSo, if the existing state is the old value that we want,
Dialogue: 0,0:17:53.86,0:17:57.50,Default,,0,0,0,,我们就把旧值设置为新值 并把返回的success设置为true\Nthen we set it to the new value and we return success being true.
Dialogue: 0,0:17:57.50,0:18:01.10,Default,,0,0,0,,否则 我们不做任何修改 把返回的success设置为false\NOtherwise, we don't change anything and we return success being false.
Dialogue: 0,0:18:01.10,0:18:05.30,Default,,0,0,0,,我们把success作为比较交换操作的返回值\NAnd we return this as the result of the compare-and-swap operation.
Dialogue: 0,0:18:05.30,0:18:07.82,Default,,0,0,0,,这个算法非常简单\NAnd this is very simple,
Dialogue: 0,0:18:07.82,0:18:14.14,Default,,0,0,0,,因为全序关系广播本质上为我们提供了一个单线程视角\Nbut because total order broadcast essentially gives us this kind of single-threaded view
Dialogue: 0,0:18:14.14,0:18:19.44,Default,,0,0,0,,所有节点会按照相同的全序关系传递所有的操作\Nthat all of the operations are delivered in the same total order on all of the nodes.
Dialogue: 0,0:18:19.44,0:18:22.78,Default,,0,0,0,,我们这里得到的本质上与状态机复制相同\NWhat we have here is essentially the same as state machine replication.
Dialogue: 0,0:18:22.78,0:18:28.32,Default,,0,0,0,,我们保证get操作可以从所有副本得到相同的结果\NWe are going to ensure that the get operations get the same result on each replica,
Dialogue: 0,0:18:28.32,0:18:33.38,Default,,0,0,0,,比较交换操作在每个副本得到相同的执行效果\Nand the compare-and-swap operations have the same effect on every replica.
Dialogue: 0,0:18:33.38,0:18:35.56,Default,,0,0,0,,这样一来 我们就得到了线性一致性\NAnd so, here we get linearizability.
Dialogue: 0,0:18:35.56,0:18:40.04,Default,,0,0,0,,我们基于全序关系广播得到了满足线性一致性的操作\NWe get these linearizable operations by building on total order broadcast,
Dialogue: 0,0:18:40.04,0:18:42.64,Default,,0,0,0,,我认为这是一个非常干净、非常简洁的构造\Nwhich I think is a very neat construction.
