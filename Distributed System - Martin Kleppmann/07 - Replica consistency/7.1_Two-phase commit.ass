[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 7.1_Two-phase commit.mp4
Video File: 7.1_Two-phase commit.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.625000
Scroll Position: 173
Active Line: 196
Video Position: 20730

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:01.24,0:00:05.20,Default,,0,0,0,,大家好 欢迎来到分布式系统的第7课\NHello, everyone, and welcome to Lecture 7 of distributed systems.
Dialogue: 0,0:00:05.20,0:00:09.28,Default,,0,0,0,,今天我们将讨论复制的一致性\NToday, we will be talking about consistency of replicas.
Dialogue: 0,0:00:09.28,0:00:13.02,Default,,0,0,0,,很不幸 “一致性”是一个很糟糕的词\NNow, consistency is a bit of a terrible word, unfortunately,
Dialogue: 0,0:00:13.02,0:00:14.92,Default,,0,0,0,,因为这个词包含了太多的含义\Nbecause it means so many different things
Dialogue: 0,0:00:14.92,0:00:18.26,Default,,0,0,0,,这个词的含义与讨论的对象和讨论的上下文高度相关\Ndepending on who you're asking and which context you're talking about.
Dialogue: 0,0:00:18.26,0:00:23.02,Default,,0,0,0,,你可能在一些上下文中见过一致性这个词\NSo, just some of the contexts where you might have seen consistency is
Dialogue: 0,0:00:23.02,0:00:24.72,Default,,0,0,0,,其中一个场景是事务一致性\Nin the context of transactions.
Dialogue: 0,0:00:24.72,0:00:28.68,Default,,0,0,0,,在ACID事务中 C表示的就是一致性\NSo, the ACID transaction, the C stands for consistency.
Dialogue: 0,0:00:28.68,0:00:34.24,Default,,0,0,0,,在这个上下文中 一致性是数据库状态要满足的一个性质\NAnd in this context, the meaning of consistency is a property of a database state.
Dialogue: 0,0:00:34.24,0:00:37.90,Default,,0,0,0,,这里的一致性是指 数据库的状态是一致的\NSo, we're saying that the database is in a consistent state.
Dialogue: 0,0:00:37.90,0:00:40.28,Default,,0,0,0,,如果你在数据库上执行一个良定义的事务\NAnd if you apply a good transaction to it,
Dialogue: 0,0:00:40.28,0:00:44.14,Default,,0,0,0,,则此事务会将数据库从一个一致性状态移动至另一个一致性状态\Nthen it moves the database from one consistent state into another.
Dialogue: 0,0:00:44.14,0:00:47.02,Default,,0,0,0,,这里的一致性指的是\NSo, here consistent really means that
Dialogue: 0,0:00:47.02,0:00:50.38,Default,,0,0,0,,数据库状态要满足特定的不变性\Nthe state of the database satisfies certain invariants
Dialogue: 0,0:00:50.38,0:00:53.24,Default,,0,0,0,,或满足应用设置的特定约束条件\Nor certain constraints that the application has set.
Dialogue: 0,0:00:53.24,0:00:56.66,Default,,0,0,0,,举个例子 如果你有一个大学数据库\NAs one example, if you have a university database,
Dialogue: 0,0:00:56.66,0:00:59.40,Default,,0,0,0,,你可能会设置一个一致性要求：\Nyou might have a consistency requirement that
Dialogue: 0,0:00:59.40,0:01:04.34,Default,,0,0,0,,如果至少有一个学生注册了某个课程 则这个课程必须有一个讲师\Nwhenever a course has at least one student enrolled in it, then it must also have a lecturer.
Dialogue: 0,0:01:04.34,0:01:05.98,Default,,0,0,0,,有学生注册的课程不可能没有讲师\NSo, it must not be without lecturer.
Dialogue: 0,0:01:05.98,0:01:10.16,Default,,0,0,0,,这只是举个例子 你可能会为数据库设置类似的一些约束性质\NFor example, you could have those kinds of consistency properties.
Dialogue: 0,0:01:10.16,0:01:12.14,Default,,0,0,0,,但实际上 ACID中的一致性\NBut this ACID consistency
Dialogue: 0,0:01:12.14,0:01:15.94,Default,,0,0,0,,与我们在分布式系统中讨论的一致性不一样\Nis not actually what we're usually talking about in distributed systems.
Dialogue: 0,0:01:15.94,0:01:19.22,Default,,0,0,0,,我们在前几节课中讲解过与之不同的一致性模型\NWe saw a different model of consistency a few lectures ago,
Dialogue: 0,0:01:19.22,0:01:20.80,Default,,0,0,0,,即读后写一致性\Nread-after-right consistency,
Dialogue: 0,0:01:20.80,0:01:27.80,Default,,0,0,0,,它的意思是 如果一个客户端写入数据 再读取刚刚写入的数据\Nwhich was that if a client makes a write and then reads back what it has just written,
Dialogue: 0,0:01:27.80,0:01:30.22,Default,,0,0,0,,则此客户端应该能读取到刚刚写入的数据\Nit should be able to see what it has just written.
Dialogue: 0,0:01:30.22,0:01:34.08,Default,,0,0,0,,这个一致性定义与ACID的一致性定义毫无关系\NThat has got nothing to do with the consistency in the sense of ACID.
Dialogue: 0,0:01:34.08,0:01:35.88,Default,,0,0,0,,一致性在这里表达了完全不同的含义\NIt's a very different meaning of the word.
Dialogue: 0,0:01:35.88,0:01:40.78,Default,,0,0,0,,在复制场景中 我们经常说\NSo, in the context of replication, what we often say is
Dialogue: 0,0:01:40.78,0:01:44.54,Default,,0,0,0,,我们希望一个副本与另一个副本保持一致\Nwe want one replica to be consistent with another replica,
Dialogue: 0,0:01:44.98,0:01:48.18,Default,,0,0,0,,我们再一次面对“一致性”到底是什么意思的问题\Nwhich again raises the question of what exactly we mean.
Dialogue: 0,0:01:48.58,0:01:51.56,Default,,0,0,0,,意思是副本必须具有相同的状态？\NSo, does that mean the replicas are in the same state?
Dialogue: 0,0:01:51.56,0:01:54.10,Default,,0,0,0,,但副本到底要在什么时刻才必须具有相同的状态？\NBut when exactly do they have to be in the same states?
Dialogue: 0,0:01:54.10,0:01:57.90,Default,,0,0,0,,它们可以在不同的时间点具备相同的状态\NThey could be in the same state at different points in time, for example,
Dialogue: 0,0:01:57.90,0:02:00.28,Default,,0,0,0,,或者说同一时间点的状态可以不同吗？\Nor in different states at the same time?
Dialogue: 0,0:02:00.98,0:02:03.26,Default,,0,0,0,,我们会把一致性解读为\NWe could express consistency in terms of
Dialogue: 0,0:02:03.26,0:02:07.58,Default,,0,0,0,,读取操作的结果与我们期待的结果一样吗？\Nwhat the results of read operations should be what we expect?
Dialogue: 0,0:02:07.58,0:02:12.50,Default,,0,0,0,,我这里想强调的意思是 一致性有很多不同的含义\NSo, I'm just saying here there are lots of different forms of consistency.
Dialogue: 0,0:02:12.50,0:02:15.34,Default,,0,0,0,,不存在一个正确的一致性定义\NAnd no one true definition of consistency.
Dialogue: 0,0:02:15.34,0:02:18.34,Default,,0,0,0,,实际上 有很多不同的一致性模型\NThere are in fact a whole bunch of different consistency models.
Dialogue: 0,0:02:18.34,0:02:22.06,Default,,0,0,0,,在本节课中 我们将学习一部分一致性模型\NAnd in this lecture, we're going to look at some of those consistency models,
Dialogue: 0,0:02:22.06,0:02:26.02,Default,,0,0,0,,看看如何在特定的场景下定义和使用这些一致性模型\Nand see the context in which they are useful and how they are defined.
Dialogue: 0,0:02:26.92,0:02:30.50,Default,,0,0,0,,我想先从分布式事务开始讲起\NSo, what I want to start with is distributed transactions.
Dialogue: 0,0:02:30.50,0:02:34.86,Default,,0,0,0,,大家在前半部分的并发系统课程中已经学习了事务的概念\NSo, you've covered transactions in the first half of this course on concurrent systems.
Dialogue: 0,0:02:34.86,0:02:38.90,Default,,0,0,0,,回忆一下ACID性质 A代表原子性\NAnd if you recall the ACID properties, the A stands for atomicity,
Dialogue: 0,0:02:38.90,0:02:44.34,Default,,0,0,0,,意思是 如果一个事务对数据库进行了一系列更新\Nwhich means that if a transaction makes a bunch of updates to the database,
Dialogue: 0,0:02:44.34,0:02:47.46,Default,,0,0,0,,则如果数据库崩溃或出现了什么错误\Nthen even if the database crashes or something goes wrong,
Dialogue: 0,0:02:47.46,0:02:53.22,Default,,0,0,0,,或者所有更新都被应用在数据库上并完成持久性存储\Neither all of those updates are applied to the database and they are made durable,
Dialogue: 0,0:02:53.64,0:02:55.84,Default,,0,0,0,,此时称事务被提交\Nin which case the transaction is set to commit,
Dialogue: 0,0:02:55.84,0:02:59.50,Default,,0,0,0,,或者所有更新都没有生效\Nor none of the updates take effect,
Dialogue: 0,0:02:59.50,0:03:02.46,Default,,0,0,0,,此时称事务被中止\Nin which case the transaction is said to be aborted.
Dialogue: 0,0:03:02.46,0:03:08.44,Default,,0,0,0,,事务有二选一的可能性 或者被提交、或者被中止\NSo, we have this kind of binary choice of a transaction, either it commits, or it aborts,
Dialogue: 0,0:03:08.44,0:03:11.20,Default,,0,0,0,,但我们不会以中间状态结束事务\Nbut we don't end up with this kind of half state,
Dialogue: 0,0:03:11.20,0:03:14.54,Default,,0,0,0,,即事务中的有些更新已经生效\Nwhere some of the transaction updates have happened,
Dialogue: 0,0:03:14.54,0:03:16.32,Default,,0,0,0,,而其余更新还没有生效\Nand others have not have happened.
Dialogue: 0,0:03:16.32,0:03:17.44,Default,,0,0,0,,这非常重要\NAnd this is very important,
Dialogue: 0,0:03:17.44,0:03:22.64,Default,,0,0,0,,如果你想让数据库系统满足ACID下的一致性\Nbecause if you want to ensure something like consistency in the sense of ACID,
Dialogue: 0,0:03:22.64,0:03:26.38,Default,,0,0,0,,则原子性是一致性的基础\Nyou do have to have atomicity as the foundation of that,
Dialogue: 0,0:03:26.74,0:03:28.66,Default,,0,0,0,,否则 你可能就需要通过某种方式\Nbecause otherwise, you could end up with
Dialogue: 0,0:03:29.20,0:03:31.56,Default,,0,0,0,,协调两个数据库更改操作\Ntwo changes that need to be coordinated in some way,
Dialogue: 0,0:03:31.94,0:03:35.16,Default,,0,0,0,,如果只有一个更改操作生效 你就会得到不一致的数据库状态\Nand if only one of the two happens, then you end up in an inconsistent state.
Dialogue: 0,0:03:35.16,0:03:38.08,Default,,0,0,0,,这就是我们为什么需要原子性的原因\NSo, that's why we need atomicity.
Dialogue: 0,0:03:38.08,0:03:41.84,Default,,0,0,0,,在分布式系统中 执行一个事务\NNow, in a distributed system, we might have a transaction
Dialogue: 0,0:03:41.84,0:03:46.30,Default,,0,0,0,,可能会涉及到分布式数据库的多个节点\Nthat involves more than one node in a distributed database, for example.
Dialogue: 0,0:03:46.30,0:03:50.20,Default,,0,0,0,,在此类系统中 我们需要保证\NAnd in this type of system, we have to ensure atomicity
Dialogue: 0,0:03:50.20,0:03:53.26,Default,,0,0,0,,参与此次事务的所有节点都满足原子性\Nacross all of the nodes that are participating in the transaction,
Dialogue: 0,0:03:53.26,0:03:57.96,Default,,0,0,0,,也就是说 涉及此事务所有节点的数据读取或写入操作都需要满足原子性\Nso, all of the nodes on which data is being read or written in the course of a transaction.
Dialogue: 0,0:03:57.96,0:04:02.44,Default,,0,0,0,,因此 我们必须保证事务在所有节点或者都被提交\NAnd so, we must ensure that the transaction either commits on all of the nodes,
Dialogue: 0,0:04:02.44,0:04:04.48,Default,,0,0,0,,或者都被中止\Nor it aborts on all of the nodes.
Dialogue: 0,0:04:05.06,0:04:08.54,Default,,0,0,0,,这样才能让事务作为一个整体\NSo, that would then give us atomicity for the transaction as a whole
Dialogue: 0,0:04:08.54,0:04:10.02,Default,,0,0,0,,在所有节点上满足原子性\Nacross all of the nodes.
Dialogue: 0,0:04:10.02,0:04:14.08,Default,,0,0,0,,进一步 如果涉及此事务的其中一个节点崩溃\NMoreover, if one of the nodes involved in the transaction crashes,
Dialogue: 0,0:04:14.08,0:04:17.94,Default,,0,0,0,,我们同样必须要求所有其他节点也要中止此事务\Nthen we also have to make sure that we abort the transaction on all other nodes,
Dialogue: 0,0:04:17.94,0:04:21.04,Default,,0,0,0,,因为崩溃节点无法完成此事务\Nbecause the crash node cannot complete the transaction,
Dialogue: 0,0:04:21.04,0:04:23.34,Default,,0,0,0,,此节点无法提交此事务\Nit cannot commit the transaction.
Dialogue: 0,0:04:23.34,0:04:27.96,Default,,0,0,0,,在分布式系统中 这被称为原子提交问题\NAnd this is known as the atomic commitment problem in distributed systems.
Dialogue: 0,0:04:27.96,0:04:31.80,Default,,0,0,0,,你可能会觉得 这看起来和共识有点像\NSo, you might think this looks kind of a bit similar to consensus,
Dialogue: 0,0:04:31.80,0:04:35.00,Default,,0,0,0,,因为我们这里也希望所有节点\Nbecause what we want here is all of the nodes to agree on
Dialogue: 0,0:04:35.00,0:04:37.60,Default,,0,0,0,,对提交或中止事务达成一致\Nwhether to commit or abort the transaction,
Dialogue: 0,0:04:37.60,0:04:40.18,Default,,0,0,0,,细细品味 这和共识确实很像\Nwhich kind of smells like consensus.
Dialogue: 0,0:04:40.18,0:04:42.22,Default,,0,0,0,,表面上的确很像\NNow, yes, superficially.
Dialogue: 0,0:04:42.60,0:04:44.10,Default,,0,0,0,,但如果我们深入到细节就会发现\NBut if we look at it in more detail,
Dialogue: 0,0:04:44.10,0:04:47.90,Default,,0,0,0,,实际上 原子提交和共识完全不同\Nactually, atomic commitment is quite different from consensus.
Dialogue: 0,0:04:47.90,0:04:51.16,Default,,0,0,0,,让我来解释一下原因\NAnd so, let me just explain why.
Dialogue: 0,0:04:51.92,0:04:56.76,Default,,0,0,0,,我前面解释过共识的定义\NWith consensus, the way I explained it previously was that
Dialogue: 0,0:04:56.76,0:05:03.00,Default,,0,0,0,,你有多个节点 一个或多个节点提出了某个值\Nyou have multiple nodes, one or more node may propose some value,
Dialogue: 0,0:05:03.78,0:05:07.58,Default,,0,0,0,,共识协议将决定选择哪个值\Nand one of those values gets decided by the consensus algorithm,
Dialogue: 0,0:05:07.58,0:05:10.92,Default,,0,0,0,,而原子提交的约束条件更强\Nwhereas in atomic commits, we're a bit more constrained.
Dialogue: 0,0:05:10.92,0:05:13.44,Default,,0,0,0,,我们必须让所有的节点进行投票\NWe have to have all of the nodes voting on
Dialogue: 0,0:05:13.44,0:05:17.06,Default,,0,0,0,,一起来判断是否提交一个事务\Nwhether they are able to commit a transaction or not.
Dialogue: 0,0:05:17.06,0:05:20.70,Default,,0,0,0,,我们必须要考虑所有节点的投票结果\NAnd we have to take all of those votes into account.
Dialogue: 0,0:05:20.70,0:05:22.28,Default,,0,0,0,,在共识中\NSo, while in consensus,
Dialogue: 0,0:05:22.28,0:05:26.54,Default,,0,0,0,,我们可以简单地选择节点提出的其中一个值\Nit's OK to simply pick any one of the values that has been proposed.
Dialogue: 0,0:05:26.54,0:05:30.84,Default,,0,0,0,,原子提交清楚地定义了必须发生的事情\NIn atomic commit, it's very clearly defined what must happen.
Dialogue: 0,0:05:30.84,0:05:35.68,Default,,0,0,0,,如果所有的节点都投票给提交 则必须提交事务\NIf all of the nodes vote to commit, then the transaction must commit.
Dialogue: 0,0:05:35.68,0:05:40.32,Default,,0,0,0,,如果任意一个节点投票给中止 则所有节点必须中止事务\NIf any one of the nodes votes to abort, then all of them must abort.
Dialogue: 0,0:05:40.32,0:05:42.48,Default,,0,0,0,,因此 在算法进行决策时\NSo, atomic commit is much more constrained
Dialogue: 0,0:05:42.48,0:05:45.56,Default,,0,0,0,,原子提交的约束条件更强\Nin the decision that the algorithm has to make.
Dialogue: 0,0:05:46.12,0:05:48.00,Default,,0,0,0,,最后 在共识中\NAnd finally, with consensus,
Dialogue: 0,0:05:48.00,0:05:50.58,Default,,0,0,0,,我们可以提出Raft这样的算法\Nwe've seen that we can have algorithms like Raft,
Dialogue: 0,0:05:50.58,0:05:52.50,Default,,0,0,0,,只要quorum节点可以接收和响应请求\Nwhich can continue working
Dialogue: 0,0:05:52.50,0:05:57.50,Default,,0,0,0,,算法就可以继续工作\Nas long as a quorum of nodes is reachable and responding to requests,
Dialogue: 0,0:05:57.50,0:05:59.10,Default,,0,0,0,,但在原子提交中\Nwhereas with atomic commit,
Dialogue: 0,0:05:59.10,0:06:03.94,Default,,0,0,0,,因为我们要求所有节点都必须要投票\Nbecause we have this requirement that all of the nodes must vote,
Dialogue: 0,0:06:03.94,0:06:07.56,Default,,0,0,0,,我们必须让所有节点达成共识\Nand we must get consensus across all of them,
Dialogue: 0,0:06:07.56,0:06:09.12,Default,,0,0,0,,这意味着\Nthis means now that
Dialogue: 0,0:06:09.64,0:06:14.60,Default,,0,0,0,,即使只存在一个崩溃节点 整个事务都需要被中止\Neven just one single node crash will cause the entire transaction to abort.
Dialogue: 0,0:06:14.60,0:06:19.18,Default,,0,0,0,,原子提交无法容忍任何故障节点\NSo, atomic commit is not able to tolerate any faulty nodes,
Dialogue: 0,0:06:19.18,0:06:23.38,Default,,0,0,0,,而像Raft这样的容错共识算法\Nwhereas a fault-tolerant consensus algorithm like Raft
Dialogue: 0,0:06:23.38,0:06:28.70,Default,,0,0,0,,可以容忍系统中出现少半故障节点\Nis able to tolerate a minority of faulty nodes in the system.
Dialogue: 0,0:06:28.70,0:06:30.74,Default,,0,0,0,,这就是原子提交的概念\NSo, this is atomic commitment.
Dialogue: 0,0:06:30.74,0:06:33.60,Default,,0,0,0,,我们通常实现原子提交的方法是\NAnd the way we typically implement atomic commit is
Dialogue: 0,0:06:33.60,0:06:36.06,Default,,0,0,0,,使用一个叫两阶段提交的算法\Nusing an algorithm called two-phase commit.
Dialogue: 0,0:06:36.06,0:06:38.76,Default,,0,0,0,,两阶段提交听起来有点像\NNow two-phase commit sounds a bit like two-phase locking,
Dialogue: 0,0:06:38.76,0:06:40.22,Default,,0,0,0,,大家在前面学习过的两阶段锁定\Nwhich you've seen previously.
Dialogue: 0,0:06:40.22,0:06:43.24,Default,,0,0,0,,不要把两个名词弄混 这两个名词听起来很相似 但它们完全不同\NDon't confuse the two. They sound very similar, but they're very different things.
Dialogue: 0,0:06:43.24,0:06:46.78,Default,,0,0,0,,两阶段锁定是实现串行化隔离的技术\NSo, two-phase locking is around serializable isolation
Dialogue: 0,0:06:46.78,0:06:49.64,Default,,0,0,0,,两阶段提交是实现原子提交的技术\Nwhereas two-phase commit is around getting atomicity,
Dialogue: 0,0:06:49.64,0:06:51.54,Default,,0,0,0,,完全不同的领域\Nvery different area.
Dialogue: 0,0:06:51.54,0:06:55.48,Default,,0,0,0,,我们开始执行两阶段提交的方式是\NSo, the way we start two-phase commit is that
Dialogue: 0,0:06:55.48,0:07:02.42,Default,,0,0,0,,客户端希望在多个数据库节点上启动一个事务\Nthe client wants to begin a transaction on multiple database nodes.
Dialogue: 0,0:07:02.42,0:07:05.20,Default,,0,0,0,,客户端像往常一样启动一个事务\NAnd it just starts a transaction as usual,
Dialogue: 0,0:07:05.20,0:07:11.14,Default,,0,0,0,,向这些节点发送事务标识符T_1 并像往常一样执行此事务\Nsends some transaction identifier T_1 to those nodes, and then, does its usual thing,
Dialogue: 0,0:07:11.14,0:07:15.70,Default,,0,0,0,,事务会从数据库中读取或写入任意对象\Nso, the transaction may read and write arbitrary objects in the database,
Dialogue: 0,0:07:16.06,0:07:18.80,Default,,0,0,0,,完成它需要执行的任意业务逻辑\Nand do whatever it needs to do any kind of logic.
Dialogue: 0,0:07:18.80,0:07:22.90,Default,,0,0,0,,只有当我们准备好提交事务时 才会启动两阶段提交\NTwo-phase commit only starts when we're ready to commit the transaction.
Dialogue: 0,0:07:22.90,0:07:27.06,Default,,0,0,0,,我们不按照通常的方式提交事务\NSo, rather than the usual form of transaction commits
Dialogue: 0,0:07:27.06,0:07:31.18,Default,,0,0,0,,客户端不能直接发送给数据库一条消息 说：“请现在提交吧”\Nwhere the client just sends directly to the database, “Hey, commit now please”.
Dialogue: 0,0:07:31.18,0:07:32.60,Default,,0,0,0,,在两阶段提交中\NWith two-phase commit, instead,
Dialogue: 0,0:07:32.60,0:07:35.82,Default,,0,0,0,,提交请求会被发送给系统中的一个新节点\Nthe request to commit goes to a new node in the system
Dialogue: 0,0:07:35.82,0:07:38.32,Default,,0,0,0,,此节点被称为事务协调者\Ncalled the transaction coordinator.
Dialogue: 0,0:07:38.32,0:07:40.64,Default,,0,0,0,,此提交请求会被发送给事务协调者\NSo, this commit request goes to the coordinator.
Dialogue: 0,0:07:40.64,0:07:44.56,Default,,0,0,0,,协调者接下来\NAnd the coordinator then sends a prepare message
Dialogue: 0,0:07:44.56,0:07:49.40,Default,,0,0,0,,向所有参与此事务的数据库节点发送一条准备消息\Nto all of the database nodes that are participating in the transaction.
Dialogue: 0,0:07:49.40,0:07:52.56,Default,,0,0,0,,发送准备消息的目的是\NAnd the purpose of the prepare message is
Dialogue: 0,0:07:52.56,0:07:57.28,Default,,0,0,0,,让节点几乎执行完事务 只是还没有最终提交事务\Nit's kind of like commit, except it doesn't actually finish the transaction yet.
Dialogue: 0,0:07:57.28,0:08:02.82,Default,,0,0,0,,也就是说 当数据库节点收到准备消息时\NSo, what prepare does is when a database node receives the prepare message,
Dialogue: 0,0:08:02.82,0:08:04.16,Default,,0,0,0,,数据库节点必须\Nthe database node has to
Dialogue: 0,0:08:04.16,0:08:07.78,Default,,0,0,0,,向磁盘写入此事务包含的所有更新操作\Nwrite all of the changes, all of the updates from that transaction to disk,
Dialogue: 0,0:08:07.78,0:08:14.26,Default,,0,0,0,,数据库节点必须检查约束条件 满足数据库的一致性要求\Nand it has to check any constraints to make sure that we have consistency of the database,
Dialogue: 0,0:08:14.26,0:08:17.50,Default,,0,0,0,,因为当回复这条准备消息时\Nbecause in response to that prepare message,
Dialogue: 0,0:08:17.50,0:08:21.50,Default,,0,0,0,,数据库节点需要回复“是”或者“否”\Nthe database node now has to reply with either yes or no,
Dialogue: 0,0:08:21.50,0:08:23.98,Default,,0,0,0,,表示数据库节点是否愿意提交此事务\Nwhether it's willing to commit that transaction or not.
Dialogue: 0,0:08:23.98,0:08:29.02,Default,,0,0,0,,我前面说过 只要有一个节点回复“否” 都会导致事务中止\NAnd so, as we said, any one no response to this will cause the transaction to abort.
Dialogue: 0,0:08:29.02,0:08:32.64,Default,,0,0,0,,但如果所有节点都回复“是” 就会提交此事务\NBut if all of them vote yes, then the transaction will commit.
Dialogue: 0,0:08:32.64,0:08:38.42,Default,,0,0,0,,这意味着一旦数据库节点回复称：\NSo, this means that once the database node replies, saying,
Dialogue: 0,0:08:38.42,0:08:41.28,Default,,0,0,0,,“我很高兴能够提交此事务”\N“OK, I'm happy to commit this transaction”,
Dialogue: 0,0:08:41.28,0:08:46.04,Default,,0,0,0,,数据库节点就会保证未来它已经能够提交此事务\Nit is promising that it will definitely be able to commit that transaction in the future,
Dialogue: 0,0:08:46.04,0:08:52.94,Default,,0,0,0,,因为在这个时刻 数据库节点已经履行完它的职责了\Nbecause at this point, the database node has abdicated its responsibility.
Dialogue: 0,0:08:52.94,0:08:55.84,Default,,0,0,0,,现在轮到事务协调者决定\NNow, it's up to the transaction coordinator to make the decision
Dialogue: 0,0:08:55.84,0:08:57.92,Default,,0,0,0,,是否提交此事务了\Nwhether or not to commit the transaction.
Dialogue: 0,0:08:57.92,0:09:00.54,Default,,0,0,0,,数据库节点必须保证\NSo, the database node just has to promise that
Dialogue: 0,0:09:00.54,0:09:04.32,Default,,0,0,0,,如果协调者随后要求数据库节点提交事务\Nif it is asked later by the coordinator to commit the transaction,
Dialogue: 0,0:09:04.32,0:09:06.36,Default,,0,0,0,,那么数据库节点就一定能提交此事务\Nit will definitely be able to commit it.
Dialogue: 0,0:09:06.36,0:09:10.64,Default,,0,0,0,,我们不允许数据库节点事后退出或离开 告诉我们：\NSo, it's not allowed to back out and flake out afterwards, and say,
Dialogue: 0,0:09:10.64,0:09:13.30,Default,,0,0,0,,“不好意思 我不想提交了”\N“Oh, sorry, I don't want to commit this after all”.
Dialogue: 0,0:09:13.30,0:09:15.26,Default,,0,0,0,,这时候再反悔就太晚了\Nbecause by that point, it's too late.
Dialogue: 0,0:09:15.26,0:09:20.92,Default,,0,0,0,,准备消息告诉事务处理节点\NSo, the prepare message is telling the trade-based nodes that
Dialogue: 0,0:09:20.92,0:09:23.92,Default,,0,0,0,,它们必须准备好提交事务\Nit must get everything ready to be able to commit,
Dialogue: 0,0:09:23.92,0:09:26.18,Default,,0,0,0,,只是还没有最终提交事务\Nbut without actually ending the transaction yet.
Dialogue: 0,0:09:26.18,0:09:29.82,Default,,0,0,0,,随后 如果在两阶段提交的步骤2中\NAnd then, if the coordinator says in phase 2 of two-phase commit,
Dialogue: 0,0:09:29.82,0:09:32.48,Default,,0,0,0,,协调者说：“我们现在提交吧”\Nif the coordinator says, “OK, now we're going to commit”,
Dialogue: 0,0:09:32.48,0:09:34.86,Default,,0,0,0,,则独立数据库节点继续处理\Nthen the individual database nodes go.
Dialogue: 0,0:09:34.86,0:09:38.58,Default,,0,0,0,,它们完成提交、终止事务、释放所有的锁\NThey do the actual commit. They end the transaction. They release all of the locks.
Dialogue: 0,0:09:38.58,0:09:41.10,Default,,0,0,0,,一切处理完毕\NAnd everything is done.
Dialogue: 0,0:09:41.10,0:09:44.80,Default,,0,0,0,,这就是两阶段提交的模型\NSo, this is the model of two-phase commit.
Dialogue: 0,0:09:44.80,0:09:48.54,Default,,0,0,0,,此协议最关键的时刻在这里\NAnd the key moment in this protocol is here.
Dialogue: 0,0:09:48.54,0:09:55.96,Default,,0,0,0,,当参与节点回复给协调者\NSo, after the participating nodes have replied to the coordinator,
Dialogue: 0,0:09:55.96,0:09:59.02,Default,,0,0,0,,告诉协调者是否愿意提交此事务时\Nsaying whether or not they're willing to commit this transaction,
Dialogue: 0,0:09:59.02,0:10:03.48,Default,,0,0,0,,在这一时刻 协调者将决定提交事务还是中止事务\Nat this point, the coordinator makes the decision whether to commit or abort.
Dialogue: 0,0:10:03.48,0:10:06.64,Default,,0,0,0,,这的确是此协议最关键的时刻\NAnd this is really a key moment in the protocol.
Dialogue: 0,0:10:06.64,0:10:10.94,Default,,0,0,0,,现在 我们可以考虑一下 如果一些节点崩溃 会发生什么\NNow, we can think about what happens if some of these nodes crash.
Dialogue: 0,0:10:10.94,0:10:14.52,Default,,0,0,0,,如果数据库节点崩溃 则我们已经讨论过\NSo, if the database node crashes, then we've discussed that
Dialogue: 0,0:10:14.52,0:10:17.10,Default,,0,0,0,,这意味着事务协调者将会发现响应超时\Nthat means the transaction coordinator will timeout,
Dialogue: 0,0:10:17.10,0:10:20.16,Default,,0,0,0,,它会说：“每个人都中止事务吧”\Nand it will say, “OK, we're going to abort the transaction for everyone”.
Dialogue: 0,0:10:20.16,0:10:22.20,Default,,0,0,0,,这没什么问题\NSo, that's fine.
Dialogue: 0,0:10:22.20,0:10:26.28,Default,,0,0,0,,问题是 如果协调者崩溃 会发生什么\NThe question is what happens if the coordinator crashes.
Dialogue: 0,0:10:26.28,0:10:29.06,Default,,0,0,0,,如果协调者崩溃\NSo, if the coordinator crashes, well,
Dialogue: 0,0:10:29.06,0:10:33.98,Default,,0,0,0,,它可能已经作出了是否中止或提交事务的决定\Nfirst of all, it has to make this decision on whether to abort or commit the transaction.
Dialogue: 0,0:10:33.98,0:10:35.94,Default,,0,0,0,,它可以把决定写入磁盘\NSo, it can write that decision to disk.
Dialogue: 0,0:10:35.94,0:10:40.12,Default,,0,0,0,,当协调者随后从崩溃中恢复 重新回到岗位后\NAnd so, then, when the coordinator recovers from its crash and starts back up again,
Dialogue: 0,0:10:40.12,0:10:45.62,Default,,0,0,0,,它可以从磁盘中读取决定 并把已经作出的决定\Nit can read this decision from disk, and send the decision that it made
Dialogue: 0,0:10:45.62,0:10:49.18,Default,,0,0,0,,发送给参与此次事务的所有副本\Nto the replicas that were participating in the transaction.
Dialogue: 0,0:10:50.14,0:10:55.54,Default,,0,0,0,,如果磁盘中没有决策记录 则协调者可以直接中止事务\NOr, if there was no decision record on disk, then the coordinator can just abort.
Dialogue: 0,0:10:55.54,0:10:59.78,Default,,0,0,0,,但是 协调者必须做到的是 如果协调者崩溃\NBut it has to be even if the coordinator crashes,
Dialogue: 0,0:10:59.78,0:11:02.50,Default,,0,0,0,,且如果协调者在崩溃前已经决定提交事务\Nif it made the decision before the crash to commit,
Dialogue: 0,0:11:02.50,0:11:05.28,Default,,0,0,0,,那么协调者必须在重启后继续诚实地发送提交事务的决定\Nthen it must honor that decision after it restarts,
Dialogue: 0,0:11:05.28,0:11:06.54,Default,,0,0,0,,因为协调者可能已经把提交消息\Nbecause it might have already
Dialogue: 0,0:11:06.54,0:11:09.80,Default,,0,0,0,,发送给了部分节点 但还没有发送给所有的节点\Nsent the commit message to some of the nodes, but not all of them.
Dialogue: 0,0:11:10.50,0:11:13.82,Default,,0,0,0,,因此 一些节点可能已经完成提交 释放了所有的锁\NAnd so, some of the nodes may have already committed and released all of their locks.
Dialogue: 0,0:11:13.82,0:11:17.54,Default,,0,0,0,,此时 我们需要保证其它节点也要提交事务\NSo now, we have to ensure that everybody else commits as well.
Dialogue: 0,0:11:17.54,0:11:21.88,Default,,0,0,0,,类似地 如果一个节点中止 则其它所有节点也必须中止\NAnd likewise, if one aborts, then all of the others have to abort as well.
Dialogue: 0,0:11:21.88,0:11:23.32,Default,,0,0,0,,但这留给了我们一个问题\NBut this leaves us in a problem,
Dialogue: 0,0:11:23.32,0:11:27.84,Default,,0,0,0,,协调方现在成为了协议的卡点\Nbecause the coordinator is now this linchpin in this protocol,
Dialogue: 0,0:11:28.38,0:11:31.00,Default,,0,0,0,,如果协调者崩溃的时间点刚好为\Nbecause if the coordinator crashes
Dialogue: 0,0:11:31.00,0:11:34.78,Default,,0,0,0,,协调者已经发送出准备请求\Njust at the moment after the prepare requests have been sent out,
Dialogue: 0,0:11:34.78,0:11:37.52,Default,,0,0,0,,但还没有发送出\Nbut before the coordinator sent out its decision on
Dialogue: 0,0:11:37.52,0:11:39.86,Default,,0,0,0,,是否提交或中止事务的决定时\Nwhether to commit or abort the transaction,
Dialogue: 0,0:11:39.86,0:11:43.98,Default,,0,0,0,,此时 所有其他节点都不知道协调方作出了什么决定\Nthen all of the other nodes don't know what the coordinator has decided it.
Dialogue: 0,0:11:43.98,0:11:47.42,Default,,0,0,0,,它们会被卡住 它们无法终止事务\NThey are simply stuck. They cannot end their transaction yet.
Dialogue: 0,0:11:47.42,0:11:48.88,Default,,0,0,0,,它们不能中止事务\NThey can't abort their transaction,
Dialogue: 0,0:11:48.88,0:11:52.46,Default,,0,0,0,,因为我前面说过 它们必须保证它们有能力提交事务\Nbecause as I said earlier, they have promised that they will be able to commit it.
Dialogue: 0,0:11:52.46,0:11:54.96,Default,,0,0,0,,如果它们中止了事务 它们就无法保证有能力提交事务了\NSo, if they abort it, then they wouldn't be able to commit it anymore.
Dialogue: 0,0:11:54.96,0:11:57.86,Default,,0,0,0,,因此 它们不能提交或中止它们的事务\NSo, they can't commit or abort their transaction.
Dialogue: 0,0:11:57.86,0:12:05.96,Default,,0,0,0,,它们都会被卡在这种不确定事务状态的阶段中\NThey're all stuck in this state of being uncertain of what the state of the transaction is.
Dialogue: 0,0:12:06.88,0:12:12.06,Default,,0,0,0,,因此 独立节点无法自主决定提交还是中止事务\NAnd so, the individual nodes can't just decide for themselves to abort or commit,
Dialogue: 0,0:12:12.06,0:12:14.76,Default,,0,0,0,,因为这会引入违反原子性的风险\Nbecause that would risk violating atomicity.
Dialogue: 0,0:12:14.76,0:12:17.02,Default,,0,0,0,,因此 整个算法都被阻塞住了\NSo, the entire algorithm is blocked
Dialogue: 0,0:12:17.02,0:12:21.70,Default,,0,0,0,,直到协调方重启 并通过磁盘上的数据恢复它的状态\Nuntil the coordinator restarts and recovers its state from disk.
Dialogue: 0,0:12:21.70,0:12:22.68,Default,,0,0,0,,这可不太妙\NSo, this is not great,
Dialogue: 0,0:12:22.68,0:12:27.06,Default,,0,0,0,,因为如果协调者崩溃 它可能需要花费一定的时间才能再次回归\Nbecause if a coordinator crashes, it might take a while to come back up again.
Dialogue: 0,0:12:27.64,0:12:31.34,Default,,0,0,0,,如果运行协调者的机器遇到了硬件故障\NIf the machine where the coordinator was running on experience the hardware failure,
Dialogue: 0,0:12:31.34,0:12:33.84,Default,,0,0,0,,那就更糟糕了 因为得有个人\Nit's even worse, because somebody has to go
Dialogue: 0,0:12:33.84,0:12:37.70,Default,,0,0,0,,把机器中的磁盘取出来 放到一台新机器上\Nand take the hard disk out of that machine and put it into a new machine, and so on.
Dialogue: 0,0:12:37.70,0:12:40.84,Default,,0,0,0,,此时 整个系统都会瘫痪\NSo, the whole system could be down and locked up
Dialogue: 0,0:12:40.84,0:12:43.22,Default,,0,0,0,,在相当长的一段时间内处于锁定状态\Nfor quite a significant amount of time.
Dialogue: 0,0:12:43.22,0:12:46.16,Default,,0,0,0,,幸运的是 有种方法可以解决这个问题\NFortunately, there is a way around this.
Dialogue: 0,0:12:46.16,0:12:51.90,Default,,0,0,0,,有一种两阶段提交的变种算法 此算法具有容错性\NAnd there is an algorithm, a variant of two-phase commit that is fault-tolerant.
Dialogue: 0,0:12:51.90,0:12:55.02,Default,,0,0,0,,此算法依赖于我们上一节课讨论的技术\NAnd it relies on what we talked about in the last lecture,
Dialogue: 0,0:12:55.02,0:12:58.84,Default,,0,0,0,,依赖全序关系广播 又名共识算法\Non total order broadcast a.k.a., consensus algorithm.
Dialogue: 0,0:12:58.84,0:13:02.22,Default,,0,0,0,,算法的工作原理如下 这个算法只有两页幻灯片长\NAnd it works like this. This algorithm is just two slides long.
Dialogue: 0,0:13:03.28,0:13:08.38,Default,,0,0,0,,算法的基本思想是 我们使用全序关系广播算法\NAnd the idea here is that we use a total order broadcast algorithm
Dialogue: 0,0:13:08.38,0:13:14.58,Default,,0,0,0,,来散布每个节点有关提交或中止的投票结果\Nto disseminate each node's vote on whether to abort or to commit.
Dialogue: 0,0:13:14.58,0:13:18.14,Default,,0,0,0,,每一个节点都会存储一些状态\NAnd so, for each node, we're going to have some state here.
Dialogue: 0,0:13:18.14,0:13:22.88,Default,,0,0,0,,对于每一个事务 我们初始化一个集合（commitVotes）\NSo, for each transaction, we're going to have a set here
Dialogue: 0,0:13:22.88,0:13:28.12,Default,,0,0,0,,此集合包含为此事务投提交票的所有副本id\Ncontaining the replica ids that have voted in favor of committing a certain transaction.
Dialogue: 0,0:13:28.12,0:13:32.30,Default,,0,0,0,,我们还初始化一个集合（replicas） 包含参与此事务的所有节点\NWe have the set of all of the replicas that are participating in a certain transaction.
Dialogue: 0,0:13:32.30,0:13:34.18,Default,,0,0,0,,对于每一个事务 我们还设置一个标识（decided）\NAnd for each transaction, we have a flag
Dialogue: 0,0:13:34.18,0:13:37.20,Default,,0,0,0,,此标识告诉我们是否已经作出了决定\Ntelling us whether we have decided yet or not.
Dialogue: 0,0:13:37.20,0:13:42.42,Default,,0,0,0,,现在 当我们想提交一个事务\NAnd so, now, when we want to commit a transaction,
Dialogue: 0,0:13:42.42,0:13:48.04,Default,,0,0,0,,我们按照协调者通常的做法进行操作\Nwe do the same as we do what the coordinator would usually do, which is
Dialogue: 0,0:13:48.04,0:13:52.36,Default,,0,0,0,,我们向参与此事务的所有节点发送一条准备消息\Nit just sends a prepare message to all of the nodes participating in the transaction.
Dialogue: 0,0:13:52.36,0:13:55.24,Default,,0,0,0,,这就是和之前一样的常规准备消息\NOK, that's just a regular prepare message as before.
Dialogue: 0,0:13:55.24,0:13:59.34,Default,,0,0,0,,当一个节点或一个副本收到了这条准备消息\NWhen a node or a replica receives this prepare message,
Dialogue: 0,0:13:59.34,0:14:05.98,Default,,0,0,0,,它就知道了参与此事务的所有副本所构成的集合 称这个集合为R\Nit now knows the set of replicas that are participating in this transaction called R.
Dialogue: 0,0:14:05.98,0:14:11.26,Default,,0,0,0,,此副本记录下此集合 这就是参与事务T的副本集合\NSo, it remembers that. This is the set of replicas participating in transaction T.
Dialogue: 0,0:14:11.26,0:14:13.10,Default,,0,0,0,,现在 和之前一样\NAnd now, as before,
Dialogue: 0,0:14:13.10,0:14:17.20,Default,,0,0,0,,副本需要检查自己是否有能力提交此事务\Nthe replica needs to check whether it is able to commit the transaction.
Dialogue: 0,0:14:17.20,0:14:21.88,Default,,0,0,0,,它随后要用“是”或“否”来回复准备请求\NAnd it will reply to the prepare request, saying either yes or no.
Dialogue: 0,0:14:22.22,0:14:24.26,Default,,0,0,0,,如果副本回复“是” 它必须保证\NAnd if it says yes, it promises that
Dialogue: 0,0:14:24.26,0:14:27.14,Default,,0,0,0,,自己在未来一定能够提交此事务\Nwe'll definitely be able to commit this transaction in the future.
Dialogue: 0,0:14:27.14,0:14:30.42,Default,,0,0,0,,这里的ok就是一个布尔值 表示“是”或“否”\NSo, this ok will simply be a Boolean here, saying true or false,
Dialogue: 0,0:14:30.42,0:14:34.14,Default,,0,0,0,,即此副本是否有能力提交此事务\Nwhether it is able to commit the transaction or not.
Dialogue: 0,0:14:34.14,0:14:37.68,Default,,0,0,0,,现在 我们不把投票发送回协调者\NAnd now, rather than sending this vote back to the coordinator,
Dialogue: 0,0:14:37.68,0:14:40.14,Default,,0,0,0,,我们使用全序关系广播\Nwe use total order broadcast to
Dialogue: 0,0:14:40.14,0:14:45.20,Default,,0,0,0,,将此投票发送给所有参与此事务的副本\Nsend this vote to all of the replicas that are participating in this transaction.
Dialogue: 0,0:14:45.20,0:14:50.72,Default,,0,0,0,,现在 所有副本互相都将知道谁有能力提交哪个事务\NSo now, all of the replicas find out about each other of who is able to commit what.
Dialogue: 0,0:14:51.60,0:14:54.02,Default,,0,0,0,,这几乎要达到我们的目的了\NAnd this gets us most of the way there.
Dialogue: 0,0:14:54.02,0:14:57.04,Default,,0,0,0,,现在的问题是 如果其中一个副本崩溃了 该怎么办\NThe question is just what if one of these replicas has crashed.
Dialogue: 0,0:14:57.04,0:15:02.24,Default,,0,0,0,,如果一个节点已经崩溃 则这个节点就无法广播投票\NAnd so, if that replica has crashed, then it is not able to broadcast its vote.
Dialogue: 0,0:15:02.24,0:15:07.58,Default,,0,0,0,,因此 所有节点都将卡在这里 一直等待下去 但此投票永远不会出现\NSo, all of the others would be stuck waiting forever until this vote never turns up.
Dialogue: 0,0:15:07.58,0:15:11.74,Default,,0,0,0,,因此 我们额外需要的是一个失效检查器\NSo, what we have in addition is a failure detector.
Dialogue: 0,0:15:11.74,0:15:16.06,Default,,0,0,0,,失效检查器可以运行在任意节点上\NAnd this failure detector, this can be running on any node,
Dialogue: 0,0:15:16.06,0:15:19.78,Default,,0,0,0,,例如 可以运行在其他数据库副本上 甚至可以运行在客户端上\Nfor example, on some of the other database replicas, or even on the client.
Dialogue: 0,0:15:20.46,0:15:24.94,Default,,0,0,0,,此失效检查器只是检查并怀疑某个副本是否已经出现了故障\NAnd it just checks whether it suspects any of the replicas to have failed.
Dialogue: 0,0:15:24.94,0:15:28.28,Default,,0,0,0,,如果某个节点向某个副本发送了准备请求\NSo, if it has sent the prepare request to some replica,
Dialogue: 0,0:15:28.28,0:15:33.08,Default,,0,0,0,,但此副本在一定时间内没有广播它的投票 此节点的投票超时了\Nand the replica has not broadcast its vote yet after some amount of time, some time out,
Dialogue: 0,0:15:33.08,0:15:38.52,Default,,0,0,0,,则运行失效检查器的节点将代表此副本广播一个投票\Nthen this other node is just going to broadcast a vote on behalf of the replica
Dialogue: 0,0:15:38.52,0:15:41.94,Default,,0,0,0,,内容是它怀疑此副本出现了故障 它代替此副本投“否”\Nthat it has suspected to have failed, and it just votes false.
Dialogue: 0,0:15:41.94,0:15:45.62,Default,,0,0,0,,也就是说 此节点将代表此副本投中止票\NSo, it votes to abort on behalf of this replica.
Dialogue: 0,0:15:45.62,0:15:49.80,Default,,0,0,0,,你可以看到 现在可能发生的一件事情是\NNow, what could happen, as you can see here, is that actually, it could be that
Dialogue: 0,0:15:49.80,0:15:55.06,Default,,0,0,0,,被怀疑已经崩溃的节点可能并没有真正崩溃\Nthe replica here that is suspected to have crashed hasn't actually crashed.
Dialogue: 0,0:15:55.06,0:15:57.28,Default,,0,0,0,,它可能还好好的 只是消息处理的有点慢\NIt might be fine. It might just be a bit slow.
Dialogue: 0,0:15:57.28,0:16:01.84,Default,,0,0,0,,因此 我们可能在几乎相同的时刻\NAnd so, it could be that just around about the same time,
Dialogue: 0,0:16:01.84,0:16:04.82,Default,,0,0,0,,得到两个针对同一副本的不同投票结果\Nwe get two conflicting votes for the same replica,
Dialogue: 0,0:16:04.82,0:16:10.54,Default,,0,0,0,,一个是副本本身发送的真实投票\Nthat is, one genuine vote from the replica that the replica itself is sending,
Dialogue: 0,0:16:10.54,0:16:14.10,Default,,0,0,0,,一个是来自其他一个甚至多个副本的投票\Nand one vote or maybe even several votes from other replicas
Dialogue: 0,0:16:14.10,0:16:17.46,Default,,0,0,0,,它们认为这个副本已经出现了故障\Nwho think this particular node has failed.
Dialogue: 0,0:16:17.46,0:16:21.72,Default,,0,0,0,,我们现在要依赖全序关系广播的性质\NAnd so, now, we are relying on the property of total order broadcast,
Dialogue: 0,0:16:21.72,0:16:25.88,Default,,0,0,0,,即系统中的所有参与方、系统中的所有节点\Nwhich is all of the participants, all of the nodes in the system
Dialogue: 0,0:16:25.88,0:16:28.66,Default,,0,0,0,,都将按照相同的顺序传递相同的消息\Nwill deliver the same messages in the same order.
Dialogue: 0,0:16:28.66,0:16:30.04,Default,,0,0,0,,正式这个性质\NAnd because of that,
Dialogue: 0,0:16:30.04,0:16:34.32,Default,,0,0,0,,使得针对相同副本的不同投票结果不会出现竞争问题\Nthis race between the different votes for the same replica is no longer a problem,
Dialogue: 0,0:16:34.32,0:16:36.84,Default,,0,0,0,,因为我们可以保证\Nbecause we can ensure that
Dialogue: 0,0:16:37.36,0:16:43.40,Default,,0,0,0,,所有节点看到的第一个针对给定副本的投票结果都是一样的\Nthe first vote that we see from a given replica will be the same for all of the nodes.
Dialogue: 0,0:16:43.40,0:16:45.42,Default,,0,0,0,,因此 这意味着\NAnd so, this means, here,
Dialogue: 0,0:16:45.42,0:16:50.38,Default,,0,0,0,,我们无论通过全序关系广播传递了哪一个投票结果\Nwhenever we deliver one of these votes here by total order broadcast,
Dialogue: 0,0:16:50.38,0:16:56.28,Default,,0,0,0,,我们只需要考虑给定副本的第一个投票结果 忽略未来所有的投票结果\Nwe can just consider the first vote from any given replica and ignore any future votes.
Dialogue: 0,0:16:56.28,0:16:59.78,Default,,0,0,0,,这将保证所有节点都会作出相同的决定\NAnd this will ensure that all of the nodes then come to the same decision
Dialogue: 0,0:16:59.78,0:17:02.86,Default,,0,0,0,,判断是中止还是提交事务\Nas to whether to abort or commit the transaction.
Dialogue: 0,0:17:02.86,0:17:04.54,Default,,0,0,0,,首先\NSo, first of all, here,
Dialogue: 0,0:17:04.54,0:17:10.86,Default,,0,0,0,,如果投票的副本不在已经投提交票的副本集合中\Nif the replica that is voting is not already one of the votes that has committed,
Dialogue: 0,0:17:10.86,0:17:14.22,Default,,0,0,0,,且如果副本是参与事务T的副本\Nand if the replica is one of the replicas in the transaction T,
Dialogue: 0,0:17:14.22,0:17:17.32,Default,,0,0,0,,且我们还没有为事务T作出决定\Nand we have not already made a decision for transaction T,
Dialogue: 0,0:17:17.32,0:17:20.74,Default,,0,0,0,,则这里的ok决定了此节点的投票结果为“是”还是“否”\Nthen, well, ok depends whether we voted in favor or not.
Dialogue: 0,0:17:20.74,0:17:24.26,Default,,0,0,0,,如果投票结果为“是” 意思是投票给提交事务\NSo, if we voted true, which means vote in favor of committing,
Dialogue: 0,0:17:24.26,0:17:28.16,Default,,0,0,0,,我们将此副本的id（replicaId）添加至\Nthen we add the replica id to the set of replicas
Dialogue: 0,0:17:28.16,0:17:32.14,Default,,0,0,0,,投票给支持提交事务的副本集合中\Nthat have voted in favor of committing this particular transaction.
Dialogue: 0,0:17:32.14,0:17:35.14,Default,,0,0,0,,如果投提交票的副本所构成的集合\NAnd if this set of replicas that have voted in favor
Dialogue: 0,0:17:35.14,0:17:38.66,Default,,0,0,0,,等于所有参与此事务的全部副本所构成的集合\Nequals the set of all replicas participating in the transaction,
Dialogue: 0,0:17:38.66,0:17:42.04,Default,,0,0,0,,这意味着我们现在得到了统一的投票结果\Nthat means now we have the unanimity that we require.
Dialogue: 0,0:17:42.04,0:17:47.06,Default,,0,0,0,,我们可以决定提交此事务 并在此节点完成提交操作\NWe can decide to commit the transaction and do the actual commit at this node.
Dialogue: 0,0:17:47.06,0:17:54.32,Default,,0,0,0,,另一方面 如果其中一个投票为“否” 即表示反对提交\NOn the other hand, if the vote was false, it was in against committing,
Dialogue: 0,0:17:54.32,0:17:56.16,Default,,0,0,0,,这意味着我们可以立刻中止\Nthat means we can immediately abort,
Dialogue: 0,0:17:56.16,0:18:00.34,Default,,0,0,0,,因为一个反对票已经足以让我们抛弃整个事务了\Nbecause one single vote against is already enough to discard the whole transaction.
Dialogue: 0,0:18:00.34,0:18:03.48,Default,,0,0,0,,我们可以将decided标识设置为“真”\NWe can set our flag to be decided to be true,
Dialogue: 0,0:18:03.48,0:18:06.58,Default,,0,0,0,,我们在这个节点中止事务\Nand then we're going to abort the transaction at this node.
Dialogue: 0,0:18:06.58,0:18:12.60,Default,,0,0,0,,如果你仔细考虑一下 我们这里的逻辑保证\NAnd if you think about this, the logic that we have here ensures that
Dialogue: 0,0:18:12.60,0:18:16.76,Default,,0,0,0,,我们只需要考虑任意给定副本的第一个投票结果\Nwe only count the first vote from any given replica,
Dialogue: 0,0:18:16.76,0:18:22.42,Default,,0,0,0,,因为所有节点都会约定好按照相同的顺序传递投票结果\Nand because all of the nodes will agree when they're delivering these votes.
Dialogue: 0,0:18:22.42,0:18:25.84,Default,,0,0,0,,它们会约定好给定副本的第一张投票结果是什么\NThey will agree on which the first vote was from a given replica.
Dialogue: 0,0:18:25.84,0:18:29.60,Default,,0,0,0,,这将保证所有参与方都可以看到相同的投票结果\NThis will ensure that all of the participants see the same
Dialogue: 0,0:18:29.60,0:18:33.94,Default,,0,0,0,,并针对提交还是中止此事务作出相同的决定\Nand come to the same decision as to whether to commit or abort this transaction.
Dialogue: 0,0:18:33.94,0:18:35.06,Default,,0,0,0,,这个协议很不错吧？\NIsn't that nice?
Dialogue: 0,0:18:35.06,0:18:37.68,Default,,0,0,0,,我们有了全序关系广播算法\NWe have this total order broadcast algorithm,
Dialogue: 0,0:18:37.68,0:18:43.48,Default,,0,0,0,,我们以一种相当简单的方式用它来解决这个完全不同的问题\Nand we can use it to solve this quite different problem in a reasonably simple way.
