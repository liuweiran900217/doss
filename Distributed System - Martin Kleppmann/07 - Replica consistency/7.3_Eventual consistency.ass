[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 7.3_Eventual consistency.mp4
Video File: 7.3_Eventual consistency.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.125000
Scroll Position: 176
Active Line: 204
Video Position: 22707

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,35,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,{\pos(639,50)}听译、时间轴：刘巍然（学酥）
Dialogue: 0,0:00:00.60,0:00:02.82,Default,,0,0,0,,我们已经讨论了线性一致性\NSo, we've talked about linearizability
Dialogue: 0,0:00:02.82,0:00:06.16,Default,,0,0,0,,这是分布式系统可能的一个一致性模型\Nas one possible consistency model for distributed systems,
Dialogue: 0,0:00:06.16,0:00:08.50,Default,,0,0,0,,这是一个非常强的一致性模型\Nwhich is a very strong consistency model.
Dialogue: 0,0:00:08.50,0:00:12.56,Default,,0,0,0,,我前面讲过 线性一致性模型拥有一个非常吸引人的性质\NAnd we said it has the very appealing property that
Dialogue: 0,0:00:12.56,0:00:16.64,Default,,0,0,0,,此模型让分布式系统看起来就像是没有副本一样\Nit actually makes a replicated system look as if it were not replicated.
Dialogue: 0,0:00:16.64,0:00:19.40,Default,,0,0,0,,此让系统看起来像是只有单一数据副本\NIt looks as if there was only a single copy of the data,
Dialogue: 0,0:00:19.40,0:00:21.78,Default,,0,0,0,,所有的操作都满足原子性\Nand all of the operations on it are atomic,
Dialogue: 0,0:00:21.78,0:00:25.86,Default,,0,0,0,,这使得线性一致性模型成为了一个非常易于使用的一致性模型\Nwhich makes linearizability a very easy-to-use consistency model.
Dialogue: 0,0:00:25.86,0:00:29.40,Default,,0,0,0,,你基本上不需要再考虑系统是否是分布式的了\NYou basically don't have to think about the fact that your system is distributed,
Dialogue: 0,0:00:29.40,0:00:32.58,Default,,0,0,0,,系统会按照你所期望的那样运作\Nand it just kind of works in the way you might expect.
Dialogue: 0,0:00:33.16,0:00:35.54,Default,,0,0,0,,不幸的是 这是有代价的\NUnfortunately, it comes at a price as well.
Dialogue: 0,0:00:35.54,0:00:40.32,Default,,0,0,0,,线性一致性模型并不能适用于所有可能的情况\NSo, linearizability is not actually suitable in all possible circumstances
Dialogue: 0,0:00:40.32,0:00:41.40,Default,,0,0,0,,原因如下\Nfor several reasons.
Dialogue: 0,0:00:41.40,0:00:45.48,Default,,0,0,0,,一种可能的原因是 实现此模型的代价非常大\NOne possible reason is that it's actually quite expensive to implement.
Dialogue: 0,0:00:45.48,0:00:47.60,Default,,0,0,0,,观察一下我们前面讨论的协议\NIf you look at the protocols that we discussed,
Dialogue: 0,0:00:47.60,0:00:52.50,Default,,0,0,0,,会发现协议会来回传输大量的消息 协议会涉及大量的等待响应步骤\Nthere are lots of messages going back and forth, lots of waiting for responses,
Dialogue: 0,0:00:52.50,0:00:56.24,Default,,0,0,0,,大多数响应都需要两轮往返通信\Nprobably something like two round trips for most requests.
Dialogue: 0,0:00:56.90,0:01:00.20,Default,,0,0,0,,因此 协议性能有一点慢\NSo, it's just going to be a bit slow basically.
Dialogue: 0,0:01:00.82,0:01:03.50,Default,,0,0,0,,另一个限制是\NAnother limitation is the scalability
Dialogue: 0,0:01:03.50,0:01:06.86,Default,,0,0,0,,系统的扩展性可能依赖于你所使用的具体算法\Npotentially depends a bit on the exact algorithm you're using.
Dialogue: 0,0:01:06.86,0:01:10.98,Default,,0,0,0,,举例来说 如果你使用类似Raft的共识算法\NBut if you're using a consensus algorithm like Raft, for example,
Dialogue: 0,0:01:10.98,0:01:13.94,Default,,0,0,0,,则所有更新操作都必须经过主节点排序\Nall of the updates have to be sequenced through the leader.
Dialogue: 0,0:01:13.94,0:01:17.58,Default,,0,0,0,,也就是说 所有的更新操作都会流经某个单一节点\NSo, there's a single node that all of the updates have to flow through.
Dialogue: 0,0:01:17.58,0:01:22.56,Default,,0,0,0,,因此 此类系统的扩展性受到单一节点能力的限制\NAnd so, you are limited by the capacity of that one node in this kind of system.
Dialogue: 0,0:01:22.56,0:01:26.88,Default,,0,0,0,,也就是说 单一主节点会成为瓶颈\NThat one leader node can become a bottleneck.
Dialogue: 0,0:01:26.88,0:01:31.80,Default,,0,0,0,,进一步深入考虑此问题 就会发现\NAnd what is perhaps the most the deepest problem
Dialogue: 0,0:01:31.80,0:01:36.24,Default,,0,0,0,,线性一致性和类似的强一致性模型\Nwith linearizability and such strong consistency models,
Dialogue: 0,0:01:36.24,0:01:38.14,Default,,0,0,0,,都面临可用性问题\Nis problems with availability,
Dialogue: 0,0:01:38.14,0:01:42.94,Default,,0,0,0,,执行任何操作都需要与quorum节点联系\Nand that is, every operation that you do needs to contact a quorum of nodes.
Dialogue: 0,0:01:42.94,0:01:47.34,Default,,0,0,0,,这意味着如果你由于任何原因无法与quorum节点联系\NAnd that means if you can't contact a quorum of nodes for whatever reason,
Dialogue: 0,0:01:47.34,0:01:49.58,Default,,0,0,0,,例如你的网络中断了 或者由于其他什么原因\Nmaybe you're disconnected on the network, or so,
Dialogue: 0,0:01:49.58,0:01:51.68,Default,,0,0,0,,则你就无法处理任何操作\Nyou can't process any operations.
Dialogue: 0,0:01:51.68,0:01:57.28,Default,,0,0,0,,如果无法与quorum节点联系 你就无法执行任何读或写操作\NNeither reading nor writing is possible if you can't contact a quorum of nodes.
Dialogue: 0,0:01:57.28,0:02:01.30,Default,,0,0,0,,这也是人们提出替代一致性模型的原因\NAnd that's why alternative consistency models have been developed,
Dialogue: 0,0:02:01.30,0:02:03.32,Default,,0,0,0,,这些一致性模型会在不同层面进行权衡\Nwhich have different trade-offs,
Dialogue: 0,0:02:03.32,0:02:06.78,Default,,0,0,0,,让某些方面变得更好一些 同时某些方面会更差一些\Nwhich are better in some regards and worse in other regards.
Dialogue: 0,0:02:06.78,0:02:11.04,Default,,0,0,0,,我们在本节要学习其中一个替代一致性模型 称为最终一致性模型\NAnd the one that we will look at in this section is called eventual consistency.
Dialogue: 0,0:02:12.38,0:02:15.20,Default,,0,0,0,,我们用日历应用来举个例子\NAs an example, let's consider a calendar app.
Dialogue: 0,0:02:15.20,0:02:18.90,Default,,0,0,0,,屏幕左侧是在我计算机上运行的日历应用\NSo, here I have on the left-hand side, the calendar app running on my computer,
Dialogue: 0,0:02:18.90,0:02:21.70,Default,,0,0,0,,屏幕右侧是在我手机上运行的日历应用\Nand on the right-hand side, the calendar app running on my phone.
Dialogue: 0,0:02:21.70,0:02:24.52,Default,,0,0,0,,相信大家都了解日历应用的功能\NAnd you all know how this works.
Dialogue: 0,0:02:24.52,0:02:30.10,Default,,0,0,0,,我可以在左侧添加一个事项 如分布式系统课程（Distributed systems lecture）\NI can add an event on the left-hand side, say, Distributed systems lecture.
Dialogue: 0,0:02:34.60,0:02:40.12,Default,,0,0,0,,几秒钟后 这个事项会被同步到右侧的手机日历应用上\NAnd this will sync within a couple of seconds over to the phone on the right-hand side.
Dialogue: 0,0:02:40.12,0:02:43.06,Default,,0,0,0,,随后 手机日历应用上应该会出现相同的事项\NSo, then, the same event should appear there.
Dialogue: 0,0:02:43.06,0:02:44.00,Default,,0,0,0,,出现了\NHere we go.
Dialogue: 0,0:02:44.00,0:02:48.16,Default,,0,0,0,,类似地 我可以在手机上添加一个事项\NAnd similarly, I can add an event on the phone.
Dialogue: 0,0:02:48.16,0:02:53.82,Default,,0,0,0,,这个事项也会被同步到我的计算机上\NAnd this should sync over to the computer.
Dialogue: 0,0:02:53.82,0:02:59.36,Default,,0,0,0,,如果你仔细想想 就会发现我们拥有的是一个复制系统\NNow, what we've got here, if you think about it, is a replicated system.
Dialogue: 0,0:02:59.36,0:03:01.76,Default,,0,0,0,,我的计算机上有一份日历的拷贝\NWe've got a copy of the calendar on my computer
Dialogue: 0,0:03:01.76,0:03:04.18,Default,,0,0,0,,我的手机上有一份日历的拷贝\Nand another copy of the calendar on my phone.
Dialogue: 0,0:03:04.18,0:03:07.96,Default,,0,0,0,,这两个副本是相互独立的\NAnd these two replicas are independent from each other
Dialogue: 0,0:03:07.96,0:03:11.68,Default,,0,0,0,,证明这一点的方法是 我可以把我的手机调节成飞行模式\Nin the sense that I can put my phone into airplane mode,
Dialogue: 0,0:03:11.68,0:03:14.80,Default,,0,0,0,,从而阻止两个设备\Nand now I have prevented any communication
Dialogue: 0,0:03:14.80,0:03:18.34,Default,,0,0,0,,通过任何方式进行通信\Nbetween these two devices from happening.
Dialogue: 0,0:03:18.34,0:03:21.58,Default,,0,0,0,,举例来说 我可以在我的计算机上\NAnd so, I could, for example, on my computer now,
Dialogue: 0,0:03:21.58,0:03:25.60,Default,,0,0,0,,把分布式系统课程的时间改成上午10:00\Nchange the time of the Distributed systems lecture to 10:00 am.
Dialogue: 0,0:03:25.60,0:03:29.92,Default,,0,0,0,,修改并不会被同步到我的手机上 因为我的手机无法与外界通信\NAnd this won't sync over to my phone, because my phone is unable to communicate.
Dialogue: 0,0:03:29.92,0:03:37.28,Default,,0,0,0,,我在手机上把事件标题改为分布式系统第1课（Distributed systems lecture 1）\NAnd let's say on my phone, I change the title to, say, Distributed systems lecture 1.
Dialogue: 0,0:03:37.28,0:03:44.52,Default,,0,0,0,,截至最终关闭飞行模式之前 修改也不会被同步到我的计算机上\NAnd this also won't sync back to the computer until I eventually turn off airplane mode.
Dialogue: 0,0:03:44.52,0:03:48.06,Default,,0,0,0,,现在 我关闭了飞行模式\NAnd so, now, after airplane mode is off,
Dialogue: 0,0:03:48.06,0:03:52.40,Default,,0,0,0,,两个设备现在可以再次相互同步\Nnow the two devices should be able to sync up with each other again.
Dialogue: 0,0:03:52.40,0:03:55.86,Default,,0,0,0,,一台设备上的修改结果应该会被传播到另一台设备上\NAnd the changes from one should propagate over to the other.
Dialogue: 0,0:03:55.86,0:03:57.94,Default,,0,0,0,,你可以看到 现在发生的情况是\NSo, you can see what has happened now is
Dialogue: 0,0:03:58.40,0:04:02.74,Default,,0,0,0,,两个设备的事项发生事件都变为了上午10:00\Nthe time of this event has moved to 10:00 am on both devices,
Dialogue: 0,0:04:02.74,0:04:08.40,Default,,0,0,0,,但标题“分布式系统课程”改成“分布式系统第1课”\Nbut my change, changing the title Distributed systems lecture, I changed it to lecture 1,
Dialogue: 0,0:04:08.40,0:04:12.06,Default,,0,0,0,,这一标题修改结果不知何故从设备上消失了\Nbut that change of the title has somehow disappeared.
Dialogue: 0,0:04:12.06,0:04:15.04,Default,,0,0,0,,我们这里遇到了冲突\NAnd so, what we have here is a conflict,
Dialogue: 0,0:04:15.04,0:04:20.46,Default,,0,0,0,,因为我在两个不同的设备上并发修改了同一个日历事项\Nbecause I concurrently edited the same calendar event on two different devices
Dialogue: 0,0:04:20.46,0:04:22.64,Default,,0,0,0,,而两个设备在修改时处于断开连接的状态\Nwhile they were disconnected from each other.
Dialogue: 0,0:04:22.64,0:04:27.28,Default,,0,0,0,,当发生冲突时 我们需要解决冲突\NAnd we had a conflict resolution that had to happen here.
Dialogue: 0,0:04:27.28,0:04:32.78,Default,,0,0,0,,很明显 我的日历应用在这里使用了“最后写入胜利”的解决方法\NAnd what my calendar app did apparently was a last-writer-wins resolution,
Dialogue: 0,0:04:32.78,0:04:37.70,Default,,0,0,0,,在这种情况下 把时间更新为上午10:00的操作优先级\Nin which case, in this case, the update of the time to 10:00 am
Dialogue: 0,0:04:37.70,0:04:42.26,Default,,0,0,0,,在某种程度上高于更新标题操作的优先级\Nsomehow took precedence over the update of the title.
Dialogue: 0,0:04:42.26,0:04:44.98,Default,,0,0,0,,因此 更新标题的操作被丢弃了\NAnd so, the update of the title was discarded
Dialogue: 0,0:04:44.98,0:04:49.74,Default,,0,0,0,,更新时间的操作在两个设备上均生效\Nwhile the update of the time took effect on both devices.
Dialogue: 0,0:04:49.74,0:04:52.88,Default,,0,0,0,,因此 即使这里丢失了部分数据\NSo, even though some data was lost here,
Dialogue: 0,0:04:52.88,0:04:58.34,Default,,0,0,0,,但我们至少保证两个设备最终处于一致的状态\Nbut at least we did end up with both devices being in a consistent state eventually.
Dialogue: 0,0:04:58.34,0:05:00.78,Default,,0,0,0,,诸如日历应用这样的系统\NThese systems, such like the calendar app,
Dialogue: 0,0:05:00.78,0:05:06.14,Default,,0,0,0,,可以用分布式系统中的CAP定理来形式化描述\Ncan be formalized using this result from distributed systems called the CAP theorem.
Dialogue: 0,0:05:06.14,0:05:08.60,Default,,0,0,0,,CAP定理背后的基本思想非常简单\NAnd this idea behind this is fairly simple.
Dialogue: 0,0:05:08.60,0:05:12.80,Default,,0,0,0,,你有一个存在网络分区的系统\NIt is, say, you have a system in which there's a network partition,
Dialogue: 0,0:05:12.80,0:05:13.22,Default,,0,0,0,,也就是说\Nthat is,
Dialogue: 0,0:05:13.22,0:05:18.78,Default,,0,0,0,,一个子集的节点无法与另一个子集的节点通信\None subset of the nodes is unable to communicate with some other subset of the nodes.
Dialogue: 0,0:05:18.78,0:05:21.28,Default,,0,0,0,,在这种情况下 我们需要做出一个选择\NIn this case, we have to make a choice,
Dialogue: 0,0:05:21.28,0:05:24.40,Default,,0,0,0,,我们可以继续提供线性一致性\Neither we can continue providing linearizability,
Dialogue: 0,0:05:24.40,0:05:27.38,Default,,0,0,0,,但一部分节点可能无法处理请求\Nbut some of the nodes won't be able to process requests,
Dialogue: 0,0:05:27.38,0:05:34.74,Default,,0,0,0,,我们也可以在不与quorum联系的条件下处理请求和操作\Nor we allow requests and operations to continue without contacting a quorum,
Dialogue: 0,0:05:34.74,0:05:38.04,Default,,0,0,0,,但这种情况下 我们有违反线性一致性的风险\Nbut in that case, we risk violating linearizability.
Dialogue: 0,0:05:38.04,0:05:42.38,Default,,0,0,0,,在存在网络分区时 我们必须做出一个选择\NAnd so, we have to just make this choice in the presence of a network partition.
Dialogue: 0,0:05:42.38,0:05:43.54,Default,,0,0,0,,这里有个演示\NIllustrated here.
Dialogue: 0,0:05:43.54,0:05:47.56,Default,,0,0,0,,左侧是隔离节点A和B 它们形成了一个quorum\NSo, we've got on the left-hand side of the partition nodes A and B, which form a quorum,
Dialogue: 0,0:05:47.56,0:05:52.22,Default,,0,0,0,,它们可以继续为操作提供满足线性一致性的服务\Nand they can continue providing a linearizable service for these operations.
Dialogue: 0,0:05:52.22,0:05:56.26,Default,,0,0,0,,但右侧的节点C陷入了两难的困境\NBut node C here on the right-hand side is stuck in this dilemma,
Dialogue: 0,0:05:56.26,0:05:58.14,Default,,0,0,0,,因为节点C\Nbecause either the node C
Dialogue: 0,0:05:58.14,0:06:02.84,Default,,0,0,0,,或者必须等待网络分区被修复 使它能够与quorum通信\Nhas to wait for this network partition to be healed before it can reach a quorum,
Dialogue: 0,0:06:03.42,0:06:06.34,Default,,0,0,0,,这可能需要无限长的事件\Nwhich might take indefinite amount of time.
Dialogue: 0,0:06:06.34,0:06:08.30,Default,,0,0,0,,在这个时间段内\NAnd so, during that time,
Dialogue: 0,0:06:08.30,0:06:12.94,Default,,0,0,0,,节点C实际上是不可用的 无法处理任何请求\Nnode C is effectively unavailable, and not able to process any requests.
Dialogue: 0,0:06:12.94,0:06:16.18,Default,,0,0,0,,节点C也可以使用本地状态继续处理请求\NOr node C just goes ahead and uses its local state,
Dialogue: 0,0:06:16.18,0:06:19.94,Default,,0,0,0,,但在这种情况下 节点C无法知道A写入了v_1\Nbut in that case, it won't know about the value v_1 that was written by A.
Dialogue: 0,0:06:19.94,0:06:23.52,Default,,0,0,0,,因此 我们在这种情况下会违反线性一致性\NSo, in this case, we will have violated linearizability.
Dialogue: 0,0:06:23.52,0:06:26.44,Default,,0,0,0,,当系统可能出现网络分区时\NAnd so, this is just a fundamental choice that you have to make
Dialogue: 0,0:06:26.44,0:06:31.08,Default,,0,0,0,,我们必须要做出一个选择\Nin a system in which network partitions might occur.
Dialogue: 0,0:06:31.08,0:06:33.32,Default,,0,0,0,,最终一致性\NAnd eventual consistency
Dialogue: 0,0:06:33.32,0:06:40.08,Default,,0,0,0,,是人们经常使用的另一类一致性模型\Nis sort of the broad category of consistency models that typically people move to
Dialogue: 0,0:06:40.08,0:06:43.16,Default,,0,0,0,,当不想假设节点能随时与quorum通信时\Nif they don't want to make an assumption of
Dialogue: 0,0:06:43.16,0:06:45.54,Default,,0,0,0,,就可以使用最终一致性模型\Nbeing able to communicate with a quorum, something like that.
Dialogue: 0,0:06:45.54,0:06:51.72,Default,,0,0,0,,如果我们想让每个副本都有能力基于本地状态处理操作\NSo, if we want each replica to be able to process operations just based on its local state
Dialogue: 0,0:06:51.72,0:06:55.36,Default,,0,0,0,,处理操作时不需要等待quorum的响应\Nand without waiting for a communication with a quorum,
Dialogue: 0,0:06:55.36,0:07:00.36,Default,,0,0,0,,那我们就无法满足线性一致性 但我们可以满足较弱的一致性模型\Nwe cannot achieve linearizability, but we can achieve weaker consistency models.
Dialogue: 0,0:07:00.36,0:07:04.92,Default,,0,0,0,,最终一致性模型一般按照下述方法定义\NAnd the way eventual consistency is usually defined is like this.
Dialogue: 0,0:07:04.92,0:07:11.56,Default,,0,0,0,,首先 一个副本可以基于本地状态处理任意读请求\NFirst of all, any read requests, a replica can just process based on its local state.
Dialogue: 0,0:07:11.56,0:07:17.78,Default,,0,0,0,,随后 每当一个副本应用了某个更新\NAnd then, whenever some updates get applied to one replica,
Dialogue: 0,0:07:17.78,0:07:22.34,Default,,0,0,0,,它们最终会在某个时刻将更新漫游到其他副本上\Nthey will eventually wander over the network at some point to other replicas.
Dialogue: 0,0:07:22.34,0:07:24.76,Default,,0,0,0,,我们想要保证的是\NAnd what we want to guarantee is that
Dialogue: 0,0:07:24.76,0:07:28.10,Default,,0,0,0,,如果我们假设在某个时刻更新能够停止\Nif we assume that at some point the updates stop,
Dialogue: 0,0:07:28.10,0:07:30.70,Default,,0,0,0,,则在更新停止后\Nthen eventually after the updates have stopped,
Dialogue: 0,0:07:30.70,0:07:33.80,Default,,0,0,0,,所有副本最终可以处于相同的状态\Nthen all of the replicas end up in the same state.
Dialogue: 0,0:07:33.80,0:07:37.94,Default,,0,0,0,,这么定义没问题 但这是一个相当弱的一致性模型\NNow, this is OK, but it's a fairly weak property,
Dialogue: 0,0:07:37.94,0:07:41.12,Default,,0,0,0,,举例来说 如果更新永远不会停止呢？\Nbecause, for example, what if the updates never stop?
Dialogue: 0,0:07:41.12,0:07:45.60,Default,,0,0,0,,可能存在一个更新或处理过程永远不会停止的系统\NYou could have a system in which continually updates or process, non-stop.
Dialogue: 0,0:07:45.60,0:07:50.82,Default,,0,0,0,,最终一致性没有定义这种情况下会发生什么\NAnd so, in this case, eventual consistency does not define what will happen in that case,
Dialogue: 0,0:07:50.82,0:07:55.64,Default,,0,0,0,,因为这种情况不满足最终一致性的前提条件\Nbecause the premise of the statement of this definition is not true.
Dialogue: 0,0:07:55.64,0:07:57.94,Default,,0,0,0,,因此 人们所做的是\NSo, what people have done is
Dialogue: 0,0:07:57.94,0:08:03.02,Default,,0,0,0,,定义一种比最终一致性稍强的一致性定义\Nto define an alternative slight strengthening of eventual consistency
Dialogue: 0,0:08:03.02,0:08:05.10,Default,,0,0,0,,称为强最终一致性\Ncalled strong eventual consistency,
Dialogue: 0,0:08:05.10,0:08:07.08,Default,,0,0,0,,此一致性模型额外定义了两个性质\Nwhich is defined with two properties.
Dialogue: 0,0:08:07.08,0:08:12.50,Default,,0,0,0,,第一个性质是 任意作用在一个副本上的更新操作\NSo, first of all, we say that any update that has been made on one replica
Dialogue: 0,0:08:12.50,0:08:15.68,Default,,0,0,0,,最终一定也会作用在另一个副本上\Nwill eventually also be made on another replica.
Dialogue: 0,0:08:15.68,0:08:18.28,Default,,0,0,0,,也就是说 更新操作会散布到整个网络中\NSo, updates get disseminated over the network.
Dialogue: 0,0:08:18.28,0:08:21.10,Default,,0,0,0,,我们不保证更新操作需要花多长时间才能散布到其他节点\NWe don't make any guarantees about how long that's going to take.
Dialogue: 0,0:08:21.10,0:08:23.76,Default,,0,0,0,,我们只是说最终会散布完毕\NWe just say eventually this will happen.
Dialogue: 0,0:08:23.76,0:08:25.06,Default,,0,0,0,,第二个性质是\NAnd secondly,
Dialogue: 0,0:08:25.06,0:08:29.22,Default,,0,0,0,,当两个副本处理的更新操作所构成的集合相同\Nwhenever you have two replicas that have processed the same set of updates,
Dialogue: 0,0:08:29.22,0:08:31.72,Default,,0,0,0,,则这两个副本必须具有相同的状态\Nthen those replicas must be in the same state,
Dialogue: 0,0:08:31.72,0:08:35.60,Default,,0,0,0,,对于任意读请求 它们必须返回相同的结果\Nand thus, they will return the same results to any read requests.
Dialogue: 0,0:08:35.60,0:08:37.04,Default,,0,0,0,,即使这些更新操作\NAnd this must hold
Dialogue: 0,0:08:37.04,0:08:42.66,Default,,0,0,0,,实际上是在不同副本按照不同的顺序应用的 此性质也必须得到满足\Neven if those updates were actually applied in a different order on different replicas.
Dialogue: 0,0:08:42.66,0:08:46.34,Default,,0,0,0,,因此 这就回到\NAnd so, this comes back down to
Dialogue: 0,0:08:46.34,0:08:51.92,Default,,0,0,0,,我们前面介绍的因果关系广播复制协议了\Nthe causal broadcast-based replication protocols that we saw earlier, for example,
Dialogue: 0,0:08:51.92,0:08:56.62,Default,,0,0,0,,当状态操作函数满足交换律时\Nwhere if you have commutative operations for operating the state,
Dialogue: 0,0:08:56.62,0:09:01.58,Default,,0,0,0,,就可以让不同副本按照不同的顺序应用更新操作\Nthen you can have different replicas updating the state in a different order,
Dialogue: 0,0:09:01.58,0:09:04.80,Default,,0,0,0,,且保证副本都会收敛到相同的最终状态\Nand still converging to the same final state.
Dialogue: 0,0:09:04.80,0:09:06.64,Default,,0,0,0,,这个收敛思想\NAnd so, this idea of convergence
Dialogue: 0,0:09:06.64,0:09:13.74,Default,,0,0,0,,是满足最终一致性和强最终一致性的关键\Nis really at the core of eventual consistency and strong eventual consistency.
Dialogue: 0,0:09:13.74,0:09:16.70,Default,,0,0,0,,最终一致性和强最终一致性\NNow, both eventual consistency and strong eventual consistency
Dialogue: 0,0:09:16.70,0:09:18.48,Default,,0,0,0,,都具有非常好的性质\Nhave some very nice properties.
Dialogue: 0,0:09:18.84,0:09:20.94,Default,,0,0,0,,如果你基于这个模型实现协议\NIf you want to implement this model,
Dialogue: 0,0:09:20.94,0:09:27.28,Default,,0,0,0,,则一个副本在执行操作时就不需要与其他副本通信了\Nthere is no need ever for an operation to wait for communication with another replica.
Dialogue: 0,0:09:27.28,0:09:30.06,Default,,0,0,0,,一个副本总能处理操作请求\NSo, a replica can always process operations.
Dialogue: 0,0:09:30.06,0:09:34.02,Default,,0,0,0,,读操作和写操作都可以在本地完成处理\NBoth reads and writes can be processed just locally
Dialogue: 0,0:09:34.02,0:09:35.74,Default,,0,0,0,,无需等待任何通信\Nwithout waiting for any communication.
Dialogue: 0,0:09:35.74,0:09:39.16,Default,,0,0,0,,当然了 有时后台还是会不可避免地进行一些通信\NOf course, eventually, sometime communication will have to happen in the background,
Dialogue: 0,0:09:39.16,0:09:41.20,Default,,0,0,0,,但操作过程无需等待任何通信\Nbut the operations don't have to wait for it,
Dialogue: 0,0:09:41.20,0:09:43.46,Default,,0,0,0,,这意味着操作处理过程总会非常迅速\Nwhich means that the operations can always be fast.
Dialogue: 0,0:09:43.46,0:09:45.46,Default,,0,0,0,,操作过程永远不涉及往返通信\NThey're never waiting for network round trips.
Dialogue: 0,0:09:45.46,0:09:47.68,Default,,0,0,0,,同时 操作过程总是可靠的\NAnd the operations can always be reliable,
Dialogue: 0,0:09:47.68,0:09:49.64,Default,,0,0,0,,因为即使出现网络中断\Nbecause even if the network is interrupted,
Dialogue: 0,0:09:49.64,0:09:53.64,Default,,0,0,0,,副本仍然可以继续处理操作\Nand a replica can continue processing operations.
Dialogue: 0,0:09:53.64,0:09:57.28,Default,,0,0,0,,我们可以使用\NAnd we can use these broadcast protocols of
Dialogue: 0,0:09:57.28,0:10:01.00,Default,,0,0,0,,因果关系广播、FIFO广播、或其他弱广播协议\Ncausal broadcast or FIFO broadcast or these other weaker broadcasts
Dialogue: 0,0:10:01.00,0:10:05.84,Default,,0,0,0,,来让一个副本向其他副本分发更新操作\Nas a way of distributing the updates from one replica to another.
Dialogue: 0,0:10:05.84,0:10:11.26,Default,,0,0,0,,最终一致性系统可能会面临的一个问题是\NNow, one problem that can arise with eventually consistent systems is that
Dialogue: 0,0:10:11.26,0:10:16.22,Default,,0,0,0,,多个副本可能会同时并发更新同一个对象或同一个数据项\Nthe same object or the same data item can be concurrently updated by multiple replicas.
Dialogue: 0,0:10:16.22,0:10:17.76,Default,,0,0,0,,无法阻止此类情况的发生\NAnd there's nothing stopping this of course,
Dialogue: 0,0:10:17.76,0:10:20.84,Default,,0,0,0,,因为多个副本在更新时不需要通信\Nbecause they cannot communicate necessarily.
Dialogue: 0,0:10:20.84,0:10:25.52,Default,,0,0,0,,由于我们会并发更新相同的对象\NAnd so, because we have these concurrent updates of the same object,
Dialogue: 0,0:10:25.52,0:10:27.12,Default,,0,0,0,,我们可能会遇到冲突\Nwe might have conflicts.
Dialogue: 0,0:10:27.12,0:10:31.16,Default,,0,0,0,,必须用一些方法来解决冲突问题\NAnd so, those conflicts will have to be resolved in some way or another.
Dialogue: 0,0:10:31.16,0:10:35.18,Default,,0,0,0,,我们在日历应用中看到的解决方法是最后写入方胜利策略\NWith the calendar app, what we saw is just the last-writer-wins policy,
Dialogue: 0,0:10:35.18,0:10:39.06,Default,,0,0,0,,即如果一个更新操作在另一个更新操作之后\Nwhere one of the updates took precedence over the other,
Dialogue: 0,0:10:39.06,0:10:40.70,Default,,0,0,0,,则较早的更新操作就被丢弃了\Nthe other one was just discarded.
Dialogue: 0,0:10:40.70,0:10:44.84,Default,,0,0,0,,我们还可以设计更复杂的冲突解决策略\NBut we can also devise more sophisticated conflict resolution policies.
Dialogue: 0,0:10:44.84,0:10:50.28,Default,,0,0,0,,我在这个领域做了一些合并算法的研究\NAnd I've actually done some research in this area on merge algorithms,
Dialogue: 0,0:10:50.28,0:10:53.04,Default,,0,0,0,,基本方法是设计适合并发更新操作的数据结构\Nwhich will take concurrently updated data structures
Dialogue: 0,0:10:53.04,0:10:58.46,Default,,0,0,0,,并把结果合并到一起 得到清晰的最终状态 以解决冲突问题\Nand merge them together into a clean final state to resolve the conflict.
Dialogue: 0,0:10:58.46,0:11:00.60,Default,,0,0,0,,这就是最终一致性的概念\NSo, that's eventual consistency.
Dialogue: 0,0:11:00.60,0:11:06.22,Default,,0,0,0,,我们现在回顾一下本节课讲解的一致性模型和算法\NI'll now recap the consistency models and algorithms that we talked about in this lecture,
Dialogue: 0,0:11:06.22,0:11:10.68,Default,,0,0,0,,我们按照所需系统模型假设从强到弱的顺序\Nand do that in the order of how strong the assumptions are
Dialogue: 0,0:11:10.68,0:11:12.18,Default,,0,0,0,,依次回顾各个模型和算法\Nthat they make about the system model.
Dialogue: 0,0:11:12.18,0:11:16.62,Default,,0,0,0,,这种不同算法的比较方法会比较有意义一些\NThis is an interesting way of comparing these different algorithms and approaches.
Dialogue: 0,0:11:16.62,0:11:20.50,Default,,0,0,0,,首先 我们从实现原子提交的两阶段提交开始\NSo, first of all, we started with atomic commitment as in two-phase commit.
Dialogue: 0,0:11:20.50,0:11:24.76,Default,,0,0,0,,回忆一下 原子提交的模型是\NAnd remember that the model with atomic commit is that
Dialogue: 0,0:11:24.76,0:11:29.96,Default,,0,0,0,,只有当所有参与节点都投提交票 才可以提交某一事务\Na transaction can commit only if all of the participating nodes vote to commit.
Dialogue: 0,0:11:29.96,0:11:31.10,Default,,0,0,0,,这意味着\NAnd so, this means that
Dialogue: 0,0:11:31.10,0:11:35.68,Default,,0,0,0,,原子提交要求与所有参与节点进行通信 这是不可避免的\Ninevitably, atomic commit requires communicating with all participating nodes,
Dialogue: 0,0:11:35.68,0:11:37.58,Default,,0,0,0,,而某个事务的参与节点可能是系统中的所有节点\Nwhich might be all nodes in the system.
Dialogue: 0,0:11:37.58,0:11:40.82,Default,,0,0,0,,如果任意一个节点崩溃\NSo, if any one node is crashed,
Dialogue: 0,0:11:41.68,0:11:44.80,Default,,0,0,0,,原子提交就不能提交任何事务了\Natomic commit will not be able to commit any transactions.
Dialogue: 0,0:11:44.80,0:11:47.78,Default,,0,0,0,,为了实现原子提交\NSo, this is a very strong assumption that we have to make
Dialogue: 0,0:11:47.78,0:11:49.90,Default,,0,0,0,,我们必须为系统通信设置非常强的假设\Nabout the communication that happens in the system.
Dialogue: 0,0:11:49.90,0:11:53.02,Default,,0,0,0,,提交事务时 我们必须与所有节点通信并等待它们的响应\NWe have to communicate with all nodes and wait for their response.
Dialogue: 0,0:11:53.02,0:11:57.00,Default,,0,0,0,,进一步 我们必须假设部分同步系统模型\NMoreover, we have to assume a partially synchronous system model,
Dialogue: 0,0:11:57.00,0:12:01.72,Default,,0,0,0,,因为我们在协议中必须设置超时机制和失效检查机制\Nbecause we have timeouts and failure detection that has to happen.
Dialogue: 0,0:12:01.72,0:12:06.96,Default,,0,0,0,,系统模型假设弱一级的是共识和全序关系广播\NNow, one step down from this is consensus and total order broadcast.
Dialogue: 0,0:12:06.96,0:12:09.82,Default,,0,0,0,,FLP的结论告诉我们\NAnd so, consensus and total order broadcast,
Dialogue: 0,0:12:09.82,0:12:14.92,Default,,0,0,0,,共识和全序关系广播也要求部分同步系统模型\Nthe FLP result told us that this also requires a partially synchronous model.
Dialogue: 0,0:12:14.92,0:12:16.70,Default,,0,0,0,,FLP的结论称\NSo, the FLP result says that
Dialogue: 0,0:12:16.70,0:12:20.50,Default,,0,0,0,,不存在实现共识的异步网络模型算法\Nthere's no asynchronous algorithm for implementing consensus.
Dialogue: 0,0:12:20.50,0:12:24.28,Default,,0,0,0,,因此 我们必须假设部分同步系统模型\NAnd so, therefore, partial synchrony is what we have to assume.
Dialogue: 0,0:12:24.28,0:12:29.32,Default,,0,0,0,,但共识对于通信的假设要稍弱一些\NBut in terms of the communication, consensus actually assumes a bit less,
Dialogue: 0,0:12:29.32,0:12:32.18,Default,,0,0,0,,因为共识仅要求与quorum通信\Nbecause it only requires communication with a quorum.
Dialogue: 0,0:12:32.18,0:12:36.88,Default,,0,0,0,,因此 我们可以容忍少数节点不可用\NAnd so, therefore, we can tolerate a minority of nodes being unavailable,
Dialogue: 0,0:12:36.88,0:12:40.52,Default,,0,0,0,,即使少数节点不可用 算法仍然可以正常处理请求\Nand the algorithm will still be able to make progress and complete as normal.
Dialogue: 0,0:12:40.52,0:12:43.24,Default,,0,0,0,,共识和全序关系广播都使用这一稍弱的通信假设\NAnd so, this holds for consensus and total order broadcast,
Dialogue: 0,0:12:43.24,0:12:45.38,Default,,0,0,0,,我们前面讲过 这两种协议是等价的\Nwhich are equivalent to each other as we said.
Dialogue: 0,0:12:45.38,0:12:48.70,Default,,0,0,0,,进一步 我们学习了满足线性一致性的比较交换\NMoreover, we saw that for linearizable compare-and-swap,
Dialogue: 0,0:12:48.70,0:12:51.30,Default,,0,0,0,,我们可以使用全序关系广播实现满足线性一致性的比较交换\Nwe can implement that using total order broadcast.
Dialogue: 0,0:12:51.30,0:12:53.28,Default,,0,0,0,,实际上 可以证明\NAnd in fact, it is possible to prove that
Dialogue: 0,0:12:53.28,0:12:56.70,Default,,0,0,0,,满足线性一致性的比较交换与共识是等价的\Nlinearizable compare-and-swap is also equivalent to consensus.
Dialogue: 0,0:12:56.70,0:12:59.94,Default,,0,0,0,,这三个问题可以相互归约\NSo, all these three problems are actually reducible to each other.
Dialogue: 0,0:12:59.94,0:13:04.60,Default,,0,0,0,,它们都要求与quorum通信、都假设部分同步网络模型\NThey all have the property that they require a quorum and partial synchrony.
Dialogue: 0,0:13:04.60,0:13:07.36,Default,,0,0,0,,有趣的是 列表继续往下\NMoving down in the list, interestingly,
Dialogue: 0,0:13:07.36,0:13:10.38,Default,,0,0,0,,满足线性一致性的get和set操作\Na linearizable get and set operation
Dialogue: 0,0:13:10.38,0:13:14.96,Default,,0,0,0,,比满足线性一致性的比较交换操作要求的系统模型假设又弱一级\Nhas weaker assumptions than a linearizable compare-and-swap operation,
Dialogue: 0,0:13:14.96,0:13:19.86,Default,,0,0,0,,因为我们可以使用前面介绍的ABD算法实现get和set操作\Nbecause for get and set, we can just use the approach we saw earlier, the ABD algorithm,
Dialogue: 0,0:13:19.86,0:13:24.64,Default,,0,0,0,,即使用quorum读和带读修复的quorum写来实现\Nwhich means quorum writes and quorum reads with read repair.
Dialogue: 0,0:13:24.64,0:13:29.00,Default,,0,0,0,,这仍然要求与quorum节点通信\NAnd this still requires communicating with a quorum of nodes,
Dialogue: 0,0:13:29.00,0:13:30.36,Default,,0,0,0,,但请注意\Nbut notice that
Dialogue: 0,0:13:30.36,0:13:34.04,Default,,0,0,0,,这个算法不需要计时器 不需要超时机制 不需要失效检查器\Nin this algorithm, there are no timers, there are no timeouts, there's no failure detection.
Dialogue: 0,0:13:34.04,0:13:38.60,Default,,0,0,0,,此算法是完全异步的 不需要引入任何时钟\NThe algorithm is actually completely asynchronous. It doesn't require on clocks at all.
Dialogue: 0,0:13:38.60,0:13:40.48,Default,,0,0,0,,因此 这意味着\NAnd so, this means that
Dialogue: 0,0:13:40.48,0:13:42.70,Default,,0,0,0,,满足线性一致性的get和set操作\Nactually linearizable get and set
Dialogue: 0,0:13:42.70,0:13:47.86,Default,,0,0,0,,所要求的系统模型假设被比满足线性一致性的比较交换操作更弱\Nhas weaker assumptions about the system model than compare-and-swap.
Dialogue: 0,0:13:47.86,0:13:51.68,Default,,0,0,0,,最后 我们一直向下移动到我们能做出的最弱假设\NAnd finally, as we move all the way down to the weakest assumptions that we can make,
Dialogue: 0,0:13:51.68,0:13:54.12,Default,,0,0,0,,我们有了最终一致性\Nnow we're with eventual consistency,
Dialogue: 0,0:13:54.72,0:14:00.62,Default,,0,0,0,,即每个副本都可以更新和读取自己的本地状态\Nwhere every replica can update and read its own local state
Dialogue: 0,0:14:00.62,0:14:03.82,Default,,0,0,0,,更新和读取时不需要等待来自其他任何副本的通信\Nwithout waiting for any communication with any other replica.
Dialogue: 0,0:14:03.82,0:14:06.60,Default,,0,0,0,,最终一致性的通信要求是最小的\NSo, the communication need is totally minimized here.
Dialogue: 0,0:14:06.60,0:14:08.94,Default,,0,0,0,,我们也不需要时间假设\NAnd we still make no timing assumptions.
Dialogue: 0,0:14:08.94,0:14:11.34,Default,,0,0,0,,对于最终一致性和强一致性\NSo, this is about the weakest that we can assume
Dialogue: 0,0:14:11.82,0:14:15.30,Default,,0,0,0,,我们可以设置最弱的系统假设\Nfor both eventual consistency and strong eventual consistency.
Dialogue: 0,0:14:15.30,0:14:17.96,Default,,0,0,0,,同样 对于广播协议\NAnd also, in terms of the broadcast protocols,
Dialogue: 0,0:14:17.96,0:14:22.86,Default,,0,0,0,,即因果关系广播、FIFO广播、可靠广播和尽力广播来说\Ncausal broadcast, FIFO broadcast, reliable broadcast and best-effort broadcast,
Dialogue: 0,0:14:22.86,0:14:29.62,Default,,0,0,0,,所有这些协议都满足的一个性质是 节点可以立刻给自己传递消息\Nall of these have the property that they can deliver a message to themselves immediately.
Dialogue: 0,0:14:29.62,0:14:33.20,Default,,0,0,0,,节点不需要等待来自其他任何节点的通信\NA node doesn't have to wait for communication with any other node
Dialogue: 0,0:14:33.20,0:14:35.80,Default,,0,0,0,,就可以给自己传递消息\Nin order to deliver a message to itself.
Dialogue: 0,0:14:35.80,0:14:40.06,Default,,0,0,0,,因此 这些协议也满足的一个性质是 如果传递的消息是更新操作\NAnd this thus also has the property that if these messages are updates,
Dialogue: 0,0:14:40.06,0:14:44.16,Default,,0,0,0,,则不需要等待任何通信即可在本地应用此更新操作\Nthat means updates can be applied locally without waiting for any communication.
Dialogue: 0,0:14:44.16,0:14:46.72,Default,,0,0,0,,也就是说\NSo, this also has the property that
Dialogue: 0,0:14:47.76,0:14:53.12,Default,,0,0,0,,这些协议在处理本地更新操作时也不需要等待任何通信\Nno waiting for communication is required in order to process local updates.
Dialogue: 0,0:14:53.12,0:14:56.80,Default,,0,0,0,,这就是今天有关一致性模型的全部内容了\NSo, that's all on consistency models for today.
